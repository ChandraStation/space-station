/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from 'protobufjs/minimal';

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const gravity = $root.gravity = (() => {

    /**
     * Namespace gravity.
     * @exports gravity
     * @namespace
     */
    const gravity = {};

    gravity.v1 = (function() {

        /**
         * Namespace v1.
         * @memberof gravity
         * @namespace
         */
        const v1 = {};

        /**
         * ClaimType enum.
         * @name gravity.v1.ClaimType
         * @enum {number}
         * @property {number} CLAIM_TYPE_UNSPECIFIED=0 CLAIM_TYPE_UNSPECIFIED value
         * @property {number} CLAIM_TYPE_SEND_TO_COSMOS=1 CLAIM_TYPE_SEND_TO_COSMOS value
         * @property {number} CLAIM_TYPE_BATCH_SEND_TO_ETH=2 CLAIM_TYPE_BATCH_SEND_TO_ETH value
         * @property {number} CLAIM_TYPE_ERC20_DEPLOYED=3 CLAIM_TYPE_ERC20_DEPLOYED value
         * @property {number} CLAIM_TYPE_LOGIC_CALL_EXECUTED=4 CLAIM_TYPE_LOGIC_CALL_EXECUTED value
         * @property {number} CLAIM_TYPE_VALSET_UPDATED=5 CLAIM_TYPE_VALSET_UPDATED value
         */
        v1.ClaimType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CLAIM_TYPE_UNSPECIFIED"] = 0;
            values[valuesById[1] = "CLAIM_TYPE_SEND_TO_COSMOS"] = 1;
            values[valuesById[2] = "CLAIM_TYPE_BATCH_SEND_TO_ETH"] = 2;
            values[valuesById[3] = "CLAIM_TYPE_ERC20_DEPLOYED"] = 3;
            values[valuesById[4] = "CLAIM_TYPE_LOGIC_CALL_EXECUTED"] = 4;
            values[valuesById[5] = "CLAIM_TYPE_VALSET_UPDATED"] = 5;
            return values;
        })();

        v1.Attestation = (function() {

            /**
             * Properties of an Attestation.
             * @memberof gravity.v1
             * @interface IAttestation
             * @property {boolean|null} [observed] Attestation observed
             * @property {Array.<string>|null} [votes] Attestation votes
             * @property {Long|null} [height] Attestation height
             * @property {google.protobuf.IAny|null} [claim] Attestation claim
             */

            /**
             * Constructs a new Attestation.
             * @memberof gravity.v1
             * @classdesc Represents an Attestation.
             * @implements IAttestation
             * @constructor
             * @param {gravity.v1.IAttestation=} [properties] Properties to set
             */
            function Attestation(properties) {
                this.votes = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Attestation observed.
             * @member {boolean} observed
             * @memberof gravity.v1.Attestation
             * @instance
             */
            Attestation.prototype.observed = false;

            /**
             * Attestation votes.
             * @member {Array.<string>} votes
             * @memberof gravity.v1.Attestation
             * @instance
             */
            Attestation.prototype.votes = $util.emptyArray;

            /**
             * Attestation height.
             * @member {Long} height
             * @memberof gravity.v1.Attestation
             * @instance
             */
            Attestation.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Attestation claim.
             * @member {google.protobuf.IAny|null|undefined} claim
             * @memberof gravity.v1.Attestation
             * @instance
             */
            Attestation.prototype.claim = null;

            /**
             * Encodes the specified Attestation message. Does not implicitly {@link gravity.v1.Attestation.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.Attestation
             * @static
             * @param {gravity.v1.IAttestation} message Attestation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Attestation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.observed != null && Object.hasOwnProperty.call(message, "observed"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.observed);
                if (message.votes != null && message.votes.length)
                    for (let i = 0; i < message.votes.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.votes[i]);
                if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.height);
                if (message.claim != null && Object.hasOwnProperty.call(message, "claim"))
                    $root.google.protobuf.Any.encode(message.claim, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Attestation message, length delimited. Does not implicitly {@link gravity.v1.Attestation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.Attestation
             * @static
             * @param {gravity.v1.IAttestation} message Attestation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Attestation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Attestation message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.Attestation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.Attestation} Attestation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Attestation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.Attestation();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.observed = reader.bool();
                        break;
                    case 2:
                        if (!(message.votes && message.votes.length))
                            message.votes = [];
                        message.votes.push(reader.string());
                        break;
                    case 3:
                        message.height = reader.uint64();
                        break;
                    case 4:
                        message.claim = $root.google.protobuf.Any.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Attestation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.Attestation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.Attestation} Attestation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Attestation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Attestation message.
             * @function verify
             * @memberof gravity.v1.Attestation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Attestation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.observed != null && message.hasOwnProperty("observed"))
                    if (typeof message.observed !== "boolean")
                        return "observed: boolean expected";
                if (message.votes != null && message.hasOwnProperty("votes")) {
                    if (!Array.isArray(message.votes))
                        return "votes: array expected";
                    for (let i = 0; i < message.votes.length; ++i)
                        if (!$util.isString(message.votes[i]))
                            return "votes: string[] expected";
                }
                if (message.height != null && message.hasOwnProperty("height"))
                    if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                        return "height: integer|Long expected";
                if (message.claim != null && message.hasOwnProperty("claim")) {
                    let error = $root.google.protobuf.Any.verify(message.claim);
                    if (error)
                        return "claim." + error;
                }
                return null;
            };

            /**
             * Creates an Attestation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.Attestation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.Attestation} Attestation
             */
            Attestation.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.Attestation)
                    return object;
                let message = new $root.gravity.v1.Attestation();
                if (object.observed != null)
                    message.observed = Boolean(object.observed);
                if (object.votes) {
                    if (!Array.isArray(object.votes))
                        throw TypeError(".gravity.v1.Attestation.votes: array expected");
                    message.votes = [];
                    for (let i = 0; i < object.votes.length; ++i)
                        message.votes[i] = String(object.votes[i]);
                }
                if (object.height != null)
                    if ($util.Long)
                        (message.height = $util.Long.fromValue(object.height)).unsigned = true;
                    else if (typeof object.height === "string")
                        message.height = parseInt(object.height, 10);
                    else if (typeof object.height === "number")
                        message.height = object.height;
                    else if (typeof object.height === "object")
                        message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
                if (object.claim != null) {
                    if (typeof object.claim !== "object")
                        throw TypeError(".gravity.v1.Attestation.claim: object expected");
                    message.claim = $root.google.protobuf.Any.fromObject(object.claim);
                }
                return message;
            };

            /**
             * Creates a plain object from an Attestation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.Attestation
             * @static
             * @param {gravity.v1.Attestation} message Attestation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Attestation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.votes = [];
                if (options.defaults) {
                    object.observed = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.height = options.longs === String ? "0" : 0;
                    object.claim = null;
                }
                if (message.observed != null && message.hasOwnProperty("observed"))
                    object.observed = message.observed;
                if (message.votes && message.votes.length) {
                    object.votes = [];
                    for (let j = 0; j < message.votes.length; ++j)
                        object.votes[j] = message.votes[j];
                }
                if (message.height != null && message.hasOwnProperty("height"))
                    if (typeof message.height === "number")
                        object.height = options.longs === String ? String(message.height) : message.height;
                    else
                        object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
                if (message.claim != null && message.hasOwnProperty("claim"))
                    object.claim = $root.google.protobuf.Any.toObject(message.claim, options);
                return object;
            };

            /**
             * Converts this Attestation to JSON.
             * @function toJSON
             * @memberof gravity.v1.Attestation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Attestation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Attestation;
        })();

        v1.ERC20Token = (function() {

            /**
             * Properties of a ERC20Token.
             * @memberof gravity.v1
             * @interface IERC20Token
             * @property {string|null} [contract] ERC20Token contract
             * @property {string|null} [amount] ERC20Token amount
             */

            /**
             * Constructs a new ERC20Token.
             * @memberof gravity.v1
             * @classdesc Represents a ERC20Token.
             * @implements IERC20Token
             * @constructor
             * @param {gravity.v1.IERC20Token=} [properties] Properties to set
             */
            function ERC20Token(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ERC20Token contract.
             * @member {string} contract
             * @memberof gravity.v1.ERC20Token
             * @instance
             */
            ERC20Token.prototype.contract = "";

            /**
             * ERC20Token amount.
             * @member {string} amount
             * @memberof gravity.v1.ERC20Token
             * @instance
             */
            ERC20Token.prototype.amount = "";

            /**
             * Encodes the specified ERC20Token message. Does not implicitly {@link gravity.v1.ERC20Token.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.ERC20Token
             * @static
             * @param {gravity.v1.IERC20Token} message ERC20Token message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ERC20Token.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contract != null && Object.hasOwnProperty.call(message, "contract"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contract);
                if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.amount);
                return writer;
            };

            /**
             * Encodes the specified ERC20Token message, length delimited. Does not implicitly {@link gravity.v1.ERC20Token.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.ERC20Token
             * @static
             * @param {gravity.v1.IERC20Token} message ERC20Token message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ERC20Token.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ERC20Token message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.ERC20Token
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.ERC20Token} ERC20Token
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ERC20Token.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.ERC20Token();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.contract = reader.string();
                        break;
                    case 2:
                        message.amount = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ERC20Token message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.ERC20Token
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.ERC20Token} ERC20Token
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ERC20Token.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ERC20Token message.
             * @function verify
             * @memberof gravity.v1.ERC20Token
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ERC20Token.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contract != null && message.hasOwnProperty("contract"))
                    if (!$util.isString(message.contract))
                        return "contract: string expected";
                if (message.amount != null && message.hasOwnProperty("amount"))
                    if (!$util.isString(message.amount))
                        return "amount: string expected";
                return null;
            };

            /**
             * Creates a ERC20Token message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.ERC20Token
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.ERC20Token} ERC20Token
             */
            ERC20Token.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.ERC20Token)
                    return object;
                let message = new $root.gravity.v1.ERC20Token();
                if (object.contract != null)
                    message.contract = String(object.contract);
                if (object.amount != null)
                    message.amount = String(object.amount);
                return message;
            };

            /**
             * Creates a plain object from a ERC20Token message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.ERC20Token
             * @static
             * @param {gravity.v1.ERC20Token} message ERC20Token
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ERC20Token.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contract = "";
                    object.amount = "";
                }
                if (message.contract != null && message.hasOwnProperty("contract"))
                    object.contract = message.contract;
                if (message.amount != null && message.hasOwnProperty("amount"))
                    object.amount = message.amount;
                return object;
            };

            /**
             * Converts this ERC20Token to JSON.
             * @function toJSON
             * @memberof gravity.v1.ERC20Token
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ERC20Token.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ERC20Token;
        })();

        v1.IDSet = (function() {

            /**
             * Properties of a IDSet.
             * @memberof gravity.v1
             * @interface IIDSet
             * @property {Array.<Long>|null} [ids] IDSet ids
             */

            /**
             * Constructs a new IDSet.
             * @memberof gravity.v1
             * @classdesc Represents a IDSet.
             * @implements IIDSet
             * @constructor
             * @param {gravity.v1.IIDSet=} [properties] Properties to set
             */
            function IDSet(properties) {
                this.ids = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IDSet ids.
             * @member {Array.<Long>} ids
             * @memberof gravity.v1.IDSet
             * @instance
             */
            IDSet.prototype.ids = $util.emptyArray;

            /**
             * Encodes the specified IDSet message. Does not implicitly {@link gravity.v1.IDSet.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.IDSet
             * @static
             * @param {gravity.v1.IIDSet} message IDSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IDSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ids != null && message.ids.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (let i = 0; i < message.ids.length; ++i)
                        writer.uint64(message.ids[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified IDSet message, length delimited. Does not implicitly {@link gravity.v1.IDSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.IDSet
             * @static
             * @param {gravity.v1.IIDSet} message IDSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IDSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a IDSet message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.IDSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.IDSet} IDSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IDSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.IDSet();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.ids && message.ids.length))
                            message.ids = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.ids.push(reader.uint64());
                        } else
                            message.ids.push(reader.uint64());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a IDSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.IDSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.IDSet} IDSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IDSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a IDSet message.
             * @function verify
             * @memberof gravity.v1.IDSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IDSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ids != null && message.hasOwnProperty("ids")) {
                    if (!Array.isArray(message.ids))
                        return "ids: array expected";
                    for (let i = 0; i < message.ids.length; ++i)
                        if (!$util.isInteger(message.ids[i]) && !(message.ids[i] && $util.isInteger(message.ids[i].low) && $util.isInteger(message.ids[i].high)))
                            return "ids: integer|Long[] expected";
                }
                return null;
            };

            /**
             * Creates a IDSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.IDSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.IDSet} IDSet
             */
            IDSet.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.IDSet)
                    return object;
                let message = new $root.gravity.v1.IDSet();
                if (object.ids) {
                    if (!Array.isArray(object.ids))
                        throw TypeError(".gravity.v1.IDSet.ids: array expected");
                    message.ids = [];
                    for (let i = 0; i < object.ids.length; ++i)
                        if ($util.Long)
                            (message.ids[i] = $util.Long.fromValue(object.ids[i])).unsigned = true;
                        else if (typeof object.ids[i] === "string")
                            message.ids[i] = parseInt(object.ids[i], 10);
                        else if (typeof object.ids[i] === "number")
                            message.ids[i] = object.ids[i];
                        else if (typeof object.ids[i] === "object")
                            message.ids[i] = new $util.LongBits(object.ids[i].low >>> 0, object.ids[i].high >>> 0).toNumber(true);
                }
                return message;
            };

            /**
             * Creates a plain object from a IDSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.IDSet
             * @static
             * @param {gravity.v1.IDSet} message IDSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IDSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.ids = [];
                if (message.ids && message.ids.length) {
                    object.ids = [];
                    for (let j = 0; j < message.ids.length; ++j)
                        if (typeof message.ids[j] === "number")
                            object.ids[j] = options.longs === String ? String(message.ids[j]) : message.ids[j];
                        else
                            object.ids[j] = options.longs === String ? $util.Long.prototype.toString.call(message.ids[j]) : options.longs === Number ? new $util.LongBits(message.ids[j].low >>> 0, message.ids[j].high >>> 0).toNumber(true) : message.ids[j];
                }
                return object;
            };

            /**
             * Converts this IDSet to JSON.
             * @function toJSON
             * @memberof gravity.v1.IDSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IDSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IDSet;
        })();

        v1.BatchFees = (function() {

            /**
             * Properties of a BatchFees.
             * @memberof gravity.v1
             * @interface IBatchFees
             * @property {string|null} [token] BatchFees token
             * @property {string|null} [total_fees] BatchFees total_fees
             */

            /**
             * Constructs a new BatchFees.
             * @memberof gravity.v1
             * @classdesc Represents a BatchFees.
             * @implements IBatchFees
             * @constructor
             * @param {gravity.v1.IBatchFees=} [properties] Properties to set
             */
            function BatchFees(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BatchFees token.
             * @member {string} token
             * @memberof gravity.v1.BatchFees
             * @instance
             */
            BatchFees.prototype.token = "";

            /**
             * BatchFees total_fees.
             * @member {string} total_fees
             * @memberof gravity.v1.BatchFees
             * @instance
             */
            BatchFees.prototype.total_fees = "";

            /**
             * Encodes the specified BatchFees message. Does not implicitly {@link gravity.v1.BatchFees.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.BatchFees
             * @static
             * @param {gravity.v1.IBatchFees} message BatchFees message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchFees.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
                if (message.total_fees != null && Object.hasOwnProperty.call(message, "total_fees"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.total_fees);
                return writer;
            };

            /**
             * Encodes the specified BatchFees message, length delimited. Does not implicitly {@link gravity.v1.BatchFees.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.BatchFees
             * @static
             * @param {gravity.v1.IBatchFees} message BatchFees message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchFees.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BatchFees message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.BatchFees
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.BatchFees} BatchFees
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchFees.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.BatchFees();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.token = reader.string();
                        break;
                    case 2:
                        message.total_fees = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BatchFees message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.BatchFees
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.BatchFees} BatchFees
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchFees.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BatchFees message.
             * @function verify
             * @memberof gravity.v1.BatchFees
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchFees.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    if (!$util.isString(message.token))
                        return "token: string expected";
                if (message.total_fees != null && message.hasOwnProperty("total_fees"))
                    if (!$util.isString(message.total_fees))
                        return "total_fees: string expected";
                return null;
            };

            /**
             * Creates a BatchFees message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.BatchFees
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.BatchFees} BatchFees
             */
            BatchFees.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.BatchFees)
                    return object;
                let message = new $root.gravity.v1.BatchFees();
                if (object.token != null)
                    message.token = String(object.token);
                if (object.total_fees != null)
                    message.total_fees = String(object.total_fees);
                return message;
            };

            /**
             * Creates a plain object from a BatchFees message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.BatchFees
             * @static
             * @param {gravity.v1.BatchFees} message BatchFees
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchFees.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.token = "";
                    object.total_fees = "";
                }
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = message.token;
                if (message.total_fees != null && message.hasOwnProperty("total_fees"))
                    object.total_fees = message.total_fees;
                return object;
            };

            /**
             * Converts this BatchFees to JSON.
             * @function toJSON
             * @memberof gravity.v1.BatchFees
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchFees.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BatchFees;
        })();

        v1.OutgoingTxBatch = (function() {

            /**
             * Properties of an OutgoingTxBatch.
             * @memberof gravity.v1
             * @interface IOutgoingTxBatch
             * @property {Long|null} [batch_nonce] OutgoingTxBatch batch_nonce
             * @property {Long|null} [batch_timeout] OutgoingTxBatch batch_timeout
             * @property {Array.<gravity.v1.IOutgoingTransferTx>|null} [transactions] OutgoingTxBatch transactions
             * @property {string|null} [token_contract] OutgoingTxBatch token_contract
             * @property {Long|null} [block] OutgoingTxBatch block
             */

            /**
             * Constructs a new OutgoingTxBatch.
             * @memberof gravity.v1
             * @classdesc Represents an OutgoingTxBatch.
             * @implements IOutgoingTxBatch
             * @constructor
             * @param {gravity.v1.IOutgoingTxBatch=} [properties] Properties to set
             */
            function OutgoingTxBatch(properties) {
                this.transactions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OutgoingTxBatch batch_nonce.
             * @member {Long} batch_nonce
             * @memberof gravity.v1.OutgoingTxBatch
             * @instance
             */
            OutgoingTxBatch.prototype.batch_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * OutgoingTxBatch batch_timeout.
             * @member {Long} batch_timeout
             * @memberof gravity.v1.OutgoingTxBatch
             * @instance
             */
            OutgoingTxBatch.prototype.batch_timeout = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * OutgoingTxBatch transactions.
             * @member {Array.<gravity.v1.IOutgoingTransferTx>} transactions
             * @memberof gravity.v1.OutgoingTxBatch
             * @instance
             */
            OutgoingTxBatch.prototype.transactions = $util.emptyArray;

            /**
             * OutgoingTxBatch token_contract.
             * @member {string} token_contract
             * @memberof gravity.v1.OutgoingTxBatch
             * @instance
             */
            OutgoingTxBatch.prototype.token_contract = "";

            /**
             * OutgoingTxBatch block.
             * @member {Long} block
             * @memberof gravity.v1.OutgoingTxBatch
             * @instance
             */
            OutgoingTxBatch.prototype.block = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified OutgoingTxBatch message. Does not implicitly {@link gravity.v1.OutgoingTxBatch.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.OutgoingTxBatch
             * @static
             * @param {gravity.v1.IOutgoingTxBatch} message OutgoingTxBatch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OutgoingTxBatch.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.batch_nonce != null && Object.hasOwnProperty.call(message, "batch_nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.batch_nonce);
                if (message.batch_timeout != null && Object.hasOwnProperty.call(message, "batch_timeout"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.batch_timeout);
                if (message.transactions != null && message.transactions.length)
                    for (let i = 0; i < message.transactions.length; ++i)
                        $root.gravity.v1.OutgoingTransferTx.encode(message.transactions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.token_contract != null && Object.hasOwnProperty.call(message, "token_contract"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.token_contract);
                if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.block);
                return writer;
            };

            /**
             * Encodes the specified OutgoingTxBatch message, length delimited. Does not implicitly {@link gravity.v1.OutgoingTxBatch.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.OutgoingTxBatch
             * @static
             * @param {gravity.v1.IOutgoingTxBatch} message OutgoingTxBatch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OutgoingTxBatch.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OutgoingTxBatch message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.OutgoingTxBatch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.OutgoingTxBatch} OutgoingTxBatch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OutgoingTxBatch.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.OutgoingTxBatch();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.batch_nonce = reader.uint64();
                        break;
                    case 2:
                        message.batch_timeout = reader.uint64();
                        break;
                    case 3:
                        if (!(message.transactions && message.transactions.length))
                            message.transactions = [];
                        message.transactions.push($root.gravity.v1.OutgoingTransferTx.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.token_contract = reader.string();
                        break;
                    case 5:
                        message.block = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OutgoingTxBatch message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.OutgoingTxBatch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.OutgoingTxBatch} OutgoingTxBatch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OutgoingTxBatch.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OutgoingTxBatch message.
             * @function verify
             * @memberof gravity.v1.OutgoingTxBatch
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OutgoingTxBatch.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.batch_nonce != null && message.hasOwnProperty("batch_nonce"))
                    if (!$util.isInteger(message.batch_nonce) && !(message.batch_nonce && $util.isInteger(message.batch_nonce.low) && $util.isInteger(message.batch_nonce.high)))
                        return "batch_nonce: integer|Long expected";
                if (message.batch_timeout != null && message.hasOwnProperty("batch_timeout"))
                    if (!$util.isInteger(message.batch_timeout) && !(message.batch_timeout && $util.isInteger(message.batch_timeout.low) && $util.isInteger(message.batch_timeout.high)))
                        return "batch_timeout: integer|Long expected";
                if (message.transactions != null && message.hasOwnProperty("transactions")) {
                    if (!Array.isArray(message.transactions))
                        return "transactions: array expected";
                    for (let i = 0; i < message.transactions.length; ++i) {
                        let error = $root.gravity.v1.OutgoingTransferTx.verify(message.transactions[i]);
                        if (error)
                            return "transactions." + error;
                    }
                }
                if (message.token_contract != null && message.hasOwnProperty("token_contract"))
                    if (!$util.isString(message.token_contract))
                        return "token_contract: string expected";
                if (message.block != null && message.hasOwnProperty("block"))
                    if (!$util.isInteger(message.block) && !(message.block && $util.isInteger(message.block.low) && $util.isInteger(message.block.high)))
                        return "block: integer|Long expected";
                return null;
            };

            /**
             * Creates an OutgoingTxBatch message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.OutgoingTxBatch
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.OutgoingTxBatch} OutgoingTxBatch
             */
            OutgoingTxBatch.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.OutgoingTxBatch)
                    return object;
                let message = new $root.gravity.v1.OutgoingTxBatch();
                if (object.batch_nonce != null)
                    if ($util.Long)
                        (message.batch_nonce = $util.Long.fromValue(object.batch_nonce)).unsigned = true;
                    else if (typeof object.batch_nonce === "string")
                        message.batch_nonce = parseInt(object.batch_nonce, 10);
                    else if (typeof object.batch_nonce === "number")
                        message.batch_nonce = object.batch_nonce;
                    else if (typeof object.batch_nonce === "object")
                        message.batch_nonce = new $util.LongBits(object.batch_nonce.low >>> 0, object.batch_nonce.high >>> 0).toNumber(true);
                if (object.batch_timeout != null)
                    if ($util.Long)
                        (message.batch_timeout = $util.Long.fromValue(object.batch_timeout)).unsigned = true;
                    else if (typeof object.batch_timeout === "string")
                        message.batch_timeout = parseInt(object.batch_timeout, 10);
                    else if (typeof object.batch_timeout === "number")
                        message.batch_timeout = object.batch_timeout;
                    else if (typeof object.batch_timeout === "object")
                        message.batch_timeout = new $util.LongBits(object.batch_timeout.low >>> 0, object.batch_timeout.high >>> 0).toNumber(true);
                if (object.transactions) {
                    if (!Array.isArray(object.transactions))
                        throw TypeError(".gravity.v1.OutgoingTxBatch.transactions: array expected");
                    message.transactions = [];
                    for (let i = 0; i < object.transactions.length; ++i) {
                        if (typeof object.transactions[i] !== "object")
                            throw TypeError(".gravity.v1.OutgoingTxBatch.transactions: object expected");
                        message.transactions[i] = $root.gravity.v1.OutgoingTransferTx.fromObject(object.transactions[i]);
                    }
                }
                if (object.token_contract != null)
                    message.token_contract = String(object.token_contract);
                if (object.block != null)
                    if ($util.Long)
                        (message.block = $util.Long.fromValue(object.block)).unsigned = true;
                    else if (typeof object.block === "string")
                        message.block = parseInt(object.block, 10);
                    else if (typeof object.block === "number")
                        message.block = object.block;
                    else if (typeof object.block === "object")
                        message.block = new $util.LongBits(object.block.low >>> 0, object.block.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an OutgoingTxBatch message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.OutgoingTxBatch
             * @static
             * @param {gravity.v1.OutgoingTxBatch} message OutgoingTxBatch
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OutgoingTxBatch.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.transactions = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.batch_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.batch_nonce = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.batch_timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.batch_timeout = options.longs === String ? "0" : 0;
                    object.token_contract = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.block = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.block = options.longs === String ? "0" : 0;
                }
                if (message.batch_nonce != null && message.hasOwnProperty("batch_nonce"))
                    if (typeof message.batch_nonce === "number")
                        object.batch_nonce = options.longs === String ? String(message.batch_nonce) : message.batch_nonce;
                    else
                        object.batch_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.batch_nonce) : options.longs === Number ? new $util.LongBits(message.batch_nonce.low >>> 0, message.batch_nonce.high >>> 0).toNumber(true) : message.batch_nonce;
                if (message.batch_timeout != null && message.hasOwnProperty("batch_timeout"))
                    if (typeof message.batch_timeout === "number")
                        object.batch_timeout = options.longs === String ? String(message.batch_timeout) : message.batch_timeout;
                    else
                        object.batch_timeout = options.longs === String ? $util.Long.prototype.toString.call(message.batch_timeout) : options.longs === Number ? new $util.LongBits(message.batch_timeout.low >>> 0, message.batch_timeout.high >>> 0).toNumber(true) : message.batch_timeout;
                if (message.transactions && message.transactions.length) {
                    object.transactions = [];
                    for (let j = 0; j < message.transactions.length; ++j)
                        object.transactions[j] = $root.gravity.v1.OutgoingTransferTx.toObject(message.transactions[j], options);
                }
                if (message.token_contract != null && message.hasOwnProperty("token_contract"))
                    object.token_contract = message.token_contract;
                if (message.block != null && message.hasOwnProperty("block"))
                    if (typeof message.block === "number")
                        object.block = options.longs === String ? String(message.block) : message.block;
                    else
                        object.block = options.longs === String ? $util.Long.prototype.toString.call(message.block) : options.longs === Number ? new $util.LongBits(message.block.low >>> 0, message.block.high >>> 0).toNumber(true) : message.block;
                return object;
            };

            /**
             * Converts this OutgoingTxBatch to JSON.
             * @function toJSON
             * @memberof gravity.v1.OutgoingTxBatch
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OutgoingTxBatch.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OutgoingTxBatch;
        })();

        v1.OutgoingTransferTx = (function() {

            /**
             * Properties of an OutgoingTransferTx.
             * @memberof gravity.v1
             * @interface IOutgoingTransferTx
             * @property {Long|null} [id] OutgoingTransferTx id
             * @property {string|null} [sender] OutgoingTransferTx sender
             * @property {string|null} [dest_address] OutgoingTransferTx dest_address
             * @property {gravity.v1.IERC20Token|null} [erc20_token] OutgoingTransferTx erc20_token
             * @property {gravity.v1.IERC20Token|null} [erc20_fee] OutgoingTransferTx erc20_fee
             */

            /**
             * Constructs a new OutgoingTransferTx.
             * @memberof gravity.v1
             * @classdesc Represents an OutgoingTransferTx.
             * @implements IOutgoingTransferTx
             * @constructor
             * @param {gravity.v1.IOutgoingTransferTx=} [properties] Properties to set
             */
            function OutgoingTransferTx(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OutgoingTransferTx id.
             * @member {Long} id
             * @memberof gravity.v1.OutgoingTransferTx
             * @instance
             */
            OutgoingTransferTx.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * OutgoingTransferTx sender.
             * @member {string} sender
             * @memberof gravity.v1.OutgoingTransferTx
             * @instance
             */
            OutgoingTransferTx.prototype.sender = "";

            /**
             * OutgoingTransferTx dest_address.
             * @member {string} dest_address
             * @memberof gravity.v1.OutgoingTransferTx
             * @instance
             */
            OutgoingTransferTx.prototype.dest_address = "";

            /**
             * OutgoingTransferTx erc20_token.
             * @member {gravity.v1.IERC20Token|null|undefined} erc20_token
             * @memberof gravity.v1.OutgoingTransferTx
             * @instance
             */
            OutgoingTransferTx.prototype.erc20_token = null;

            /**
             * OutgoingTransferTx erc20_fee.
             * @member {gravity.v1.IERC20Token|null|undefined} erc20_fee
             * @memberof gravity.v1.OutgoingTransferTx
             * @instance
             */
            OutgoingTransferTx.prototype.erc20_fee = null;

            /**
             * Encodes the specified OutgoingTransferTx message. Does not implicitly {@link gravity.v1.OutgoingTransferTx.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.OutgoingTransferTx
             * @static
             * @param {gravity.v1.IOutgoingTransferTx} message OutgoingTransferTx message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OutgoingTransferTx.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.sender);
                if (message.dest_address != null && Object.hasOwnProperty.call(message, "dest_address"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.dest_address);
                if (message.erc20_token != null && Object.hasOwnProperty.call(message, "erc20_token"))
                    $root.gravity.v1.ERC20Token.encode(message.erc20_token, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.erc20_fee != null && Object.hasOwnProperty.call(message, "erc20_fee"))
                    $root.gravity.v1.ERC20Token.encode(message.erc20_fee, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OutgoingTransferTx message, length delimited. Does not implicitly {@link gravity.v1.OutgoingTransferTx.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.OutgoingTransferTx
             * @static
             * @param {gravity.v1.IOutgoingTransferTx} message OutgoingTransferTx message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OutgoingTransferTx.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OutgoingTransferTx message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.OutgoingTransferTx
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.OutgoingTransferTx} OutgoingTransferTx
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OutgoingTransferTx.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.OutgoingTransferTx();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint64();
                        break;
                    case 2:
                        message.sender = reader.string();
                        break;
                    case 3:
                        message.dest_address = reader.string();
                        break;
                    case 4:
                        message.erc20_token = $root.gravity.v1.ERC20Token.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.erc20_fee = $root.gravity.v1.ERC20Token.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OutgoingTransferTx message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.OutgoingTransferTx
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.OutgoingTransferTx} OutgoingTransferTx
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OutgoingTransferTx.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OutgoingTransferTx message.
             * @function verify
             * @memberof gravity.v1.OutgoingTransferTx
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OutgoingTransferTx.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                        return "id: integer|Long expected";
                if (message.sender != null && message.hasOwnProperty("sender"))
                    if (!$util.isString(message.sender))
                        return "sender: string expected";
                if (message.dest_address != null && message.hasOwnProperty("dest_address"))
                    if (!$util.isString(message.dest_address))
                        return "dest_address: string expected";
                if (message.erc20_token != null && message.hasOwnProperty("erc20_token")) {
                    let error = $root.gravity.v1.ERC20Token.verify(message.erc20_token);
                    if (error)
                        return "erc20_token." + error;
                }
                if (message.erc20_fee != null && message.hasOwnProperty("erc20_fee")) {
                    let error = $root.gravity.v1.ERC20Token.verify(message.erc20_fee);
                    if (error)
                        return "erc20_fee." + error;
                }
                return null;
            };

            /**
             * Creates an OutgoingTransferTx message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.OutgoingTransferTx
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.OutgoingTransferTx} OutgoingTransferTx
             */
            OutgoingTransferTx.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.OutgoingTransferTx)
                    return object;
                let message = new $root.gravity.v1.OutgoingTransferTx();
                if (object.id != null)
                    if ($util.Long)
                        (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                    else if (typeof object.id === "string")
                        message.id = parseInt(object.id, 10);
                    else if (typeof object.id === "number")
                        message.id = object.id;
                    else if (typeof object.id === "object")
                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                if (object.sender != null)
                    message.sender = String(object.sender);
                if (object.dest_address != null)
                    message.dest_address = String(object.dest_address);
                if (object.erc20_token != null) {
                    if (typeof object.erc20_token !== "object")
                        throw TypeError(".gravity.v1.OutgoingTransferTx.erc20_token: object expected");
                    message.erc20_token = $root.gravity.v1.ERC20Token.fromObject(object.erc20_token);
                }
                if (object.erc20_fee != null) {
                    if (typeof object.erc20_fee !== "object")
                        throw TypeError(".gravity.v1.OutgoingTransferTx.erc20_fee: object expected");
                    message.erc20_fee = $root.gravity.v1.ERC20Token.fromObject(object.erc20_fee);
                }
                return message;
            };

            /**
             * Creates a plain object from an OutgoingTransferTx message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.OutgoingTransferTx
             * @static
             * @param {gravity.v1.OutgoingTransferTx} message OutgoingTransferTx
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OutgoingTransferTx.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.id = options.longs === String ? "0" : 0;
                    object.sender = "";
                    object.dest_address = "";
                    object.erc20_token = null;
                    object.erc20_fee = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (typeof message.id === "number")
                        object.id = options.longs === String ? String(message.id) : message.id;
                    else
                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                if (message.sender != null && message.hasOwnProperty("sender"))
                    object.sender = message.sender;
                if (message.dest_address != null && message.hasOwnProperty("dest_address"))
                    object.dest_address = message.dest_address;
                if (message.erc20_token != null && message.hasOwnProperty("erc20_token"))
                    object.erc20_token = $root.gravity.v1.ERC20Token.toObject(message.erc20_token, options);
                if (message.erc20_fee != null && message.hasOwnProperty("erc20_fee"))
                    object.erc20_fee = $root.gravity.v1.ERC20Token.toObject(message.erc20_fee, options);
                return object;
            };

            /**
             * Converts this OutgoingTransferTx to JSON.
             * @function toJSON
             * @memberof gravity.v1.OutgoingTransferTx
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OutgoingTransferTx.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OutgoingTransferTx;
        })();

        v1.OutgoingLogicCall = (function() {

            /**
             * Properties of an OutgoingLogicCall.
             * @memberof gravity.v1
             * @interface IOutgoingLogicCall
             * @property {Array.<gravity.v1.IERC20Token>|null} [transfers] OutgoingLogicCall transfers
             * @property {Array.<gravity.v1.IERC20Token>|null} [fees] OutgoingLogicCall fees
             * @property {string|null} [logic_contract_address] OutgoingLogicCall logic_contract_address
             * @property {Uint8Array|null} [payload] OutgoingLogicCall payload
             * @property {Long|null} [timeout] OutgoingLogicCall timeout
             * @property {Uint8Array|null} [invalidation_id] OutgoingLogicCall invalidation_id
             * @property {Long|null} [invalidation_nonce] OutgoingLogicCall invalidation_nonce
             * @property {Long|null} [block] OutgoingLogicCall block
             */

            /**
             * Constructs a new OutgoingLogicCall.
             * @memberof gravity.v1
             * @classdesc Represents an OutgoingLogicCall.
             * @implements IOutgoingLogicCall
             * @constructor
             * @param {gravity.v1.IOutgoingLogicCall=} [properties] Properties to set
             */
            function OutgoingLogicCall(properties) {
                this.transfers = [];
                this.fees = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OutgoingLogicCall transfers.
             * @member {Array.<gravity.v1.IERC20Token>} transfers
             * @memberof gravity.v1.OutgoingLogicCall
             * @instance
             */
            OutgoingLogicCall.prototype.transfers = $util.emptyArray;

            /**
             * OutgoingLogicCall fees.
             * @member {Array.<gravity.v1.IERC20Token>} fees
             * @memberof gravity.v1.OutgoingLogicCall
             * @instance
             */
            OutgoingLogicCall.prototype.fees = $util.emptyArray;

            /**
             * OutgoingLogicCall logic_contract_address.
             * @member {string} logic_contract_address
             * @memberof gravity.v1.OutgoingLogicCall
             * @instance
             */
            OutgoingLogicCall.prototype.logic_contract_address = "";

            /**
             * OutgoingLogicCall payload.
             * @member {Uint8Array} payload
             * @memberof gravity.v1.OutgoingLogicCall
             * @instance
             */
            OutgoingLogicCall.prototype.payload = $util.newBuffer([]);

            /**
             * OutgoingLogicCall timeout.
             * @member {Long} timeout
             * @memberof gravity.v1.OutgoingLogicCall
             * @instance
             */
            OutgoingLogicCall.prototype.timeout = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * OutgoingLogicCall invalidation_id.
             * @member {Uint8Array} invalidation_id
             * @memberof gravity.v1.OutgoingLogicCall
             * @instance
             */
            OutgoingLogicCall.prototype.invalidation_id = $util.newBuffer([]);

            /**
             * OutgoingLogicCall invalidation_nonce.
             * @member {Long} invalidation_nonce
             * @memberof gravity.v1.OutgoingLogicCall
             * @instance
             */
            OutgoingLogicCall.prototype.invalidation_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * OutgoingLogicCall block.
             * @member {Long} block
             * @memberof gravity.v1.OutgoingLogicCall
             * @instance
             */
            OutgoingLogicCall.prototype.block = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified OutgoingLogicCall message. Does not implicitly {@link gravity.v1.OutgoingLogicCall.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.OutgoingLogicCall
             * @static
             * @param {gravity.v1.IOutgoingLogicCall} message OutgoingLogicCall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OutgoingLogicCall.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.transfers != null && message.transfers.length)
                    for (let i = 0; i < message.transfers.length; ++i)
                        $root.gravity.v1.ERC20Token.encode(message.transfers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.fees != null && message.fees.length)
                    for (let i = 0; i < message.fees.length; ++i)
                        $root.gravity.v1.ERC20Token.encode(message.fees[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.logic_contract_address != null && Object.hasOwnProperty.call(message, "logic_contract_address"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.logic_contract_address);
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payload);
                if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.timeout);
                if (message.invalidation_id != null && Object.hasOwnProperty.call(message, "invalidation_id"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.invalidation_id);
                if (message.invalidation_nonce != null && Object.hasOwnProperty.call(message, "invalidation_nonce"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.invalidation_nonce);
                if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.block);
                return writer;
            };

            /**
             * Encodes the specified OutgoingLogicCall message, length delimited. Does not implicitly {@link gravity.v1.OutgoingLogicCall.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.OutgoingLogicCall
             * @static
             * @param {gravity.v1.IOutgoingLogicCall} message OutgoingLogicCall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OutgoingLogicCall.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OutgoingLogicCall message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.OutgoingLogicCall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.OutgoingLogicCall} OutgoingLogicCall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OutgoingLogicCall.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.OutgoingLogicCall();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.transfers && message.transfers.length))
                            message.transfers = [];
                        message.transfers.push($root.gravity.v1.ERC20Token.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.fees && message.fees.length))
                            message.fees = [];
                        message.fees.push($root.gravity.v1.ERC20Token.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.logic_contract_address = reader.string();
                        break;
                    case 4:
                        message.payload = reader.bytes();
                        break;
                    case 5:
                        message.timeout = reader.uint64();
                        break;
                    case 6:
                        message.invalidation_id = reader.bytes();
                        break;
                    case 7:
                        message.invalidation_nonce = reader.uint64();
                        break;
                    case 8:
                        message.block = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OutgoingLogicCall message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.OutgoingLogicCall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.OutgoingLogicCall} OutgoingLogicCall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OutgoingLogicCall.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OutgoingLogicCall message.
             * @function verify
             * @memberof gravity.v1.OutgoingLogicCall
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OutgoingLogicCall.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.transfers != null && message.hasOwnProperty("transfers")) {
                    if (!Array.isArray(message.transfers))
                        return "transfers: array expected";
                    for (let i = 0; i < message.transfers.length; ++i) {
                        let error = $root.gravity.v1.ERC20Token.verify(message.transfers[i]);
                        if (error)
                            return "transfers." + error;
                    }
                }
                if (message.fees != null && message.hasOwnProperty("fees")) {
                    if (!Array.isArray(message.fees))
                        return "fees: array expected";
                    for (let i = 0; i < message.fees.length; ++i) {
                        let error = $root.gravity.v1.ERC20Token.verify(message.fees[i]);
                        if (error)
                            return "fees." + error;
                    }
                }
                if (message.logic_contract_address != null && message.hasOwnProperty("logic_contract_address"))
                    if (!$util.isString(message.logic_contract_address))
                        return "logic_contract_address: string expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    if (!$util.isInteger(message.timeout) && !(message.timeout && $util.isInteger(message.timeout.low) && $util.isInteger(message.timeout.high)))
                        return "timeout: integer|Long expected";
                if (message.invalidation_id != null && message.hasOwnProperty("invalidation_id"))
                    if (!(message.invalidation_id && typeof message.invalidation_id.length === "number" || $util.isString(message.invalidation_id)))
                        return "invalidation_id: buffer expected";
                if (message.invalidation_nonce != null && message.hasOwnProperty("invalidation_nonce"))
                    if (!$util.isInteger(message.invalidation_nonce) && !(message.invalidation_nonce && $util.isInteger(message.invalidation_nonce.low) && $util.isInteger(message.invalidation_nonce.high)))
                        return "invalidation_nonce: integer|Long expected";
                if (message.block != null && message.hasOwnProperty("block"))
                    if (!$util.isInteger(message.block) && !(message.block && $util.isInteger(message.block.low) && $util.isInteger(message.block.high)))
                        return "block: integer|Long expected";
                return null;
            };

            /**
             * Creates an OutgoingLogicCall message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.OutgoingLogicCall
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.OutgoingLogicCall} OutgoingLogicCall
             */
            OutgoingLogicCall.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.OutgoingLogicCall)
                    return object;
                let message = new $root.gravity.v1.OutgoingLogicCall();
                if (object.transfers) {
                    if (!Array.isArray(object.transfers))
                        throw TypeError(".gravity.v1.OutgoingLogicCall.transfers: array expected");
                    message.transfers = [];
                    for (let i = 0; i < object.transfers.length; ++i) {
                        if (typeof object.transfers[i] !== "object")
                            throw TypeError(".gravity.v1.OutgoingLogicCall.transfers: object expected");
                        message.transfers[i] = $root.gravity.v1.ERC20Token.fromObject(object.transfers[i]);
                    }
                }
                if (object.fees) {
                    if (!Array.isArray(object.fees))
                        throw TypeError(".gravity.v1.OutgoingLogicCall.fees: array expected");
                    message.fees = [];
                    for (let i = 0; i < object.fees.length; ++i) {
                        if (typeof object.fees[i] !== "object")
                            throw TypeError(".gravity.v1.OutgoingLogicCall.fees: object expected");
                        message.fees[i] = $root.gravity.v1.ERC20Token.fromObject(object.fees[i]);
                    }
                }
                if (object.logic_contract_address != null)
                    message.logic_contract_address = String(object.logic_contract_address);
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.timeout != null)
                    if ($util.Long)
                        (message.timeout = $util.Long.fromValue(object.timeout)).unsigned = true;
                    else if (typeof object.timeout === "string")
                        message.timeout = parseInt(object.timeout, 10);
                    else if (typeof object.timeout === "number")
                        message.timeout = object.timeout;
                    else if (typeof object.timeout === "object")
                        message.timeout = new $util.LongBits(object.timeout.low >>> 0, object.timeout.high >>> 0).toNumber(true);
                if (object.invalidation_id != null)
                    if (typeof object.invalidation_id === "string")
                        $util.base64.decode(object.invalidation_id, message.invalidation_id = $util.newBuffer($util.base64.length(object.invalidation_id)), 0);
                    else if (object.invalidation_id.length)
                        message.invalidation_id = object.invalidation_id;
                if (object.invalidation_nonce != null)
                    if ($util.Long)
                        (message.invalidation_nonce = $util.Long.fromValue(object.invalidation_nonce)).unsigned = true;
                    else if (typeof object.invalidation_nonce === "string")
                        message.invalidation_nonce = parseInt(object.invalidation_nonce, 10);
                    else if (typeof object.invalidation_nonce === "number")
                        message.invalidation_nonce = object.invalidation_nonce;
                    else if (typeof object.invalidation_nonce === "object")
                        message.invalidation_nonce = new $util.LongBits(object.invalidation_nonce.low >>> 0, object.invalidation_nonce.high >>> 0).toNumber(true);
                if (object.block != null)
                    if ($util.Long)
                        (message.block = $util.Long.fromValue(object.block)).unsigned = true;
                    else if (typeof object.block === "string")
                        message.block = parseInt(object.block, 10);
                    else if (typeof object.block === "number")
                        message.block = object.block;
                    else if (typeof object.block === "object")
                        message.block = new $util.LongBits(object.block.low >>> 0, object.block.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an OutgoingLogicCall message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.OutgoingLogicCall
             * @static
             * @param {gravity.v1.OutgoingLogicCall} message OutgoingLogicCall
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OutgoingLogicCall.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.transfers = [];
                    object.fees = [];
                }
                if (options.defaults) {
                    object.logic_contract_address = "";
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timeout = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.invalidation_id = "";
                    else {
                        object.invalidation_id = [];
                        if (options.bytes !== Array)
                            object.invalidation_id = $util.newBuffer(object.invalidation_id);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.invalidation_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.invalidation_nonce = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.block = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.block = options.longs === String ? "0" : 0;
                }
                if (message.transfers && message.transfers.length) {
                    object.transfers = [];
                    for (let j = 0; j < message.transfers.length; ++j)
                        object.transfers[j] = $root.gravity.v1.ERC20Token.toObject(message.transfers[j], options);
                }
                if (message.fees && message.fees.length) {
                    object.fees = [];
                    for (let j = 0; j < message.fees.length; ++j)
                        object.fees[j] = $root.gravity.v1.ERC20Token.toObject(message.fees[j], options);
                }
                if (message.logic_contract_address != null && message.hasOwnProperty("logic_contract_address"))
                    object.logic_contract_address = message.logic_contract_address;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    if (typeof message.timeout === "number")
                        object.timeout = options.longs === String ? String(message.timeout) : message.timeout;
                    else
                        object.timeout = options.longs === String ? $util.Long.prototype.toString.call(message.timeout) : options.longs === Number ? new $util.LongBits(message.timeout.low >>> 0, message.timeout.high >>> 0).toNumber(true) : message.timeout;
                if (message.invalidation_id != null && message.hasOwnProperty("invalidation_id"))
                    object.invalidation_id = options.bytes === String ? $util.base64.encode(message.invalidation_id, 0, message.invalidation_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.invalidation_id) : message.invalidation_id;
                if (message.invalidation_nonce != null && message.hasOwnProperty("invalidation_nonce"))
                    if (typeof message.invalidation_nonce === "number")
                        object.invalidation_nonce = options.longs === String ? String(message.invalidation_nonce) : message.invalidation_nonce;
                    else
                        object.invalidation_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.invalidation_nonce) : options.longs === Number ? new $util.LongBits(message.invalidation_nonce.low >>> 0, message.invalidation_nonce.high >>> 0).toNumber(true) : message.invalidation_nonce;
                if (message.block != null && message.hasOwnProperty("block"))
                    if (typeof message.block === "number")
                        object.block = options.longs === String ? String(message.block) : message.block;
                    else
                        object.block = options.longs === String ? $util.Long.prototype.toString.call(message.block) : options.longs === Number ? new $util.LongBits(message.block.low >>> 0, message.block.high >>> 0).toNumber(true) : message.block;
                return object;
            };

            /**
             * Converts this OutgoingLogicCall to JSON.
             * @function toJSON
             * @memberof gravity.v1.OutgoingLogicCall
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OutgoingLogicCall.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OutgoingLogicCall;
        })();

        v1.BridgeValidator = (function() {

            /**
             * Properties of a BridgeValidator.
             * @memberof gravity.v1
             * @interface IBridgeValidator
             * @property {Long|null} [power] BridgeValidator power
             * @property {string|null} [ethereum_address] BridgeValidator ethereum_address
             */

            /**
             * Constructs a new BridgeValidator.
             * @memberof gravity.v1
             * @classdesc Represents a BridgeValidator.
             * @implements IBridgeValidator
             * @constructor
             * @param {gravity.v1.IBridgeValidator=} [properties] Properties to set
             */
            function BridgeValidator(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BridgeValidator power.
             * @member {Long} power
             * @memberof gravity.v1.BridgeValidator
             * @instance
             */
            BridgeValidator.prototype.power = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * BridgeValidator ethereum_address.
             * @member {string} ethereum_address
             * @memberof gravity.v1.BridgeValidator
             * @instance
             */
            BridgeValidator.prototype.ethereum_address = "";

            /**
             * Encodes the specified BridgeValidator message. Does not implicitly {@link gravity.v1.BridgeValidator.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.BridgeValidator
             * @static
             * @param {gravity.v1.IBridgeValidator} message BridgeValidator message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BridgeValidator.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.power);
                if (message.ethereum_address != null && Object.hasOwnProperty.call(message, "ethereum_address"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.ethereum_address);
                return writer;
            };

            /**
             * Encodes the specified BridgeValidator message, length delimited. Does not implicitly {@link gravity.v1.BridgeValidator.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.BridgeValidator
             * @static
             * @param {gravity.v1.IBridgeValidator} message BridgeValidator message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BridgeValidator.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BridgeValidator message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.BridgeValidator
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.BridgeValidator} BridgeValidator
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BridgeValidator.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.BridgeValidator();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.power = reader.uint64();
                        break;
                    case 2:
                        message.ethereum_address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BridgeValidator message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.BridgeValidator
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.BridgeValidator} BridgeValidator
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BridgeValidator.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BridgeValidator message.
             * @function verify
             * @memberof gravity.v1.BridgeValidator
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BridgeValidator.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.power != null && message.hasOwnProperty("power"))
                    if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                        return "power: integer|Long expected";
                if (message.ethereum_address != null && message.hasOwnProperty("ethereum_address"))
                    if (!$util.isString(message.ethereum_address))
                        return "ethereum_address: string expected";
                return null;
            };

            /**
             * Creates a BridgeValidator message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.BridgeValidator
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.BridgeValidator} BridgeValidator
             */
            BridgeValidator.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.BridgeValidator)
                    return object;
                let message = new $root.gravity.v1.BridgeValidator();
                if (object.power != null)
                    if ($util.Long)
                        (message.power = $util.Long.fromValue(object.power)).unsigned = true;
                    else if (typeof object.power === "string")
                        message.power = parseInt(object.power, 10);
                    else if (typeof object.power === "number")
                        message.power = object.power;
                    else if (typeof object.power === "object")
                        message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber(true);
                if (object.ethereum_address != null)
                    message.ethereum_address = String(object.ethereum_address);
                return message;
            };

            /**
             * Creates a plain object from a BridgeValidator message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.BridgeValidator
             * @static
             * @param {gravity.v1.BridgeValidator} message BridgeValidator
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BridgeValidator.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.power = options.longs === String ? "0" : 0;
                    object.ethereum_address = "";
                }
                if (message.power != null && message.hasOwnProperty("power"))
                    if (typeof message.power === "number")
                        object.power = options.longs === String ? String(message.power) : message.power;
                    else
                        object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber(true) : message.power;
                if (message.ethereum_address != null && message.hasOwnProperty("ethereum_address"))
                    object.ethereum_address = message.ethereum_address;
                return object;
            };

            /**
             * Converts this BridgeValidator to JSON.
             * @function toJSON
             * @memberof gravity.v1.BridgeValidator
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BridgeValidator.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BridgeValidator;
        })();

        v1.Valset = (function() {

            /**
             * Properties of a Valset.
             * @memberof gravity.v1
             * @interface IValset
             * @property {Long|null} [nonce] Valset nonce
             * @property {Array.<gravity.v1.IBridgeValidator>|null} [members] Valset members
             * @property {Long|null} [height] Valset height
             * @property {string|null} [reward_amount] Valset reward_amount
             * @property {string|null} [reward_token] Valset reward_token
             */

            /**
             * Constructs a new Valset.
             * @memberof gravity.v1
             * @classdesc Represents a Valset.
             * @implements IValset
             * @constructor
             * @param {gravity.v1.IValset=} [properties] Properties to set
             */
            function Valset(properties) {
                this.members = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Valset nonce.
             * @member {Long} nonce
             * @memberof gravity.v1.Valset
             * @instance
             */
            Valset.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Valset members.
             * @member {Array.<gravity.v1.IBridgeValidator>} members
             * @memberof gravity.v1.Valset
             * @instance
             */
            Valset.prototype.members = $util.emptyArray;

            /**
             * Valset height.
             * @member {Long} height
             * @memberof gravity.v1.Valset
             * @instance
             */
            Valset.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Valset reward_amount.
             * @member {string} reward_amount
             * @memberof gravity.v1.Valset
             * @instance
             */
            Valset.prototype.reward_amount = "";

            /**
             * Valset reward_token.
             * @member {string} reward_token
             * @memberof gravity.v1.Valset
             * @instance
             */
            Valset.prototype.reward_token = "";

            /**
             * Encodes the specified Valset message. Does not implicitly {@link gravity.v1.Valset.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.Valset
             * @static
             * @param {gravity.v1.IValset} message Valset message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Valset.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.members != null && message.members.length)
                    for (let i = 0; i < message.members.length; ++i)
                        $root.gravity.v1.BridgeValidator.encode(message.members[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.height);
                if (message.reward_amount != null && Object.hasOwnProperty.call(message, "reward_amount"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.reward_amount);
                if (message.reward_token != null && Object.hasOwnProperty.call(message, "reward_token"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.reward_token);
                return writer;
            };

            /**
             * Encodes the specified Valset message, length delimited. Does not implicitly {@link gravity.v1.Valset.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.Valset
             * @static
             * @param {gravity.v1.IValset} message Valset message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Valset.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Valset message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.Valset
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.Valset} Valset
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Valset.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.Valset();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        if (!(message.members && message.members.length))
                            message.members = [];
                        message.members.push($root.gravity.v1.BridgeValidator.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.height = reader.uint64();
                        break;
                    case 4:
                        message.reward_amount = reader.string();
                        break;
                    case 5:
                        message.reward_token = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Valset message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.Valset
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.Valset} Valset
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Valset.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Valset message.
             * @function verify
             * @memberof gravity.v1.Valset
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Valset.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.members != null && message.hasOwnProperty("members")) {
                    if (!Array.isArray(message.members))
                        return "members: array expected";
                    for (let i = 0; i < message.members.length; ++i) {
                        let error = $root.gravity.v1.BridgeValidator.verify(message.members[i]);
                        if (error)
                            return "members." + error;
                    }
                }
                if (message.height != null && message.hasOwnProperty("height"))
                    if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                        return "height: integer|Long expected";
                if (message.reward_amount != null && message.hasOwnProperty("reward_amount"))
                    if (!$util.isString(message.reward_amount))
                        return "reward_amount: string expected";
                if (message.reward_token != null && message.hasOwnProperty("reward_token"))
                    if (!$util.isString(message.reward_token))
                        return "reward_token: string expected";
                return null;
            };

            /**
             * Creates a Valset message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.Valset
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.Valset} Valset
             */
            Valset.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.Valset)
                    return object;
                let message = new $root.gravity.v1.Valset();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.members) {
                    if (!Array.isArray(object.members))
                        throw TypeError(".gravity.v1.Valset.members: array expected");
                    message.members = [];
                    for (let i = 0; i < object.members.length; ++i) {
                        if (typeof object.members[i] !== "object")
                            throw TypeError(".gravity.v1.Valset.members: object expected");
                        message.members[i] = $root.gravity.v1.BridgeValidator.fromObject(object.members[i]);
                    }
                }
                if (object.height != null)
                    if ($util.Long)
                        (message.height = $util.Long.fromValue(object.height)).unsigned = true;
                    else if (typeof object.height === "string")
                        message.height = parseInt(object.height, 10);
                    else if (typeof object.height === "number")
                        message.height = object.height;
                    else if (typeof object.height === "object")
                        message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
                if (object.reward_amount != null)
                    message.reward_amount = String(object.reward_amount);
                if (object.reward_token != null)
                    message.reward_token = String(object.reward_token);
                return message;
            };

            /**
             * Creates a plain object from a Valset message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.Valset
             * @static
             * @param {gravity.v1.Valset} message Valset
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Valset.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.members = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.height = options.longs === String ? "0" : 0;
                    object.reward_amount = "";
                    object.reward_token = "";
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.members && message.members.length) {
                    object.members = [];
                    for (let j = 0; j < message.members.length; ++j)
                        object.members[j] = $root.gravity.v1.BridgeValidator.toObject(message.members[j], options);
                }
                if (message.height != null && message.hasOwnProperty("height"))
                    if (typeof message.height === "number")
                        object.height = options.longs === String ? String(message.height) : message.height;
                    else
                        object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
                if (message.reward_amount != null && message.hasOwnProperty("reward_amount"))
                    object.reward_amount = message.reward_amount;
                if (message.reward_token != null && message.hasOwnProperty("reward_token"))
                    object.reward_token = message.reward_token;
                return object;
            };

            /**
             * Converts this Valset to JSON.
             * @function toJSON
             * @memberof gravity.v1.Valset
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Valset.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Valset;
        })();

        v1.LastObservedEthereumBlockHeight = (function() {

            /**
             * Properties of a LastObservedEthereumBlockHeight.
             * @memberof gravity.v1
             * @interface ILastObservedEthereumBlockHeight
             * @property {Long|null} [cosmos_block_height] LastObservedEthereumBlockHeight cosmos_block_height
             * @property {Long|null} [ethereum_block_height] LastObservedEthereumBlockHeight ethereum_block_height
             */

            /**
             * Constructs a new LastObservedEthereumBlockHeight.
             * @memberof gravity.v1
             * @classdesc Represents a LastObservedEthereumBlockHeight.
             * @implements ILastObservedEthereumBlockHeight
             * @constructor
             * @param {gravity.v1.ILastObservedEthereumBlockHeight=} [properties] Properties to set
             */
            function LastObservedEthereumBlockHeight(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LastObservedEthereumBlockHeight cosmos_block_height.
             * @member {Long} cosmos_block_height
             * @memberof gravity.v1.LastObservedEthereumBlockHeight
             * @instance
             */
            LastObservedEthereumBlockHeight.prototype.cosmos_block_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * LastObservedEthereumBlockHeight ethereum_block_height.
             * @member {Long} ethereum_block_height
             * @memberof gravity.v1.LastObservedEthereumBlockHeight
             * @instance
             */
            LastObservedEthereumBlockHeight.prototype.ethereum_block_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified LastObservedEthereumBlockHeight message. Does not implicitly {@link gravity.v1.LastObservedEthereumBlockHeight.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.LastObservedEthereumBlockHeight
             * @static
             * @param {gravity.v1.ILastObservedEthereumBlockHeight} message LastObservedEthereumBlockHeight message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LastObservedEthereumBlockHeight.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cosmos_block_height != null && Object.hasOwnProperty.call(message, "cosmos_block_height"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.cosmos_block_height);
                if (message.ethereum_block_height != null && Object.hasOwnProperty.call(message, "ethereum_block_height"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.ethereum_block_height);
                return writer;
            };

            /**
             * Encodes the specified LastObservedEthereumBlockHeight message, length delimited. Does not implicitly {@link gravity.v1.LastObservedEthereumBlockHeight.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.LastObservedEthereumBlockHeight
             * @static
             * @param {gravity.v1.ILastObservedEthereumBlockHeight} message LastObservedEthereumBlockHeight message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LastObservedEthereumBlockHeight.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LastObservedEthereumBlockHeight message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.LastObservedEthereumBlockHeight
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.LastObservedEthereumBlockHeight} LastObservedEthereumBlockHeight
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LastObservedEthereumBlockHeight.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.LastObservedEthereumBlockHeight();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.cosmos_block_height = reader.uint64();
                        break;
                    case 2:
                        message.ethereum_block_height = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LastObservedEthereumBlockHeight message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.LastObservedEthereumBlockHeight
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.LastObservedEthereumBlockHeight} LastObservedEthereumBlockHeight
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LastObservedEthereumBlockHeight.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LastObservedEthereumBlockHeight message.
             * @function verify
             * @memberof gravity.v1.LastObservedEthereumBlockHeight
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LastObservedEthereumBlockHeight.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cosmos_block_height != null && message.hasOwnProperty("cosmos_block_height"))
                    if (!$util.isInteger(message.cosmos_block_height) && !(message.cosmos_block_height && $util.isInteger(message.cosmos_block_height.low) && $util.isInteger(message.cosmos_block_height.high)))
                        return "cosmos_block_height: integer|Long expected";
                if (message.ethereum_block_height != null && message.hasOwnProperty("ethereum_block_height"))
                    if (!$util.isInteger(message.ethereum_block_height) && !(message.ethereum_block_height && $util.isInteger(message.ethereum_block_height.low) && $util.isInteger(message.ethereum_block_height.high)))
                        return "ethereum_block_height: integer|Long expected";
                return null;
            };

            /**
             * Creates a LastObservedEthereumBlockHeight message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.LastObservedEthereumBlockHeight
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.LastObservedEthereumBlockHeight} LastObservedEthereumBlockHeight
             */
            LastObservedEthereumBlockHeight.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.LastObservedEthereumBlockHeight)
                    return object;
                let message = new $root.gravity.v1.LastObservedEthereumBlockHeight();
                if (object.cosmos_block_height != null)
                    if ($util.Long)
                        (message.cosmos_block_height = $util.Long.fromValue(object.cosmos_block_height)).unsigned = true;
                    else if (typeof object.cosmos_block_height === "string")
                        message.cosmos_block_height = parseInt(object.cosmos_block_height, 10);
                    else if (typeof object.cosmos_block_height === "number")
                        message.cosmos_block_height = object.cosmos_block_height;
                    else if (typeof object.cosmos_block_height === "object")
                        message.cosmos_block_height = new $util.LongBits(object.cosmos_block_height.low >>> 0, object.cosmos_block_height.high >>> 0).toNumber(true);
                if (object.ethereum_block_height != null)
                    if ($util.Long)
                        (message.ethereum_block_height = $util.Long.fromValue(object.ethereum_block_height)).unsigned = true;
                    else if (typeof object.ethereum_block_height === "string")
                        message.ethereum_block_height = parseInt(object.ethereum_block_height, 10);
                    else if (typeof object.ethereum_block_height === "number")
                        message.ethereum_block_height = object.ethereum_block_height;
                    else if (typeof object.ethereum_block_height === "object")
                        message.ethereum_block_height = new $util.LongBits(object.ethereum_block_height.low >>> 0, object.ethereum_block_height.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a LastObservedEthereumBlockHeight message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.LastObservedEthereumBlockHeight
             * @static
             * @param {gravity.v1.LastObservedEthereumBlockHeight} message LastObservedEthereumBlockHeight
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LastObservedEthereumBlockHeight.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.cosmos_block_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.cosmos_block_height = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.ethereum_block_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ethereum_block_height = options.longs === String ? "0" : 0;
                }
                if (message.cosmos_block_height != null && message.hasOwnProperty("cosmos_block_height"))
                    if (typeof message.cosmos_block_height === "number")
                        object.cosmos_block_height = options.longs === String ? String(message.cosmos_block_height) : message.cosmos_block_height;
                    else
                        object.cosmos_block_height = options.longs === String ? $util.Long.prototype.toString.call(message.cosmos_block_height) : options.longs === Number ? new $util.LongBits(message.cosmos_block_height.low >>> 0, message.cosmos_block_height.high >>> 0).toNumber(true) : message.cosmos_block_height;
                if (message.ethereum_block_height != null && message.hasOwnProperty("ethereum_block_height"))
                    if (typeof message.ethereum_block_height === "number")
                        object.ethereum_block_height = options.longs === String ? String(message.ethereum_block_height) : message.ethereum_block_height;
                    else
                        object.ethereum_block_height = options.longs === String ? $util.Long.prototype.toString.call(message.ethereum_block_height) : options.longs === Number ? new $util.LongBits(message.ethereum_block_height.low >>> 0, message.ethereum_block_height.high >>> 0).toNumber(true) : message.ethereum_block_height;
                return object;
            };

            /**
             * Converts this LastObservedEthereumBlockHeight to JSON.
             * @function toJSON
             * @memberof gravity.v1.LastObservedEthereumBlockHeight
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LastObservedEthereumBlockHeight.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LastObservedEthereumBlockHeight;
        })();

        v1.ERC20ToDenom = (function() {

            /**
             * Properties of a ERC20ToDenom.
             * @memberof gravity.v1
             * @interface IERC20ToDenom
             * @property {string|null} [erc20] ERC20ToDenom erc20
             * @property {string|null} [denom] ERC20ToDenom denom
             */

            /**
             * Constructs a new ERC20ToDenom.
             * @memberof gravity.v1
             * @classdesc Represents a ERC20ToDenom.
             * @implements IERC20ToDenom
             * @constructor
             * @param {gravity.v1.IERC20ToDenom=} [properties] Properties to set
             */
            function ERC20ToDenom(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ERC20ToDenom erc20.
             * @member {string} erc20
             * @memberof gravity.v1.ERC20ToDenom
             * @instance
             */
            ERC20ToDenom.prototype.erc20 = "";

            /**
             * ERC20ToDenom denom.
             * @member {string} denom
             * @memberof gravity.v1.ERC20ToDenom
             * @instance
             */
            ERC20ToDenom.prototype.denom = "";

            /**
             * Encodes the specified ERC20ToDenom message. Does not implicitly {@link gravity.v1.ERC20ToDenom.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.ERC20ToDenom
             * @static
             * @param {gravity.v1.IERC20ToDenom} message ERC20ToDenom message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ERC20ToDenom.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.erc20 != null && Object.hasOwnProperty.call(message, "erc20"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.erc20);
                if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.denom);
                return writer;
            };

            /**
             * Encodes the specified ERC20ToDenom message, length delimited. Does not implicitly {@link gravity.v1.ERC20ToDenom.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.ERC20ToDenom
             * @static
             * @param {gravity.v1.IERC20ToDenom} message ERC20ToDenom message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ERC20ToDenom.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ERC20ToDenom message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.ERC20ToDenom
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.ERC20ToDenom} ERC20ToDenom
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ERC20ToDenom.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.ERC20ToDenom();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.erc20 = reader.string();
                        break;
                    case 2:
                        message.denom = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ERC20ToDenom message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.ERC20ToDenom
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.ERC20ToDenom} ERC20ToDenom
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ERC20ToDenom.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ERC20ToDenom message.
             * @function verify
             * @memberof gravity.v1.ERC20ToDenom
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ERC20ToDenom.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.erc20 != null && message.hasOwnProperty("erc20"))
                    if (!$util.isString(message.erc20))
                        return "erc20: string expected";
                if (message.denom != null && message.hasOwnProperty("denom"))
                    if (!$util.isString(message.denom))
                        return "denom: string expected";
                return null;
            };

            /**
             * Creates a ERC20ToDenom message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.ERC20ToDenom
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.ERC20ToDenom} ERC20ToDenom
             */
            ERC20ToDenom.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.ERC20ToDenom)
                    return object;
                let message = new $root.gravity.v1.ERC20ToDenom();
                if (object.erc20 != null)
                    message.erc20 = String(object.erc20);
                if (object.denom != null)
                    message.denom = String(object.denom);
                return message;
            };

            /**
             * Creates a plain object from a ERC20ToDenom message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.ERC20ToDenom
             * @static
             * @param {gravity.v1.ERC20ToDenom} message ERC20ToDenom
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ERC20ToDenom.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.erc20 = "";
                    object.denom = "";
                }
                if (message.erc20 != null && message.hasOwnProperty("erc20"))
                    object.erc20 = message.erc20;
                if (message.denom != null && message.hasOwnProperty("denom"))
                    object.denom = message.denom;
                return object;
            };

            /**
             * Converts this ERC20ToDenom to JSON.
             * @function toJSON
             * @memberof gravity.v1.ERC20ToDenom
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ERC20ToDenom.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ERC20ToDenom;
        })();

        v1.UnhaltBridgeProposal = (function() {

            /**
             * Properties of an UnhaltBridgeProposal.
             * @memberof gravity.v1
             * @interface IUnhaltBridgeProposal
             * @property {string|null} [title] UnhaltBridgeProposal title
             * @property {string|null} [description] UnhaltBridgeProposal description
             * @property {Long|null} [target_nonce] UnhaltBridgeProposal target_nonce
             */

            /**
             * Constructs a new UnhaltBridgeProposal.
             * @memberof gravity.v1
             * @classdesc Represents an UnhaltBridgeProposal.
             * @implements IUnhaltBridgeProposal
             * @constructor
             * @param {gravity.v1.IUnhaltBridgeProposal=} [properties] Properties to set
             */
            function UnhaltBridgeProposal(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UnhaltBridgeProposal title.
             * @member {string} title
             * @memberof gravity.v1.UnhaltBridgeProposal
             * @instance
             */
            UnhaltBridgeProposal.prototype.title = "";

            /**
             * UnhaltBridgeProposal description.
             * @member {string} description
             * @memberof gravity.v1.UnhaltBridgeProposal
             * @instance
             */
            UnhaltBridgeProposal.prototype.description = "";

            /**
             * UnhaltBridgeProposal target_nonce.
             * @member {Long} target_nonce
             * @memberof gravity.v1.UnhaltBridgeProposal
             * @instance
             */
            UnhaltBridgeProposal.prototype.target_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified UnhaltBridgeProposal message. Does not implicitly {@link gravity.v1.UnhaltBridgeProposal.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.UnhaltBridgeProposal
             * @static
             * @param {gravity.v1.IUnhaltBridgeProposal} message UnhaltBridgeProposal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnhaltBridgeProposal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                if (message.target_nonce != null && Object.hasOwnProperty.call(message, "target_nonce"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.target_nonce);
                return writer;
            };

            /**
             * Encodes the specified UnhaltBridgeProposal message, length delimited. Does not implicitly {@link gravity.v1.UnhaltBridgeProposal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.UnhaltBridgeProposal
             * @static
             * @param {gravity.v1.IUnhaltBridgeProposal} message UnhaltBridgeProposal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnhaltBridgeProposal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UnhaltBridgeProposal message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.UnhaltBridgeProposal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.UnhaltBridgeProposal} UnhaltBridgeProposal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnhaltBridgeProposal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.UnhaltBridgeProposal();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.title = reader.string();
                        break;
                    case 2:
                        message.description = reader.string();
                        break;
                    case 4:
                        message.target_nonce = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UnhaltBridgeProposal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.UnhaltBridgeProposal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.UnhaltBridgeProposal} UnhaltBridgeProposal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnhaltBridgeProposal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UnhaltBridgeProposal message.
             * @function verify
             * @memberof gravity.v1.UnhaltBridgeProposal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnhaltBridgeProposal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.target_nonce != null && message.hasOwnProperty("target_nonce"))
                    if (!$util.isInteger(message.target_nonce) && !(message.target_nonce && $util.isInteger(message.target_nonce.low) && $util.isInteger(message.target_nonce.high)))
                        return "target_nonce: integer|Long expected";
                return null;
            };

            /**
             * Creates an UnhaltBridgeProposal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.UnhaltBridgeProposal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.UnhaltBridgeProposal} UnhaltBridgeProposal
             */
            UnhaltBridgeProposal.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.UnhaltBridgeProposal)
                    return object;
                let message = new $root.gravity.v1.UnhaltBridgeProposal();
                if (object.title != null)
                    message.title = String(object.title);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.target_nonce != null)
                    if ($util.Long)
                        (message.target_nonce = $util.Long.fromValue(object.target_nonce)).unsigned = true;
                    else if (typeof object.target_nonce === "string")
                        message.target_nonce = parseInt(object.target_nonce, 10);
                    else if (typeof object.target_nonce === "number")
                        message.target_nonce = object.target_nonce;
                    else if (typeof object.target_nonce === "object")
                        message.target_nonce = new $util.LongBits(object.target_nonce.low >>> 0, object.target_nonce.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an UnhaltBridgeProposal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.UnhaltBridgeProposal
             * @static
             * @param {gravity.v1.UnhaltBridgeProposal} message UnhaltBridgeProposal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnhaltBridgeProposal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.title = "";
                    object.description = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.target_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.target_nonce = options.longs === String ? "0" : 0;
                }
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.target_nonce != null && message.hasOwnProperty("target_nonce"))
                    if (typeof message.target_nonce === "number")
                        object.target_nonce = options.longs === String ? String(message.target_nonce) : message.target_nonce;
                    else
                        object.target_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.target_nonce) : options.longs === Number ? new $util.LongBits(message.target_nonce.low >>> 0, message.target_nonce.high >>> 0).toNumber(true) : message.target_nonce;
                return object;
            };

            /**
             * Converts this UnhaltBridgeProposal to JSON.
             * @function toJSON
             * @memberof gravity.v1.UnhaltBridgeProposal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnhaltBridgeProposal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnhaltBridgeProposal;
        })();

        v1.AirdropProposal = (function() {

            /**
             * Properties of an AirdropProposal.
             * @memberof gravity.v1
             * @interface IAirdropProposal
             * @property {string|null} [title] AirdropProposal title
             * @property {string|null} [description] AirdropProposal description
             * @property {Array.<string>|null} [recipients] AirdropProposal recipients
             * @property {cosmos.base.v1beta1.ICoin|null} [amount] AirdropProposal amount
             */

            /**
             * Constructs a new AirdropProposal.
             * @memberof gravity.v1
             * @classdesc Represents an AirdropProposal.
             * @implements IAirdropProposal
             * @constructor
             * @param {gravity.v1.IAirdropProposal=} [properties] Properties to set
             */
            function AirdropProposal(properties) {
                this.recipients = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AirdropProposal title.
             * @member {string} title
             * @memberof gravity.v1.AirdropProposal
             * @instance
             */
            AirdropProposal.prototype.title = "";

            /**
             * AirdropProposal description.
             * @member {string} description
             * @memberof gravity.v1.AirdropProposal
             * @instance
             */
            AirdropProposal.prototype.description = "";

            /**
             * AirdropProposal recipients.
             * @member {Array.<string>} recipients
             * @memberof gravity.v1.AirdropProposal
             * @instance
             */
            AirdropProposal.prototype.recipients = $util.emptyArray;

            /**
             * AirdropProposal amount.
             * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
             * @memberof gravity.v1.AirdropProposal
             * @instance
             */
            AirdropProposal.prototype.amount = null;

            /**
             * Encodes the specified AirdropProposal message. Does not implicitly {@link gravity.v1.AirdropProposal.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.AirdropProposal
             * @static
             * @param {gravity.v1.IAirdropProposal} message AirdropProposal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AirdropProposal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                if (message.recipients != null && message.recipients.length)
                    for (let i = 0; i < message.recipients.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.recipients[i]);
                if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                    $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AirdropProposal message, length delimited. Does not implicitly {@link gravity.v1.AirdropProposal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.AirdropProposal
             * @static
             * @param {gravity.v1.IAirdropProposal} message AirdropProposal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AirdropProposal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AirdropProposal message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.AirdropProposal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.AirdropProposal} AirdropProposal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AirdropProposal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.AirdropProposal();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.title = reader.string();
                        break;
                    case 2:
                        message.description = reader.string();
                        break;
                    case 3:
                        if (!(message.recipients && message.recipients.length))
                            message.recipients = [];
                        message.recipients.push(reader.string());
                        break;
                    case 4:
                        message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AirdropProposal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.AirdropProposal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.AirdropProposal} AirdropProposal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AirdropProposal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AirdropProposal message.
             * @function verify
             * @memberof gravity.v1.AirdropProposal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AirdropProposal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.recipients != null && message.hasOwnProperty("recipients")) {
                    if (!Array.isArray(message.recipients))
                        return "recipients: array expected";
                    for (let i = 0; i < message.recipients.length; ++i)
                        if (!$util.isString(message.recipients[i]))
                            return "recipients: string[] expected";
                }
                if (message.amount != null && message.hasOwnProperty("amount")) {
                    let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
                    if (error)
                        return "amount." + error;
                }
                return null;
            };

            /**
             * Creates an AirdropProposal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.AirdropProposal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.AirdropProposal} AirdropProposal
             */
            AirdropProposal.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.AirdropProposal)
                    return object;
                let message = new $root.gravity.v1.AirdropProposal();
                if (object.title != null)
                    message.title = String(object.title);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.recipients) {
                    if (!Array.isArray(object.recipients))
                        throw TypeError(".gravity.v1.AirdropProposal.recipients: array expected");
                    message.recipients = [];
                    for (let i = 0; i < object.recipients.length; ++i)
                        message.recipients[i] = String(object.recipients[i]);
                }
                if (object.amount != null) {
                    if (typeof object.amount !== "object")
                        throw TypeError(".gravity.v1.AirdropProposal.amount: object expected");
                    message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
                }
                return message;
            };

            /**
             * Creates a plain object from an AirdropProposal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.AirdropProposal
             * @static
             * @param {gravity.v1.AirdropProposal} message AirdropProposal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AirdropProposal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.recipients = [];
                if (options.defaults) {
                    object.title = "";
                    object.description = "";
                    object.amount = null;
                }
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.recipients && message.recipients.length) {
                    object.recipients = [];
                    for (let j = 0; j < message.recipients.length; ++j)
                        object.recipients[j] = message.recipients[j];
                }
                if (message.amount != null && message.hasOwnProperty("amount"))
                    object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
                return object;
            };

            /**
             * Converts this AirdropProposal to JSON.
             * @function toJSON
             * @memberof gravity.v1.AirdropProposal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AirdropProposal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AirdropProposal;
        })();

        v1.IBCMetadataProposal = (function() {

            /**
             * Properties of a IBCMetadataProposal.
             * @memberof gravity.v1
             * @interface IIBCMetadataProposal
             * @property {string|null} [title] IBCMetadataProposal title
             * @property {string|null} [description] IBCMetadataProposal description
             * @property {cosmos.bank.v1beta1.IMetadata|null} [metadata] IBCMetadataProposal metadata
             * @property {string|null} [ibc_denom] IBCMetadataProposal ibc_denom
             */

            /**
             * Constructs a new IBCMetadataProposal.
             * @memberof gravity.v1
             * @classdesc Represents a IBCMetadataProposal.
             * @implements IIBCMetadataProposal
             * @constructor
             * @param {gravity.v1.IIBCMetadataProposal=} [properties] Properties to set
             */
            function IBCMetadataProposal(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IBCMetadataProposal title.
             * @member {string} title
             * @memberof gravity.v1.IBCMetadataProposal
             * @instance
             */
            IBCMetadataProposal.prototype.title = "";

            /**
             * IBCMetadataProposal description.
             * @member {string} description
             * @memberof gravity.v1.IBCMetadataProposal
             * @instance
             */
            IBCMetadataProposal.prototype.description = "";

            /**
             * IBCMetadataProposal metadata.
             * @member {cosmos.bank.v1beta1.IMetadata|null|undefined} metadata
             * @memberof gravity.v1.IBCMetadataProposal
             * @instance
             */
            IBCMetadataProposal.prototype.metadata = null;

            /**
             * IBCMetadataProposal ibc_denom.
             * @member {string} ibc_denom
             * @memberof gravity.v1.IBCMetadataProposal
             * @instance
             */
            IBCMetadataProposal.prototype.ibc_denom = "";

            /**
             * Encodes the specified IBCMetadataProposal message. Does not implicitly {@link gravity.v1.IBCMetadataProposal.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.IBCMetadataProposal
             * @static
             * @param {gravity.v1.IIBCMetadataProposal} message IBCMetadataProposal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IBCMetadataProposal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    $root.cosmos.bank.v1beta1.Metadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.ibc_denom != null && Object.hasOwnProperty.call(message, "ibc_denom"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.ibc_denom);
                return writer;
            };

            /**
             * Encodes the specified IBCMetadataProposal message, length delimited. Does not implicitly {@link gravity.v1.IBCMetadataProposal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.IBCMetadataProposal
             * @static
             * @param {gravity.v1.IIBCMetadataProposal} message IBCMetadataProposal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IBCMetadataProposal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a IBCMetadataProposal message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.IBCMetadataProposal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.IBCMetadataProposal} IBCMetadataProposal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IBCMetadataProposal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.IBCMetadataProposal();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.title = reader.string();
                        break;
                    case 2:
                        message.description = reader.string();
                        break;
                    case 3:
                        message.metadata = $root.cosmos.bank.v1beta1.Metadata.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.ibc_denom = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a IBCMetadataProposal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.IBCMetadataProposal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.IBCMetadataProposal} IBCMetadataProposal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IBCMetadataProposal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a IBCMetadataProposal message.
             * @function verify
             * @memberof gravity.v1.IBCMetadataProposal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IBCMetadataProposal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.cosmos.bank.v1beta1.Metadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                if (message.ibc_denom != null && message.hasOwnProperty("ibc_denom"))
                    if (!$util.isString(message.ibc_denom))
                        return "ibc_denom: string expected";
                return null;
            };

            /**
             * Creates a IBCMetadataProposal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.IBCMetadataProposal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.IBCMetadataProposal} IBCMetadataProposal
             */
            IBCMetadataProposal.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.IBCMetadataProposal)
                    return object;
                let message = new $root.gravity.v1.IBCMetadataProposal();
                if (object.title != null)
                    message.title = String(object.title);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".gravity.v1.IBCMetadataProposal.metadata: object expected");
                    message.metadata = $root.cosmos.bank.v1beta1.Metadata.fromObject(object.metadata);
                }
                if (object.ibc_denom != null)
                    message.ibc_denom = String(object.ibc_denom);
                return message;
            };

            /**
             * Creates a plain object from a IBCMetadataProposal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.IBCMetadataProposal
             * @static
             * @param {gravity.v1.IBCMetadataProposal} message IBCMetadataProposal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IBCMetadataProposal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.title = "";
                    object.description = "";
                    object.metadata = null;
                    object.ibc_denom = "";
                }
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.cosmos.bank.v1beta1.Metadata.toObject(message.metadata, options);
                if (message.ibc_denom != null && message.hasOwnProperty("ibc_denom"))
                    object.ibc_denom = message.ibc_denom;
                return object;
            };

            /**
             * Converts this IBCMetadataProposal to JSON.
             * @function toJSON
             * @memberof gravity.v1.IBCMetadataProposal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IBCMetadataProposal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IBCMetadataProposal;
        })();

        v1.Query = (function() {

            /**
             * Constructs a new Query service.
             * @memberof gravity.v1
             * @classdesc Represents a Query
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Query(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

            /**
             * Callback as used by {@link gravity.v1.Query#params}.
             * @memberof gravity.v1.Query
             * @typedef ParamsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryParamsResponse} [response] QueryParamsResponse
             */

            /**
             * Calls Params.
             * @function params
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryParamsRequest} request QueryParamsRequest message or plain object
             * @param {gravity.v1.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.params = function params(request, callback) {
                return this.rpcCall(params, $root.gravity.v1.QueryParamsRequest, $root.gravity.v1.QueryParamsResponse, request, callback);
            }, "name", { value: "Params" });

            /**
             * Calls Params.
             * @function params
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryParamsRequest} request QueryParamsRequest message or plain object
             * @returns {Promise<gravity.v1.QueryParamsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#currentValset}.
             * @memberof gravity.v1.Query
             * @typedef CurrentValsetCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryCurrentValsetResponse} [response] QueryCurrentValsetResponse
             */

            /**
             * Calls CurrentValset.
             * @function currentValset
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryCurrentValsetRequest} request QueryCurrentValsetRequest message or plain object
             * @param {gravity.v1.Query.CurrentValsetCallback} callback Node-style callback called with the error, if any, and QueryCurrentValsetResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.currentValset = function currentValset(request, callback) {
                return this.rpcCall(currentValset, $root.gravity.v1.QueryCurrentValsetRequest, $root.gravity.v1.QueryCurrentValsetResponse, request, callback);
            }, "name", { value: "CurrentValset" });

            /**
             * Calls CurrentValset.
             * @function currentValset
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryCurrentValsetRequest} request QueryCurrentValsetRequest message or plain object
             * @returns {Promise<gravity.v1.QueryCurrentValsetResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#valsetRequest}.
             * @memberof gravity.v1.Query
             * @typedef ValsetRequestCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryValsetRequestResponse} [response] QueryValsetRequestResponse
             */

            /**
             * Calls ValsetRequest.
             * @function valsetRequest
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryValsetRequestRequest} request QueryValsetRequestRequest message or plain object
             * @param {gravity.v1.Query.ValsetRequestCallback} callback Node-style callback called with the error, if any, and QueryValsetRequestResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.valsetRequest = function valsetRequest(request, callback) {
                return this.rpcCall(valsetRequest, $root.gravity.v1.QueryValsetRequestRequest, $root.gravity.v1.QueryValsetRequestResponse, request, callback);
            }, "name", { value: "ValsetRequest" });

            /**
             * Calls ValsetRequest.
             * @function valsetRequest
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryValsetRequestRequest} request QueryValsetRequestRequest message or plain object
             * @returns {Promise<gravity.v1.QueryValsetRequestResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#valsetConfirm}.
             * @memberof gravity.v1.Query
             * @typedef ValsetConfirmCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryValsetConfirmResponse} [response] QueryValsetConfirmResponse
             */

            /**
             * Calls ValsetConfirm.
             * @function valsetConfirm
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryValsetConfirmRequest} request QueryValsetConfirmRequest message or plain object
             * @param {gravity.v1.Query.ValsetConfirmCallback} callback Node-style callback called with the error, if any, and QueryValsetConfirmResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.valsetConfirm = function valsetConfirm(request, callback) {
                return this.rpcCall(valsetConfirm, $root.gravity.v1.QueryValsetConfirmRequest, $root.gravity.v1.QueryValsetConfirmResponse, request, callback);
            }, "name", { value: "ValsetConfirm" });

            /**
             * Calls ValsetConfirm.
             * @function valsetConfirm
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryValsetConfirmRequest} request QueryValsetConfirmRequest message or plain object
             * @returns {Promise<gravity.v1.QueryValsetConfirmResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#valsetConfirmsByNonce}.
             * @memberof gravity.v1.Query
             * @typedef ValsetConfirmsByNonceCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryValsetConfirmsByNonceResponse} [response] QueryValsetConfirmsByNonceResponse
             */

            /**
             * Calls ValsetConfirmsByNonce.
             * @function valsetConfirmsByNonce
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryValsetConfirmsByNonceRequest} request QueryValsetConfirmsByNonceRequest message or plain object
             * @param {gravity.v1.Query.ValsetConfirmsByNonceCallback} callback Node-style callback called with the error, if any, and QueryValsetConfirmsByNonceResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.valsetConfirmsByNonce = function valsetConfirmsByNonce(request, callback) {
                return this.rpcCall(valsetConfirmsByNonce, $root.gravity.v1.QueryValsetConfirmsByNonceRequest, $root.gravity.v1.QueryValsetConfirmsByNonceResponse, request, callback);
            }, "name", { value: "ValsetConfirmsByNonce" });

            /**
             * Calls ValsetConfirmsByNonce.
             * @function valsetConfirmsByNonce
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryValsetConfirmsByNonceRequest} request QueryValsetConfirmsByNonceRequest message or plain object
             * @returns {Promise<gravity.v1.QueryValsetConfirmsByNonceResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#lastValsetRequests}.
             * @memberof gravity.v1.Query
             * @typedef LastValsetRequestsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryLastValsetRequestsResponse} [response] QueryLastValsetRequestsResponse
             */

            /**
             * Calls LastValsetRequests.
             * @function lastValsetRequests
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryLastValsetRequestsRequest} request QueryLastValsetRequestsRequest message or plain object
             * @param {gravity.v1.Query.LastValsetRequestsCallback} callback Node-style callback called with the error, if any, and QueryLastValsetRequestsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.lastValsetRequests = function lastValsetRequests(request, callback) {
                return this.rpcCall(lastValsetRequests, $root.gravity.v1.QueryLastValsetRequestsRequest, $root.gravity.v1.QueryLastValsetRequestsResponse, request, callback);
            }, "name", { value: "LastValsetRequests" });

            /**
             * Calls LastValsetRequests.
             * @function lastValsetRequests
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryLastValsetRequestsRequest} request QueryLastValsetRequestsRequest message or plain object
             * @returns {Promise<gravity.v1.QueryLastValsetRequestsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#lastPendingValsetRequestByAddr}.
             * @memberof gravity.v1.Query
             * @typedef LastPendingValsetRequestByAddrCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryLastPendingValsetRequestByAddrResponse} [response] QueryLastPendingValsetRequestByAddrResponse
             */

            /**
             * Calls LastPendingValsetRequestByAddr.
             * @function lastPendingValsetRequestByAddr
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrRequest} request QueryLastPendingValsetRequestByAddrRequest message or plain object
             * @param {gravity.v1.Query.LastPendingValsetRequestByAddrCallback} callback Node-style callback called with the error, if any, and QueryLastPendingValsetRequestByAddrResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.lastPendingValsetRequestByAddr = function lastPendingValsetRequestByAddr(request, callback) {
                return this.rpcCall(lastPendingValsetRequestByAddr, $root.gravity.v1.QueryLastPendingValsetRequestByAddrRequest, $root.gravity.v1.QueryLastPendingValsetRequestByAddrResponse, request, callback);
            }, "name", { value: "LastPendingValsetRequestByAddr" });

            /**
             * Calls LastPendingValsetRequestByAddr.
             * @function lastPendingValsetRequestByAddr
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrRequest} request QueryLastPendingValsetRequestByAddrRequest message or plain object
             * @returns {Promise<gravity.v1.QueryLastPendingValsetRequestByAddrResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#lastPendingBatchRequestByAddr}.
             * @memberof gravity.v1.Query
             * @typedef LastPendingBatchRequestByAddrCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryLastPendingBatchRequestByAddrResponse} [response] QueryLastPendingBatchRequestByAddrResponse
             */

            /**
             * Calls LastPendingBatchRequestByAddr.
             * @function lastPendingBatchRequestByAddr
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrRequest} request QueryLastPendingBatchRequestByAddrRequest message or plain object
             * @param {gravity.v1.Query.LastPendingBatchRequestByAddrCallback} callback Node-style callback called with the error, if any, and QueryLastPendingBatchRequestByAddrResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.lastPendingBatchRequestByAddr = function lastPendingBatchRequestByAddr(request, callback) {
                return this.rpcCall(lastPendingBatchRequestByAddr, $root.gravity.v1.QueryLastPendingBatchRequestByAddrRequest, $root.gravity.v1.QueryLastPendingBatchRequestByAddrResponse, request, callback);
            }, "name", { value: "LastPendingBatchRequestByAddr" });

            /**
             * Calls LastPendingBatchRequestByAddr.
             * @function lastPendingBatchRequestByAddr
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrRequest} request QueryLastPendingBatchRequestByAddrRequest message or plain object
             * @returns {Promise<gravity.v1.QueryLastPendingBatchRequestByAddrResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#lastPendingLogicCallByAddr}.
             * @memberof gravity.v1.Query
             * @typedef LastPendingLogicCallByAddrCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryLastPendingLogicCallByAddrResponse} [response] QueryLastPendingLogicCallByAddrResponse
             */

            /**
             * Calls LastPendingLogicCallByAddr.
             * @function lastPendingLogicCallByAddr
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryLastPendingLogicCallByAddrRequest} request QueryLastPendingLogicCallByAddrRequest message or plain object
             * @param {gravity.v1.Query.LastPendingLogicCallByAddrCallback} callback Node-style callback called with the error, if any, and QueryLastPendingLogicCallByAddrResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.lastPendingLogicCallByAddr = function lastPendingLogicCallByAddr(request, callback) {
                return this.rpcCall(lastPendingLogicCallByAddr, $root.gravity.v1.QueryLastPendingLogicCallByAddrRequest, $root.gravity.v1.QueryLastPendingLogicCallByAddrResponse, request, callback);
            }, "name", { value: "LastPendingLogicCallByAddr" });

            /**
             * Calls LastPendingLogicCallByAddr.
             * @function lastPendingLogicCallByAddr
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryLastPendingLogicCallByAddrRequest} request QueryLastPendingLogicCallByAddrRequest message or plain object
             * @returns {Promise<gravity.v1.QueryLastPendingLogicCallByAddrResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#lastEventNonceByAddr}.
             * @memberof gravity.v1.Query
             * @typedef LastEventNonceByAddrCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryLastEventNonceByAddrResponse} [response] QueryLastEventNonceByAddrResponse
             */

            /**
             * Calls LastEventNonceByAddr.
             * @function lastEventNonceByAddr
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryLastEventNonceByAddrRequest} request QueryLastEventNonceByAddrRequest message or plain object
             * @param {gravity.v1.Query.LastEventNonceByAddrCallback} callback Node-style callback called with the error, if any, and QueryLastEventNonceByAddrResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.lastEventNonceByAddr = function lastEventNonceByAddr(request, callback) {
                return this.rpcCall(lastEventNonceByAddr, $root.gravity.v1.QueryLastEventNonceByAddrRequest, $root.gravity.v1.QueryLastEventNonceByAddrResponse, request, callback);
            }, "name", { value: "LastEventNonceByAddr" });

            /**
             * Calls LastEventNonceByAddr.
             * @function lastEventNonceByAddr
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryLastEventNonceByAddrRequest} request QueryLastEventNonceByAddrRequest message or plain object
             * @returns {Promise<gravity.v1.QueryLastEventNonceByAddrResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#batchFees}.
             * @memberof gravity.v1.Query
             * @typedef BatchFeesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryBatchFeeResponse} [response] QueryBatchFeeResponse
             */

            /**
             * Calls BatchFees.
             * @function batchFees
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryBatchFeeRequest} request QueryBatchFeeRequest message or plain object
             * @param {gravity.v1.Query.BatchFeesCallback} callback Node-style callback called with the error, if any, and QueryBatchFeeResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.batchFees = function batchFees(request, callback) {
                return this.rpcCall(batchFees, $root.gravity.v1.QueryBatchFeeRequest, $root.gravity.v1.QueryBatchFeeResponse, request, callback);
            }, "name", { value: "BatchFees" });

            /**
             * Calls BatchFees.
             * @function batchFees
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryBatchFeeRequest} request QueryBatchFeeRequest message or plain object
             * @returns {Promise<gravity.v1.QueryBatchFeeResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#outgoingTxBatches}.
             * @memberof gravity.v1.Query
             * @typedef OutgoingTxBatchesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryOutgoingTxBatchesResponse} [response] QueryOutgoingTxBatchesResponse
             */

            /**
             * Calls OutgoingTxBatches.
             * @function outgoingTxBatches
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryOutgoingTxBatchesRequest} request QueryOutgoingTxBatchesRequest message or plain object
             * @param {gravity.v1.Query.OutgoingTxBatchesCallback} callback Node-style callback called with the error, if any, and QueryOutgoingTxBatchesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.outgoingTxBatches = function outgoingTxBatches(request, callback) {
                return this.rpcCall(outgoingTxBatches, $root.gravity.v1.QueryOutgoingTxBatchesRequest, $root.gravity.v1.QueryOutgoingTxBatchesResponse, request, callback);
            }, "name", { value: "OutgoingTxBatches" });

            /**
             * Calls OutgoingTxBatches.
             * @function outgoingTxBatches
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryOutgoingTxBatchesRequest} request QueryOutgoingTxBatchesRequest message or plain object
             * @returns {Promise<gravity.v1.QueryOutgoingTxBatchesResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#outgoingLogicCalls}.
             * @memberof gravity.v1.Query
             * @typedef OutgoingLogicCallsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryOutgoingLogicCallsResponse} [response] QueryOutgoingLogicCallsResponse
             */

            /**
             * Calls OutgoingLogicCalls.
             * @function outgoingLogicCalls
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryOutgoingLogicCallsRequest} request QueryOutgoingLogicCallsRequest message or plain object
             * @param {gravity.v1.Query.OutgoingLogicCallsCallback} callback Node-style callback called with the error, if any, and QueryOutgoingLogicCallsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.outgoingLogicCalls = function outgoingLogicCalls(request, callback) {
                return this.rpcCall(outgoingLogicCalls, $root.gravity.v1.QueryOutgoingLogicCallsRequest, $root.gravity.v1.QueryOutgoingLogicCallsResponse, request, callback);
            }, "name", { value: "OutgoingLogicCalls" });

            /**
             * Calls OutgoingLogicCalls.
             * @function outgoingLogicCalls
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryOutgoingLogicCallsRequest} request QueryOutgoingLogicCallsRequest message or plain object
             * @returns {Promise<gravity.v1.QueryOutgoingLogicCallsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#batchRequestByNonce}.
             * @memberof gravity.v1.Query
             * @typedef BatchRequestByNonceCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryBatchRequestByNonceResponse} [response] QueryBatchRequestByNonceResponse
             */

            /**
             * Calls BatchRequestByNonce.
             * @function batchRequestByNonce
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryBatchRequestByNonceRequest} request QueryBatchRequestByNonceRequest message or plain object
             * @param {gravity.v1.Query.BatchRequestByNonceCallback} callback Node-style callback called with the error, if any, and QueryBatchRequestByNonceResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.batchRequestByNonce = function batchRequestByNonce(request, callback) {
                return this.rpcCall(batchRequestByNonce, $root.gravity.v1.QueryBatchRequestByNonceRequest, $root.gravity.v1.QueryBatchRequestByNonceResponse, request, callback);
            }, "name", { value: "BatchRequestByNonce" });

            /**
             * Calls BatchRequestByNonce.
             * @function batchRequestByNonce
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryBatchRequestByNonceRequest} request QueryBatchRequestByNonceRequest message or plain object
             * @returns {Promise<gravity.v1.QueryBatchRequestByNonceResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#batchConfirms}.
             * @memberof gravity.v1.Query
             * @typedef BatchConfirmsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryBatchConfirmsResponse} [response] QueryBatchConfirmsResponse
             */

            /**
             * Calls BatchConfirms.
             * @function batchConfirms
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryBatchConfirmsRequest} request QueryBatchConfirmsRequest message or plain object
             * @param {gravity.v1.Query.BatchConfirmsCallback} callback Node-style callback called with the error, if any, and QueryBatchConfirmsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.batchConfirms = function batchConfirms(request, callback) {
                return this.rpcCall(batchConfirms, $root.gravity.v1.QueryBatchConfirmsRequest, $root.gravity.v1.QueryBatchConfirmsResponse, request, callback);
            }, "name", { value: "BatchConfirms" });

            /**
             * Calls BatchConfirms.
             * @function batchConfirms
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryBatchConfirmsRequest} request QueryBatchConfirmsRequest message or plain object
             * @returns {Promise<gravity.v1.QueryBatchConfirmsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#logicConfirms}.
             * @memberof gravity.v1.Query
             * @typedef LogicConfirmsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryLogicConfirmsResponse} [response] QueryLogicConfirmsResponse
             */

            /**
             * Calls LogicConfirms.
             * @function logicConfirms
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryLogicConfirmsRequest} request QueryLogicConfirmsRequest message or plain object
             * @param {gravity.v1.Query.LogicConfirmsCallback} callback Node-style callback called with the error, if any, and QueryLogicConfirmsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.logicConfirms = function logicConfirms(request, callback) {
                return this.rpcCall(logicConfirms, $root.gravity.v1.QueryLogicConfirmsRequest, $root.gravity.v1.QueryLogicConfirmsResponse, request, callback);
            }, "name", { value: "LogicConfirms" });

            /**
             * Calls LogicConfirms.
             * @function logicConfirms
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryLogicConfirmsRequest} request QueryLogicConfirmsRequest message or plain object
             * @returns {Promise<gravity.v1.QueryLogicConfirmsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#eRC20ToDenom}.
             * @memberof gravity.v1.Query
             * @typedef ERC20ToDenomCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryERC20ToDenomResponse} [response] QueryERC20ToDenomResponse
             */

            /**
             * Calls ERC20ToDenom.
             * @function eRC20ToDenom
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryERC20ToDenomRequest} request QueryERC20ToDenomRequest message or plain object
             * @param {gravity.v1.Query.ERC20ToDenomCallback} callback Node-style callback called with the error, if any, and QueryERC20ToDenomResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.eRC20ToDenom = function eRC20ToDenom(request, callback) {
                return this.rpcCall(eRC20ToDenom, $root.gravity.v1.QueryERC20ToDenomRequest, $root.gravity.v1.QueryERC20ToDenomResponse, request, callback);
            }, "name", { value: "ERC20ToDenom" });

            /**
             * Calls ERC20ToDenom.
             * @function eRC20ToDenom
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryERC20ToDenomRequest} request QueryERC20ToDenomRequest message or plain object
             * @returns {Promise<gravity.v1.QueryERC20ToDenomResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#denomToERC20}.
             * @memberof gravity.v1.Query
             * @typedef DenomToERC20Callback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryDenomToERC20Response} [response] QueryDenomToERC20Response
             */

            /**
             * Calls DenomToERC20.
             * @function denomToERC20
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryDenomToERC20Request} request QueryDenomToERC20Request message or plain object
             * @param {gravity.v1.Query.DenomToERC20Callback} callback Node-style callback called with the error, if any, and QueryDenomToERC20Response
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.denomToERC20 = function denomToERC20(request, callback) {
                return this.rpcCall(denomToERC20, $root.gravity.v1.QueryDenomToERC20Request, $root.gravity.v1.QueryDenomToERC20Response, request, callback);
            }, "name", { value: "DenomToERC20" });

            /**
             * Calls DenomToERC20.
             * @function denomToERC20
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryDenomToERC20Request} request QueryDenomToERC20Request message or plain object
             * @returns {Promise<gravity.v1.QueryDenomToERC20Response>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#getAttestations}.
             * @memberof gravity.v1.Query
             * @typedef GetAttestationsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryAttestationsResponse} [response] QueryAttestationsResponse
             */

            /**
             * Calls GetAttestations.
             * @function getAttestations
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryAttestationsRequest} request QueryAttestationsRequest message or plain object
             * @param {gravity.v1.Query.GetAttestationsCallback} callback Node-style callback called with the error, if any, and QueryAttestationsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.getAttestations = function getAttestations(request, callback) {
                return this.rpcCall(getAttestations, $root.gravity.v1.QueryAttestationsRequest, $root.gravity.v1.QueryAttestationsResponse, request, callback);
            }, "name", { value: "GetAttestations" });

            /**
             * Calls GetAttestations.
             * @function getAttestations
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryAttestationsRequest} request QueryAttestationsRequest message or plain object
             * @returns {Promise<gravity.v1.QueryAttestationsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#getDelegateKeyByValidator}.
             * @memberof gravity.v1.Query
             * @typedef GetDelegateKeyByValidatorCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryDelegateKeysByValidatorAddressResponse} [response] QueryDelegateKeysByValidatorAddressResponse
             */

            /**
             * Calls GetDelegateKeyByValidator.
             * @function getDelegateKeyByValidator
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryDelegateKeysByValidatorAddress} request QueryDelegateKeysByValidatorAddress message or plain object
             * @param {gravity.v1.Query.GetDelegateKeyByValidatorCallback} callback Node-style callback called with the error, if any, and QueryDelegateKeysByValidatorAddressResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.getDelegateKeyByValidator = function getDelegateKeyByValidator(request, callback) {
                return this.rpcCall(getDelegateKeyByValidator, $root.gravity.v1.QueryDelegateKeysByValidatorAddress, $root.gravity.v1.QueryDelegateKeysByValidatorAddressResponse, request, callback);
            }, "name", { value: "GetDelegateKeyByValidator" });

            /**
             * Calls GetDelegateKeyByValidator.
             * @function getDelegateKeyByValidator
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryDelegateKeysByValidatorAddress} request QueryDelegateKeysByValidatorAddress message or plain object
             * @returns {Promise<gravity.v1.QueryDelegateKeysByValidatorAddressResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#getDelegateKeyByEth}.
             * @memberof gravity.v1.Query
             * @typedef GetDelegateKeyByEthCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryDelegateKeysByEthAddressResponse} [response] QueryDelegateKeysByEthAddressResponse
             */

            /**
             * Calls GetDelegateKeyByEth.
             * @function getDelegateKeyByEth
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryDelegateKeysByEthAddress} request QueryDelegateKeysByEthAddress message or plain object
             * @param {gravity.v1.Query.GetDelegateKeyByEthCallback} callback Node-style callback called with the error, if any, and QueryDelegateKeysByEthAddressResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.getDelegateKeyByEth = function getDelegateKeyByEth(request, callback) {
                return this.rpcCall(getDelegateKeyByEth, $root.gravity.v1.QueryDelegateKeysByEthAddress, $root.gravity.v1.QueryDelegateKeysByEthAddressResponse, request, callback);
            }, "name", { value: "GetDelegateKeyByEth" });

            /**
             * Calls GetDelegateKeyByEth.
             * @function getDelegateKeyByEth
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryDelegateKeysByEthAddress} request QueryDelegateKeysByEthAddress message or plain object
             * @returns {Promise<gravity.v1.QueryDelegateKeysByEthAddressResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#getDelegateKeyByOrchestrator}.
             * @memberof gravity.v1.Query
             * @typedef GetDelegateKeyByOrchestratorCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse} [response] QueryDelegateKeysByOrchestratorAddressResponse
             */

            /**
             * Calls GetDelegateKeyByOrchestrator.
             * @function getDelegateKeyByOrchestrator
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddress} request QueryDelegateKeysByOrchestratorAddress message or plain object
             * @param {gravity.v1.Query.GetDelegateKeyByOrchestratorCallback} callback Node-style callback called with the error, if any, and QueryDelegateKeysByOrchestratorAddressResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.getDelegateKeyByOrchestrator = function getDelegateKeyByOrchestrator(request, callback) {
                return this.rpcCall(getDelegateKeyByOrchestrator, $root.gravity.v1.QueryDelegateKeysByOrchestratorAddress, $root.gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse, request, callback);
            }, "name", { value: "GetDelegateKeyByOrchestrator" });

            /**
             * Calls GetDelegateKeyByOrchestrator.
             * @function getDelegateKeyByOrchestrator
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddress} request QueryDelegateKeysByOrchestratorAddress message or plain object
             * @returns {Promise<gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Query#getPendingSendToEth}.
             * @memberof gravity.v1.Query
             * @typedef GetPendingSendToEthCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.QueryPendingSendToEthResponse} [response] QueryPendingSendToEthResponse
             */

            /**
             * Calls GetPendingSendToEth.
             * @function getPendingSendToEth
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryPendingSendToEth} request QueryPendingSendToEth message or plain object
             * @param {gravity.v1.Query.GetPendingSendToEthCallback} callback Node-style callback called with the error, if any, and QueryPendingSendToEthResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Query.prototype.getPendingSendToEth = function getPendingSendToEth(request, callback) {
                return this.rpcCall(getPendingSendToEth, $root.gravity.v1.QueryPendingSendToEth, $root.gravity.v1.QueryPendingSendToEthResponse, request, callback);
            }, "name", { value: "GetPendingSendToEth" });

            /**
             * Calls GetPendingSendToEth.
             * @function getPendingSendToEth
             * @memberof gravity.v1.Query
             * @instance
             * @param {gravity.v1.IQueryPendingSendToEth} request QueryPendingSendToEth message or plain object
             * @returns {Promise<gravity.v1.QueryPendingSendToEthResponse>} Promise
             * @variation 2
             */

            return Query;
        })();

        v1.QueryParamsRequest = (function() {

            /**
             * Properties of a QueryParamsRequest.
             * @memberof gravity.v1
             * @interface IQueryParamsRequest
             */

            /**
             * Constructs a new QueryParamsRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryParamsRequest.
             * @implements IQueryParamsRequest
             * @constructor
             * @param {gravity.v1.IQueryParamsRequest=} [properties] Properties to set
             */
            function QueryParamsRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified QueryParamsRequest message. Does not implicitly {@link gravity.v1.QueryParamsRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryParamsRequest
             * @static
             * @param {gravity.v1.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryParamsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryParamsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryParamsRequest
             * @static
             * @param {gravity.v1.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryParamsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryParamsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryParamsRequest} QueryParamsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryParamsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryParamsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryParamsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryParamsRequest} QueryParamsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryParamsRequest message.
             * @function verify
             * @memberof gravity.v1.QueryParamsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryParamsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryParamsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryParamsRequest} QueryParamsRequest
             */
            QueryParamsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryParamsRequest)
                    return object;
                return new $root.gravity.v1.QueryParamsRequest();
            };

            /**
             * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryParamsRequest
             * @static
             * @param {gravity.v1.QueryParamsRequest} message QueryParamsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryParamsRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this QueryParamsRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryParamsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryParamsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryParamsRequest;
        })();

        v1.QueryParamsResponse = (function() {

            /**
             * Properties of a QueryParamsResponse.
             * @memberof gravity.v1
             * @interface IQueryParamsResponse
             * @property {gravity.v1.IParams|null} [params] QueryParamsResponse params
             */

            /**
             * Constructs a new QueryParamsResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryParamsResponse.
             * @implements IQueryParamsResponse
             * @constructor
             * @param {gravity.v1.IQueryParamsResponse=} [properties] Properties to set
             */
            function QueryParamsResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryParamsResponse params.
             * @member {gravity.v1.IParams|null|undefined} params
             * @memberof gravity.v1.QueryParamsResponse
             * @instance
             */
            QueryParamsResponse.prototype.params = null;

            /**
             * Encodes the specified QueryParamsResponse message. Does not implicitly {@link gravity.v1.QueryParamsResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryParamsResponse
             * @static
             * @param {gravity.v1.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryParamsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                    $root.gravity.v1.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryParamsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryParamsResponse
             * @static
             * @param {gravity.v1.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryParamsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryParamsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryParamsResponse} QueryParamsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryParamsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryParamsResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.params = $root.gravity.v1.Params.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryParamsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryParamsResponse} QueryParamsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryParamsResponse message.
             * @function verify
             * @memberof gravity.v1.QueryParamsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryParamsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.params != null && message.hasOwnProperty("params")) {
                    let error = $root.gravity.v1.Params.verify(message.params);
                    if (error)
                        return "params." + error;
                }
                return null;
            };

            /**
             * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryParamsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryParamsResponse} QueryParamsResponse
             */
            QueryParamsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryParamsResponse)
                    return object;
                let message = new $root.gravity.v1.QueryParamsResponse();
                if (object.params != null) {
                    if (typeof object.params !== "object")
                        throw TypeError(".gravity.v1.QueryParamsResponse.params: object expected");
                    message.params = $root.gravity.v1.Params.fromObject(object.params);
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryParamsResponse
             * @static
             * @param {gravity.v1.QueryParamsResponse} message QueryParamsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryParamsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.params = null;
                if (message.params != null && message.hasOwnProperty("params"))
                    object.params = $root.gravity.v1.Params.toObject(message.params, options);
                return object;
            };

            /**
             * Converts this QueryParamsResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryParamsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryParamsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryParamsResponse;
        })();

        v1.QueryCurrentValsetRequest = (function() {

            /**
             * Properties of a QueryCurrentValsetRequest.
             * @memberof gravity.v1
             * @interface IQueryCurrentValsetRequest
             */

            /**
             * Constructs a new QueryCurrentValsetRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryCurrentValsetRequest.
             * @implements IQueryCurrentValsetRequest
             * @constructor
             * @param {gravity.v1.IQueryCurrentValsetRequest=} [properties] Properties to set
             */
            function QueryCurrentValsetRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified QueryCurrentValsetRequest message. Does not implicitly {@link gravity.v1.QueryCurrentValsetRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryCurrentValsetRequest
             * @static
             * @param {gravity.v1.IQueryCurrentValsetRequest} message QueryCurrentValsetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryCurrentValsetRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified QueryCurrentValsetRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryCurrentValsetRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryCurrentValsetRequest
             * @static
             * @param {gravity.v1.IQueryCurrentValsetRequest} message QueryCurrentValsetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryCurrentValsetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryCurrentValsetRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryCurrentValsetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryCurrentValsetRequest} QueryCurrentValsetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryCurrentValsetRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryCurrentValsetRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryCurrentValsetRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryCurrentValsetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryCurrentValsetRequest} QueryCurrentValsetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryCurrentValsetRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryCurrentValsetRequest message.
             * @function verify
             * @memberof gravity.v1.QueryCurrentValsetRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryCurrentValsetRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a QueryCurrentValsetRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryCurrentValsetRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryCurrentValsetRequest} QueryCurrentValsetRequest
             */
            QueryCurrentValsetRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryCurrentValsetRequest)
                    return object;
                return new $root.gravity.v1.QueryCurrentValsetRequest();
            };

            /**
             * Creates a plain object from a QueryCurrentValsetRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryCurrentValsetRequest
             * @static
             * @param {gravity.v1.QueryCurrentValsetRequest} message QueryCurrentValsetRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryCurrentValsetRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this QueryCurrentValsetRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryCurrentValsetRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryCurrentValsetRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryCurrentValsetRequest;
        })();

        v1.QueryCurrentValsetResponse = (function() {

            /**
             * Properties of a QueryCurrentValsetResponse.
             * @memberof gravity.v1
             * @interface IQueryCurrentValsetResponse
             * @property {gravity.v1.IValset|null} [valset] QueryCurrentValsetResponse valset
             */

            /**
             * Constructs a new QueryCurrentValsetResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryCurrentValsetResponse.
             * @implements IQueryCurrentValsetResponse
             * @constructor
             * @param {gravity.v1.IQueryCurrentValsetResponse=} [properties] Properties to set
             */
            function QueryCurrentValsetResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryCurrentValsetResponse valset.
             * @member {gravity.v1.IValset|null|undefined} valset
             * @memberof gravity.v1.QueryCurrentValsetResponse
             * @instance
             */
            QueryCurrentValsetResponse.prototype.valset = null;

            /**
             * Encodes the specified QueryCurrentValsetResponse message. Does not implicitly {@link gravity.v1.QueryCurrentValsetResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryCurrentValsetResponse
             * @static
             * @param {gravity.v1.IQueryCurrentValsetResponse} message QueryCurrentValsetResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryCurrentValsetResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.valset != null && Object.hasOwnProperty.call(message, "valset"))
                    $root.gravity.v1.Valset.encode(message.valset, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryCurrentValsetResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryCurrentValsetResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryCurrentValsetResponse
             * @static
             * @param {gravity.v1.IQueryCurrentValsetResponse} message QueryCurrentValsetResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryCurrentValsetResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryCurrentValsetResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryCurrentValsetResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryCurrentValsetResponse} QueryCurrentValsetResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryCurrentValsetResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryCurrentValsetResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.valset = $root.gravity.v1.Valset.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryCurrentValsetResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryCurrentValsetResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryCurrentValsetResponse} QueryCurrentValsetResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryCurrentValsetResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryCurrentValsetResponse message.
             * @function verify
             * @memberof gravity.v1.QueryCurrentValsetResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryCurrentValsetResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.valset != null && message.hasOwnProperty("valset")) {
                    let error = $root.gravity.v1.Valset.verify(message.valset);
                    if (error)
                        return "valset." + error;
                }
                return null;
            };

            /**
             * Creates a QueryCurrentValsetResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryCurrentValsetResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryCurrentValsetResponse} QueryCurrentValsetResponse
             */
            QueryCurrentValsetResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryCurrentValsetResponse)
                    return object;
                let message = new $root.gravity.v1.QueryCurrentValsetResponse();
                if (object.valset != null) {
                    if (typeof object.valset !== "object")
                        throw TypeError(".gravity.v1.QueryCurrentValsetResponse.valset: object expected");
                    message.valset = $root.gravity.v1.Valset.fromObject(object.valset);
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryCurrentValsetResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryCurrentValsetResponse
             * @static
             * @param {gravity.v1.QueryCurrentValsetResponse} message QueryCurrentValsetResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryCurrentValsetResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.valset = null;
                if (message.valset != null && message.hasOwnProperty("valset"))
                    object.valset = $root.gravity.v1.Valset.toObject(message.valset, options);
                return object;
            };

            /**
             * Converts this QueryCurrentValsetResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryCurrentValsetResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryCurrentValsetResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryCurrentValsetResponse;
        })();

        v1.QueryValsetRequestRequest = (function() {

            /**
             * Properties of a QueryValsetRequestRequest.
             * @memberof gravity.v1
             * @interface IQueryValsetRequestRequest
             * @property {Long|null} [nonce] QueryValsetRequestRequest nonce
             */

            /**
             * Constructs a new QueryValsetRequestRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryValsetRequestRequest.
             * @implements IQueryValsetRequestRequest
             * @constructor
             * @param {gravity.v1.IQueryValsetRequestRequest=} [properties] Properties to set
             */
            function QueryValsetRequestRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryValsetRequestRequest nonce.
             * @member {Long} nonce
             * @memberof gravity.v1.QueryValsetRequestRequest
             * @instance
             */
            QueryValsetRequestRequest.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified QueryValsetRequestRequest message. Does not implicitly {@link gravity.v1.QueryValsetRequestRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryValsetRequestRequest
             * @static
             * @param {gravity.v1.IQueryValsetRequestRequest} message QueryValsetRequestRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryValsetRequestRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                return writer;
            };

            /**
             * Encodes the specified QueryValsetRequestRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryValsetRequestRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryValsetRequestRequest
             * @static
             * @param {gravity.v1.IQueryValsetRequestRequest} message QueryValsetRequestRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryValsetRequestRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryValsetRequestRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryValsetRequestRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryValsetRequestRequest} QueryValsetRequestRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryValsetRequestRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryValsetRequestRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryValsetRequestRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryValsetRequestRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryValsetRequestRequest} QueryValsetRequestRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryValsetRequestRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryValsetRequestRequest message.
             * @function verify
             * @memberof gravity.v1.QueryValsetRequestRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryValsetRequestRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                return null;
            };

            /**
             * Creates a QueryValsetRequestRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryValsetRequestRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryValsetRequestRequest} QueryValsetRequestRequest
             */
            QueryValsetRequestRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryValsetRequestRequest)
                    return object;
                let message = new $root.gravity.v1.QueryValsetRequestRequest();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a QueryValsetRequestRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryValsetRequestRequest
             * @static
             * @param {gravity.v1.QueryValsetRequestRequest} message QueryValsetRequestRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryValsetRequestRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                return object;
            };

            /**
             * Converts this QueryValsetRequestRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryValsetRequestRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryValsetRequestRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryValsetRequestRequest;
        })();

        v1.QueryValsetRequestResponse = (function() {

            /**
             * Properties of a QueryValsetRequestResponse.
             * @memberof gravity.v1
             * @interface IQueryValsetRequestResponse
             * @property {gravity.v1.IValset|null} [valset] QueryValsetRequestResponse valset
             */

            /**
             * Constructs a new QueryValsetRequestResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryValsetRequestResponse.
             * @implements IQueryValsetRequestResponse
             * @constructor
             * @param {gravity.v1.IQueryValsetRequestResponse=} [properties] Properties to set
             */
            function QueryValsetRequestResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryValsetRequestResponse valset.
             * @member {gravity.v1.IValset|null|undefined} valset
             * @memberof gravity.v1.QueryValsetRequestResponse
             * @instance
             */
            QueryValsetRequestResponse.prototype.valset = null;

            /**
             * Encodes the specified QueryValsetRequestResponse message. Does not implicitly {@link gravity.v1.QueryValsetRequestResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryValsetRequestResponse
             * @static
             * @param {gravity.v1.IQueryValsetRequestResponse} message QueryValsetRequestResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryValsetRequestResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.valset != null && Object.hasOwnProperty.call(message, "valset"))
                    $root.gravity.v1.Valset.encode(message.valset, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryValsetRequestResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryValsetRequestResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryValsetRequestResponse
             * @static
             * @param {gravity.v1.IQueryValsetRequestResponse} message QueryValsetRequestResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryValsetRequestResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryValsetRequestResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryValsetRequestResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryValsetRequestResponse} QueryValsetRequestResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryValsetRequestResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryValsetRequestResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.valset = $root.gravity.v1.Valset.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryValsetRequestResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryValsetRequestResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryValsetRequestResponse} QueryValsetRequestResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryValsetRequestResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryValsetRequestResponse message.
             * @function verify
             * @memberof gravity.v1.QueryValsetRequestResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryValsetRequestResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.valset != null && message.hasOwnProperty("valset")) {
                    let error = $root.gravity.v1.Valset.verify(message.valset);
                    if (error)
                        return "valset." + error;
                }
                return null;
            };

            /**
             * Creates a QueryValsetRequestResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryValsetRequestResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryValsetRequestResponse} QueryValsetRequestResponse
             */
            QueryValsetRequestResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryValsetRequestResponse)
                    return object;
                let message = new $root.gravity.v1.QueryValsetRequestResponse();
                if (object.valset != null) {
                    if (typeof object.valset !== "object")
                        throw TypeError(".gravity.v1.QueryValsetRequestResponse.valset: object expected");
                    message.valset = $root.gravity.v1.Valset.fromObject(object.valset);
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryValsetRequestResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryValsetRequestResponse
             * @static
             * @param {gravity.v1.QueryValsetRequestResponse} message QueryValsetRequestResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryValsetRequestResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.valset = null;
                if (message.valset != null && message.hasOwnProperty("valset"))
                    object.valset = $root.gravity.v1.Valset.toObject(message.valset, options);
                return object;
            };

            /**
             * Converts this QueryValsetRequestResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryValsetRequestResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryValsetRequestResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryValsetRequestResponse;
        })();

        v1.QueryValsetConfirmRequest = (function() {

            /**
             * Properties of a QueryValsetConfirmRequest.
             * @memberof gravity.v1
             * @interface IQueryValsetConfirmRequest
             * @property {Long|null} [nonce] QueryValsetConfirmRequest nonce
             * @property {string|null} [address] QueryValsetConfirmRequest address
             */

            /**
             * Constructs a new QueryValsetConfirmRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryValsetConfirmRequest.
             * @implements IQueryValsetConfirmRequest
             * @constructor
             * @param {gravity.v1.IQueryValsetConfirmRequest=} [properties] Properties to set
             */
            function QueryValsetConfirmRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryValsetConfirmRequest nonce.
             * @member {Long} nonce
             * @memberof gravity.v1.QueryValsetConfirmRequest
             * @instance
             */
            QueryValsetConfirmRequest.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * QueryValsetConfirmRequest address.
             * @member {string} address
             * @memberof gravity.v1.QueryValsetConfirmRequest
             * @instance
             */
            QueryValsetConfirmRequest.prototype.address = "";

            /**
             * Encodes the specified QueryValsetConfirmRequest message. Does not implicitly {@link gravity.v1.QueryValsetConfirmRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryValsetConfirmRequest
             * @static
             * @param {gravity.v1.IQueryValsetConfirmRequest} message QueryValsetConfirmRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryValsetConfirmRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.address);
                return writer;
            };

            /**
             * Encodes the specified QueryValsetConfirmRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryValsetConfirmRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryValsetConfirmRequest
             * @static
             * @param {gravity.v1.IQueryValsetConfirmRequest} message QueryValsetConfirmRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryValsetConfirmRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryValsetConfirmRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryValsetConfirmRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryValsetConfirmRequest} QueryValsetConfirmRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryValsetConfirmRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryValsetConfirmRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        message.address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryValsetConfirmRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryValsetConfirmRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryValsetConfirmRequest} QueryValsetConfirmRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryValsetConfirmRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryValsetConfirmRequest message.
             * @function verify
             * @memberof gravity.v1.QueryValsetConfirmRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryValsetConfirmRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                return null;
            };

            /**
             * Creates a QueryValsetConfirmRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryValsetConfirmRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryValsetConfirmRequest} QueryValsetConfirmRequest
             */
            QueryValsetConfirmRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryValsetConfirmRequest)
                    return object;
                let message = new $root.gravity.v1.QueryValsetConfirmRequest();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.address != null)
                    message.address = String(object.address);
                return message;
            };

            /**
             * Creates a plain object from a QueryValsetConfirmRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryValsetConfirmRequest
             * @static
             * @param {gravity.v1.QueryValsetConfirmRequest} message QueryValsetConfirmRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryValsetConfirmRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    object.address = "";
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                return object;
            };

            /**
             * Converts this QueryValsetConfirmRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryValsetConfirmRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryValsetConfirmRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryValsetConfirmRequest;
        })();

        v1.QueryValsetConfirmResponse = (function() {

            /**
             * Properties of a QueryValsetConfirmResponse.
             * @memberof gravity.v1
             * @interface IQueryValsetConfirmResponse
             * @property {gravity.v1.IMsgValsetConfirm|null} [confirm] QueryValsetConfirmResponse confirm
             */

            /**
             * Constructs a new QueryValsetConfirmResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryValsetConfirmResponse.
             * @implements IQueryValsetConfirmResponse
             * @constructor
             * @param {gravity.v1.IQueryValsetConfirmResponse=} [properties] Properties to set
             */
            function QueryValsetConfirmResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryValsetConfirmResponse confirm.
             * @member {gravity.v1.IMsgValsetConfirm|null|undefined} confirm
             * @memberof gravity.v1.QueryValsetConfirmResponse
             * @instance
             */
            QueryValsetConfirmResponse.prototype.confirm = null;

            /**
             * Encodes the specified QueryValsetConfirmResponse message. Does not implicitly {@link gravity.v1.QueryValsetConfirmResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryValsetConfirmResponse
             * @static
             * @param {gravity.v1.IQueryValsetConfirmResponse} message QueryValsetConfirmResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryValsetConfirmResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.confirm != null && Object.hasOwnProperty.call(message, "confirm"))
                    $root.gravity.v1.MsgValsetConfirm.encode(message.confirm, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryValsetConfirmResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryValsetConfirmResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryValsetConfirmResponse
             * @static
             * @param {gravity.v1.IQueryValsetConfirmResponse} message QueryValsetConfirmResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryValsetConfirmResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryValsetConfirmResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryValsetConfirmResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryValsetConfirmResponse} QueryValsetConfirmResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryValsetConfirmResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryValsetConfirmResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.confirm = $root.gravity.v1.MsgValsetConfirm.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryValsetConfirmResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryValsetConfirmResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryValsetConfirmResponse} QueryValsetConfirmResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryValsetConfirmResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryValsetConfirmResponse message.
             * @function verify
             * @memberof gravity.v1.QueryValsetConfirmResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryValsetConfirmResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.confirm != null && message.hasOwnProperty("confirm")) {
                    let error = $root.gravity.v1.MsgValsetConfirm.verify(message.confirm);
                    if (error)
                        return "confirm." + error;
                }
                return null;
            };

            /**
             * Creates a QueryValsetConfirmResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryValsetConfirmResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryValsetConfirmResponse} QueryValsetConfirmResponse
             */
            QueryValsetConfirmResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryValsetConfirmResponse)
                    return object;
                let message = new $root.gravity.v1.QueryValsetConfirmResponse();
                if (object.confirm != null) {
                    if (typeof object.confirm !== "object")
                        throw TypeError(".gravity.v1.QueryValsetConfirmResponse.confirm: object expected");
                    message.confirm = $root.gravity.v1.MsgValsetConfirm.fromObject(object.confirm);
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryValsetConfirmResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryValsetConfirmResponse
             * @static
             * @param {gravity.v1.QueryValsetConfirmResponse} message QueryValsetConfirmResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryValsetConfirmResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.confirm = null;
                if (message.confirm != null && message.hasOwnProperty("confirm"))
                    object.confirm = $root.gravity.v1.MsgValsetConfirm.toObject(message.confirm, options);
                return object;
            };

            /**
             * Converts this QueryValsetConfirmResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryValsetConfirmResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryValsetConfirmResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryValsetConfirmResponse;
        })();

        v1.QueryValsetConfirmsByNonceRequest = (function() {

            /**
             * Properties of a QueryValsetConfirmsByNonceRequest.
             * @memberof gravity.v1
             * @interface IQueryValsetConfirmsByNonceRequest
             * @property {Long|null} [nonce] QueryValsetConfirmsByNonceRequest nonce
             */

            /**
             * Constructs a new QueryValsetConfirmsByNonceRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryValsetConfirmsByNonceRequest.
             * @implements IQueryValsetConfirmsByNonceRequest
             * @constructor
             * @param {gravity.v1.IQueryValsetConfirmsByNonceRequest=} [properties] Properties to set
             */
            function QueryValsetConfirmsByNonceRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryValsetConfirmsByNonceRequest nonce.
             * @member {Long} nonce
             * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
             * @instance
             */
            QueryValsetConfirmsByNonceRequest.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified QueryValsetConfirmsByNonceRequest message. Does not implicitly {@link gravity.v1.QueryValsetConfirmsByNonceRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
             * @static
             * @param {gravity.v1.IQueryValsetConfirmsByNonceRequest} message QueryValsetConfirmsByNonceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryValsetConfirmsByNonceRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                return writer;
            };

            /**
             * Encodes the specified QueryValsetConfirmsByNonceRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryValsetConfirmsByNonceRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
             * @static
             * @param {gravity.v1.IQueryValsetConfirmsByNonceRequest} message QueryValsetConfirmsByNonceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryValsetConfirmsByNonceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryValsetConfirmsByNonceRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryValsetConfirmsByNonceRequest} QueryValsetConfirmsByNonceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryValsetConfirmsByNonceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryValsetConfirmsByNonceRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryValsetConfirmsByNonceRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryValsetConfirmsByNonceRequest} QueryValsetConfirmsByNonceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryValsetConfirmsByNonceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryValsetConfirmsByNonceRequest message.
             * @function verify
             * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryValsetConfirmsByNonceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                return null;
            };

            /**
             * Creates a QueryValsetConfirmsByNonceRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryValsetConfirmsByNonceRequest} QueryValsetConfirmsByNonceRequest
             */
            QueryValsetConfirmsByNonceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryValsetConfirmsByNonceRequest)
                    return object;
                let message = new $root.gravity.v1.QueryValsetConfirmsByNonceRequest();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a QueryValsetConfirmsByNonceRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
             * @static
             * @param {gravity.v1.QueryValsetConfirmsByNonceRequest} message QueryValsetConfirmsByNonceRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryValsetConfirmsByNonceRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                return object;
            };

            /**
             * Converts this QueryValsetConfirmsByNonceRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryValsetConfirmsByNonceRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryValsetConfirmsByNonceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryValsetConfirmsByNonceRequest;
        })();

        v1.QueryValsetConfirmsByNonceResponse = (function() {

            /**
             * Properties of a QueryValsetConfirmsByNonceResponse.
             * @memberof gravity.v1
             * @interface IQueryValsetConfirmsByNonceResponse
             * @property {Array.<gravity.v1.IMsgValsetConfirm>|null} [confirms] QueryValsetConfirmsByNonceResponse confirms
             */

            /**
             * Constructs a new QueryValsetConfirmsByNonceResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryValsetConfirmsByNonceResponse.
             * @implements IQueryValsetConfirmsByNonceResponse
             * @constructor
             * @param {gravity.v1.IQueryValsetConfirmsByNonceResponse=} [properties] Properties to set
             */
            function QueryValsetConfirmsByNonceResponse(properties) {
                this.confirms = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryValsetConfirmsByNonceResponse confirms.
             * @member {Array.<gravity.v1.IMsgValsetConfirm>} confirms
             * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
             * @instance
             */
            QueryValsetConfirmsByNonceResponse.prototype.confirms = $util.emptyArray;

            /**
             * Encodes the specified QueryValsetConfirmsByNonceResponse message. Does not implicitly {@link gravity.v1.QueryValsetConfirmsByNonceResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
             * @static
             * @param {gravity.v1.IQueryValsetConfirmsByNonceResponse} message QueryValsetConfirmsByNonceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryValsetConfirmsByNonceResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.confirms != null && message.confirms.length)
                    for (let i = 0; i < message.confirms.length; ++i)
                        $root.gravity.v1.MsgValsetConfirm.encode(message.confirms[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryValsetConfirmsByNonceResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryValsetConfirmsByNonceResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
             * @static
             * @param {gravity.v1.IQueryValsetConfirmsByNonceResponse} message QueryValsetConfirmsByNonceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryValsetConfirmsByNonceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryValsetConfirmsByNonceResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryValsetConfirmsByNonceResponse} QueryValsetConfirmsByNonceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryValsetConfirmsByNonceResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryValsetConfirmsByNonceResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.confirms && message.confirms.length))
                            message.confirms = [];
                        message.confirms.push($root.gravity.v1.MsgValsetConfirm.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryValsetConfirmsByNonceResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryValsetConfirmsByNonceResponse} QueryValsetConfirmsByNonceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryValsetConfirmsByNonceResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryValsetConfirmsByNonceResponse message.
             * @function verify
             * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryValsetConfirmsByNonceResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.confirms != null && message.hasOwnProperty("confirms")) {
                    if (!Array.isArray(message.confirms))
                        return "confirms: array expected";
                    for (let i = 0; i < message.confirms.length; ++i) {
                        let error = $root.gravity.v1.MsgValsetConfirm.verify(message.confirms[i]);
                        if (error)
                            return "confirms." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryValsetConfirmsByNonceResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryValsetConfirmsByNonceResponse} QueryValsetConfirmsByNonceResponse
             */
            QueryValsetConfirmsByNonceResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryValsetConfirmsByNonceResponse)
                    return object;
                let message = new $root.gravity.v1.QueryValsetConfirmsByNonceResponse();
                if (object.confirms) {
                    if (!Array.isArray(object.confirms))
                        throw TypeError(".gravity.v1.QueryValsetConfirmsByNonceResponse.confirms: array expected");
                    message.confirms = [];
                    for (let i = 0; i < object.confirms.length; ++i) {
                        if (typeof object.confirms[i] !== "object")
                            throw TypeError(".gravity.v1.QueryValsetConfirmsByNonceResponse.confirms: object expected");
                        message.confirms[i] = $root.gravity.v1.MsgValsetConfirm.fromObject(object.confirms[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryValsetConfirmsByNonceResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
             * @static
             * @param {gravity.v1.QueryValsetConfirmsByNonceResponse} message QueryValsetConfirmsByNonceResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryValsetConfirmsByNonceResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.confirms = [];
                if (message.confirms && message.confirms.length) {
                    object.confirms = [];
                    for (let j = 0; j < message.confirms.length; ++j)
                        object.confirms[j] = $root.gravity.v1.MsgValsetConfirm.toObject(message.confirms[j], options);
                }
                return object;
            };

            /**
             * Converts this QueryValsetConfirmsByNonceResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryValsetConfirmsByNonceResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryValsetConfirmsByNonceResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryValsetConfirmsByNonceResponse;
        })();

        v1.QueryLastValsetRequestsRequest = (function() {

            /**
             * Properties of a QueryLastValsetRequestsRequest.
             * @memberof gravity.v1
             * @interface IQueryLastValsetRequestsRequest
             */

            /**
             * Constructs a new QueryLastValsetRequestsRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryLastValsetRequestsRequest.
             * @implements IQueryLastValsetRequestsRequest
             * @constructor
             * @param {gravity.v1.IQueryLastValsetRequestsRequest=} [properties] Properties to set
             */
            function QueryLastValsetRequestsRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified QueryLastValsetRequestsRequest message. Does not implicitly {@link gravity.v1.QueryLastValsetRequestsRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryLastValsetRequestsRequest
             * @static
             * @param {gravity.v1.IQueryLastValsetRequestsRequest} message QueryLastValsetRequestsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastValsetRequestsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified QueryLastValsetRequestsRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryLastValsetRequestsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryLastValsetRequestsRequest
             * @static
             * @param {gravity.v1.IQueryLastValsetRequestsRequest} message QueryLastValsetRequestsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastValsetRequestsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryLastValsetRequestsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryLastValsetRequestsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryLastValsetRequestsRequest} QueryLastValsetRequestsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastValsetRequestsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastValsetRequestsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryLastValsetRequestsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryLastValsetRequestsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryLastValsetRequestsRequest} QueryLastValsetRequestsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastValsetRequestsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryLastValsetRequestsRequest message.
             * @function verify
             * @memberof gravity.v1.QueryLastValsetRequestsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryLastValsetRequestsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a QueryLastValsetRequestsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryLastValsetRequestsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryLastValsetRequestsRequest} QueryLastValsetRequestsRequest
             */
            QueryLastValsetRequestsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryLastValsetRequestsRequest)
                    return object;
                return new $root.gravity.v1.QueryLastValsetRequestsRequest();
            };

            /**
             * Creates a plain object from a QueryLastValsetRequestsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryLastValsetRequestsRequest
             * @static
             * @param {gravity.v1.QueryLastValsetRequestsRequest} message QueryLastValsetRequestsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryLastValsetRequestsRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this QueryLastValsetRequestsRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryLastValsetRequestsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryLastValsetRequestsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryLastValsetRequestsRequest;
        })();

        v1.QueryLastValsetRequestsResponse = (function() {

            /**
             * Properties of a QueryLastValsetRequestsResponse.
             * @memberof gravity.v1
             * @interface IQueryLastValsetRequestsResponse
             * @property {Array.<gravity.v1.IValset>|null} [valsets] QueryLastValsetRequestsResponse valsets
             */

            /**
             * Constructs a new QueryLastValsetRequestsResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryLastValsetRequestsResponse.
             * @implements IQueryLastValsetRequestsResponse
             * @constructor
             * @param {gravity.v1.IQueryLastValsetRequestsResponse=} [properties] Properties to set
             */
            function QueryLastValsetRequestsResponse(properties) {
                this.valsets = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryLastValsetRequestsResponse valsets.
             * @member {Array.<gravity.v1.IValset>} valsets
             * @memberof gravity.v1.QueryLastValsetRequestsResponse
             * @instance
             */
            QueryLastValsetRequestsResponse.prototype.valsets = $util.emptyArray;

            /**
             * Encodes the specified QueryLastValsetRequestsResponse message. Does not implicitly {@link gravity.v1.QueryLastValsetRequestsResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryLastValsetRequestsResponse
             * @static
             * @param {gravity.v1.IQueryLastValsetRequestsResponse} message QueryLastValsetRequestsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastValsetRequestsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.valsets != null && message.valsets.length)
                    for (let i = 0; i < message.valsets.length; ++i)
                        $root.gravity.v1.Valset.encode(message.valsets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryLastValsetRequestsResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryLastValsetRequestsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryLastValsetRequestsResponse
             * @static
             * @param {gravity.v1.IQueryLastValsetRequestsResponse} message QueryLastValsetRequestsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastValsetRequestsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryLastValsetRequestsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryLastValsetRequestsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryLastValsetRequestsResponse} QueryLastValsetRequestsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastValsetRequestsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastValsetRequestsResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.valsets && message.valsets.length))
                            message.valsets = [];
                        message.valsets.push($root.gravity.v1.Valset.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryLastValsetRequestsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryLastValsetRequestsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryLastValsetRequestsResponse} QueryLastValsetRequestsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastValsetRequestsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryLastValsetRequestsResponse message.
             * @function verify
             * @memberof gravity.v1.QueryLastValsetRequestsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryLastValsetRequestsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.valsets != null && message.hasOwnProperty("valsets")) {
                    if (!Array.isArray(message.valsets))
                        return "valsets: array expected";
                    for (let i = 0; i < message.valsets.length; ++i) {
                        let error = $root.gravity.v1.Valset.verify(message.valsets[i]);
                        if (error)
                            return "valsets." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryLastValsetRequestsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryLastValsetRequestsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryLastValsetRequestsResponse} QueryLastValsetRequestsResponse
             */
            QueryLastValsetRequestsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryLastValsetRequestsResponse)
                    return object;
                let message = new $root.gravity.v1.QueryLastValsetRequestsResponse();
                if (object.valsets) {
                    if (!Array.isArray(object.valsets))
                        throw TypeError(".gravity.v1.QueryLastValsetRequestsResponse.valsets: array expected");
                    message.valsets = [];
                    for (let i = 0; i < object.valsets.length; ++i) {
                        if (typeof object.valsets[i] !== "object")
                            throw TypeError(".gravity.v1.QueryLastValsetRequestsResponse.valsets: object expected");
                        message.valsets[i] = $root.gravity.v1.Valset.fromObject(object.valsets[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryLastValsetRequestsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryLastValsetRequestsResponse
             * @static
             * @param {gravity.v1.QueryLastValsetRequestsResponse} message QueryLastValsetRequestsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryLastValsetRequestsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.valsets = [];
                if (message.valsets && message.valsets.length) {
                    object.valsets = [];
                    for (let j = 0; j < message.valsets.length; ++j)
                        object.valsets[j] = $root.gravity.v1.Valset.toObject(message.valsets[j], options);
                }
                return object;
            };

            /**
             * Converts this QueryLastValsetRequestsResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryLastValsetRequestsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryLastValsetRequestsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryLastValsetRequestsResponse;
        })();

        v1.QueryLastPendingValsetRequestByAddrRequest = (function() {

            /**
             * Properties of a QueryLastPendingValsetRequestByAddrRequest.
             * @memberof gravity.v1
             * @interface IQueryLastPendingValsetRequestByAddrRequest
             * @property {string|null} [address] QueryLastPendingValsetRequestByAddrRequest address
             */

            /**
             * Constructs a new QueryLastPendingValsetRequestByAddrRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryLastPendingValsetRequestByAddrRequest.
             * @implements IQueryLastPendingValsetRequestByAddrRequest
             * @constructor
             * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrRequest=} [properties] Properties to set
             */
            function QueryLastPendingValsetRequestByAddrRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryLastPendingValsetRequestByAddrRequest address.
             * @member {string} address
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
             * @instance
             */
            QueryLastPendingValsetRequestByAddrRequest.prototype.address = "";

            /**
             * Encodes the specified QueryLastPendingValsetRequestByAddrRequest message. Does not implicitly {@link gravity.v1.QueryLastPendingValsetRequestByAddrRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
             * @static
             * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrRequest} message QueryLastPendingValsetRequestByAddrRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastPendingValsetRequestByAddrRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                return writer;
            };

            /**
             * Encodes the specified QueryLastPendingValsetRequestByAddrRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryLastPendingValsetRequestByAddrRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
             * @static
             * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrRequest} message QueryLastPendingValsetRequestByAddrRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastPendingValsetRequestByAddrRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryLastPendingValsetRequestByAddrRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryLastPendingValsetRequestByAddrRequest} QueryLastPendingValsetRequestByAddrRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastPendingValsetRequestByAddrRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastPendingValsetRequestByAddrRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryLastPendingValsetRequestByAddrRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryLastPendingValsetRequestByAddrRequest} QueryLastPendingValsetRequestByAddrRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastPendingValsetRequestByAddrRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryLastPendingValsetRequestByAddrRequest message.
             * @function verify
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryLastPendingValsetRequestByAddrRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                return null;
            };

            /**
             * Creates a QueryLastPendingValsetRequestByAddrRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryLastPendingValsetRequestByAddrRequest} QueryLastPendingValsetRequestByAddrRequest
             */
            QueryLastPendingValsetRequestByAddrRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryLastPendingValsetRequestByAddrRequest)
                    return object;
                let message = new $root.gravity.v1.QueryLastPendingValsetRequestByAddrRequest();
                if (object.address != null)
                    message.address = String(object.address);
                return message;
            };

            /**
             * Creates a plain object from a QueryLastPendingValsetRequestByAddrRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
             * @static
             * @param {gravity.v1.QueryLastPendingValsetRequestByAddrRequest} message QueryLastPendingValsetRequestByAddrRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryLastPendingValsetRequestByAddrRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.address = "";
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                return object;
            };

            /**
             * Converts this QueryLastPendingValsetRequestByAddrRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryLastPendingValsetRequestByAddrRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryLastPendingValsetRequestByAddrRequest;
        })();

        v1.QueryLastPendingValsetRequestByAddrResponse = (function() {

            /**
             * Properties of a QueryLastPendingValsetRequestByAddrResponse.
             * @memberof gravity.v1
             * @interface IQueryLastPendingValsetRequestByAddrResponse
             * @property {Array.<gravity.v1.IValset>|null} [valsets] QueryLastPendingValsetRequestByAddrResponse valsets
             */

            /**
             * Constructs a new QueryLastPendingValsetRequestByAddrResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryLastPendingValsetRequestByAddrResponse.
             * @implements IQueryLastPendingValsetRequestByAddrResponse
             * @constructor
             * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrResponse=} [properties] Properties to set
             */
            function QueryLastPendingValsetRequestByAddrResponse(properties) {
                this.valsets = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryLastPendingValsetRequestByAddrResponse valsets.
             * @member {Array.<gravity.v1.IValset>} valsets
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
             * @instance
             */
            QueryLastPendingValsetRequestByAddrResponse.prototype.valsets = $util.emptyArray;

            /**
             * Encodes the specified QueryLastPendingValsetRequestByAddrResponse message. Does not implicitly {@link gravity.v1.QueryLastPendingValsetRequestByAddrResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
             * @static
             * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrResponse} message QueryLastPendingValsetRequestByAddrResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastPendingValsetRequestByAddrResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.valsets != null && message.valsets.length)
                    for (let i = 0; i < message.valsets.length; ++i)
                        $root.gravity.v1.Valset.encode(message.valsets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryLastPendingValsetRequestByAddrResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryLastPendingValsetRequestByAddrResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
             * @static
             * @param {gravity.v1.IQueryLastPendingValsetRequestByAddrResponse} message QueryLastPendingValsetRequestByAddrResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastPendingValsetRequestByAddrResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryLastPendingValsetRequestByAddrResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryLastPendingValsetRequestByAddrResponse} QueryLastPendingValsetRequestByAddrResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastPendingValsetRequestByAddrResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastPendingValsetRequestByAddrResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.valsets && message.valsets.length))
                            message.valsets = [];
                        message.valsets.push($root.gravity.v1.Valset.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryLastPendingValsetRequestByAddrResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryLastPendingValsetRequestByAddrResponse} QueryLastPendingValsetRequestByAddrResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastPendingValsetRequestByAddrResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryLastPendingValsetRequestByAddrResponse message.
             * @function verify
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryLastPendingValsetRequestByAddrResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.valsets != null && message.hasOwnProperty("valsets")) {
                    if (!Array.isArray(message.valsets))
                        return "valsets: array expected";
                    for (let i = 0; i < message.valsets.length; ++i) {
                        let error = $root.gravity.v1.Valset.verify(message.valsets[i]);
                        if (error)
                            return "valsets." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryLastPendingValsetRequestByAddrResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryLastPendingValsetRequestByAddrResponse} QueryLastPendingValsetRequestByAddrResponse
             */
            QueryLastPendingValsetRequestByAddrResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryLastPendingValsetRequestByAddrResponse)
                    return object;
                let message = new $root.gravity.v1.QueryLastPendingValsetRequestByAddrResponse();
                if (object.valsets) {
                    if (!Array.isArray(object.valsets))
                        throw TypeError(".gravity.v1.QueryLastPendingValsetRequestByAddrResponse.valsets: array expected");
                    message.valsets = [];
                    for (let i = 0; i < object.valsets.length; ++i) {
                        if (typeof object.valsets[i] !== "object")
                            throw TypeError(".gravity.v1.QueryLastPendingValsetRequestByAddrResponse.valsets: object expected");
                        message.valsets[i] = $root.gravity.v1.Valset.fromObject(object.valsets[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryLastPendingValsetRequestByAddrResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
             * @static
             * @param {gravity.v1.QueryLastPendingValsetRequestByAddrResponse} message QueryLastPendingValsetRequestByAddrResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryLastPendingValsetRequestByAddrResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.valsets = [];
                if (message.valsets && message.valsets.length) {
                    object.valsets = [];
                    for (let j = 0; j < message.valsets.length; ++j)
                        object.valsets[j] = $root.gravity.v1.Valset.toObject(message.valsets[j], options);
                }
                return object;
            };

            /**
             * Converts this QueryLastPendingValsetRequestByAddrResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryLastPendingValsetRequestByAddrResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryLastPendingValsetRequestByAddrResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryLastPendingValsetRequestByAddrResponse;
        })();

        v1.QueryBatchFeeRequest = (function() {

            /**
             * Properties of a QueryBatchFeeRequest.
             * @memberof gravity.v1
             * @interface IQueryBatchFeeRequest
             */

            /**
             * Constructs a new QueryBatchFeeRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryBatchFeeRequest.
             * @implements IQueryBatchFeeRequest
             * @constructor
             * @param {gravity.v1.IQueryBatchFeeRequest=} [properties] Properties to set
             */
            function QueryBatchFeeRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified QueryBatchFeeRequest message. Does not implicitly {@link gravity.v1.QueryBatchFeeRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryBatchFeeRequest
             * @static
             * @param {gravity.v1.IQueryBatchFeeRequest} message QueryBatchFeeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryBatchFeeRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified QueryBatchFeeRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryBatchFeeRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryBatchFeeRequest
             * @static
             * @param {gravity.v1.IQueryBatchFeeRequest} message QueryBatchFeeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryBatchFeeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryBatchFeeRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryBatchFeeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryBatchFeeRequest} QueryBatchFeeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryBatchFeeRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryBatchFeeRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryBatchFeeRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryBatchFeeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryBatchFeeRequest} QueryBatchFeeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryBatchFeeRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryBatchFeeRequest message.
             * @function verify
             * @memberof gravity.v1.QueryBatchFeeRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryBatchFeeRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a QueryBatchFeeRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryBatchFeeRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryBatchFeeRequest} QueryBatchFeeRequest
             */
            QueryBatchFeeRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryBatchFeeRequest)
                    return object;
                return new $root.gravity.v1.QueryBatchFeeRequest();
            };

            /**
             * Creates a plain object from a QueryBatchFeeRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryBatchFeeRequest
             * @static
             * @param {gravity.v1.QueryBatchFeeRequest} message QueryBatchFeeRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryBatchFeeRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this QueryBatchFeeRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryBatchFeeRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryBatchFeeRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryBatchFeeRequest;
        })();

        v1.QueryBatchFeeResponse = (function() {

            /**
             * Properties of a QueryBatchFeeResponse.
             * @memberof gravity.v1
             * @interface IQueryBatchFeeResponse
             * @property {Array.<gravity.v1.IBatchFees>|null} [batch_fees] QueryBatchFeeResponse batch_fees
             */

            /**
             * Constructs a new QueryBatchFeeResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryBatchFeeResponse.
             * @implements IQueryBatchFeeResponse
             * @constructor
             * @param {gravity.v1.IQueryBatchFeeResponse=} [properties] Properties to set
             */
            function QueryBatchFeeResponse(properties) {
                this.batch_fees = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryBatchFeeResponse batch_fees.
             * @member {Array.<gravity.v1.IBatchFees>} batch_fees
             * @memberof gravity.v1.QueryBatchFeeResponse
             * @instance
             */
            QueryBatchFeeResponse.prototype.batch_fees = $util.emptyArray;

            /**
             * Encodes the specified QueryBatchFeeResponse message. Does not implicitly {@link gravity.v1.QueryBatchFeeResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryBatchFeeResponse
             * @static
             * @param {gravity.v1.IQueryBatchFeeResponse} message QueryBatchFeeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryBatchFeeResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.batch_fees != null && message.batch_fees.length)
                    for (let i = 0; i < message.batch_fees.length; ++i)
                        $root.gravity.v1.BatchFees.encode(message.batch_fees[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryBatchFeeResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryBatchFeeResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryBatchFeeResponse
             * @static
             * @param {gravity.v1.IQueryBatchFeeResponse} message QueryBatchFeeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryBatchFeeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryBatchFeeResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryBatchFeeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryBatchFeeResponse} QueryBatchFeeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryBatchFeeResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryBatchFeeResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.batch_fees && message.batch_fees.length))
                            message.batch_fees = [];
                        message.batch_fees.push($root.gravity.v1.BatchFees.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryBatchFeeResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryBatchFeeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryBatchFeeResponse} QueryBatchFeeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryBatchFeeResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryBatchFeeResponse message.
             * @function verify
             * @memberof gravity.v1.QueryBatchFeeResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryBatchFeeResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.batch_fees != null && message.hasOwnProperty("batch_fees")) {
                    if (!Array.isArray(message.batch_fees))
                        return "batch_fees: array expected";
                    for (let i = 0; i < message.batch_fees.length; ++i) {
                        let error = $root.gravity.v1.BatchFees.verify(message.batch_fees[i]);
                        if (error)
                            return "batch_fees." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryBatchFeeResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryBatchFeeResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryBatchFeeResponse} QueryBatchFeeResponse
             */
            QueryBatchFeeResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryBatchFeeResponse)
                    return object;
                let message = new $root.gravity.v1.QueryBatchFeeResponse();
                if (object.batch_fees) {
                    if (!Array.isArray(object.batch_fees))
                        throw TypeError(".gravity.v1.QueryBatchFeeResponse.batch_fees: array expected");
                    message.batch_fees = [];
                    for (let i = 0; i < object.batch_fees.length; ++i) {
                        if (typeof object.batch_fees[i] !== "object")
                            throw TypeError(".gravity.v1.QueryBatchFeeResponse.batch_fees: object expected");
                        message.batch_fees[i] = $root.gravity.v1.BatchFees.fromObject(object.batch_fees[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryBatchFeeResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryBatchFeeResponse
             * @static
             * @param {gravity.v1.QueryBatchFeeResponse} message QueryBatchFeeResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryBatchFeeResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.batch_fees = [];
                if (message.batch_fees && message.batch_fees.length) {
                    object.batch_fees = [];
                    for (let j = 0; j < message.batch_fees.length; ++j)
                        object.batch_fees[j] = $root.gravity.v1.BatchFees.toObject(message.batch_fees[j], options);
                }
                return object;
            };

            /**
             * Converts this QueryBatchFeeResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryBatchFeeResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryBatchFeeResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryBatchFeeResponse;
        })();

        v1.QueryLastPendingBatchRequestByAddrRequest = (function() {

            /**
             * Properties of a QueryLastPendingBatchRequestByAddrRequest.
             * @memberof gravity.v1
             * @interface IQueryLastPendingBatchRequestByAddrRequest
             * @property {string|null} [address] QueryLastPendingBatchRequestByAddrRequest address
             */

            /**
             * Constructs a new QueryLastPendingBatchRequestByAddrRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryLastPendingBatchRequestByAddrRequest.
             * @implements IQueryLastPendingBatchRequestByAddrRequest
             * @constructor
             * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrRequest=} [properties] Properties to set
             */
            function QueryLastPendingBatchRequestByAddrRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryLastPendingBatchRequestByAddrRequest address.
             * @member {string} address
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
             * @instance
             */
            QueryLastPendingBatchRequestByAddrRequest.prototype.address = "";

            /**
             * Encodes the specified QueryLastPendingBatchRequestByAddrRequest message. Does not implicitly {@link gravity.v1.QueryLastPendingBatchRequestByAddrRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
             * @static
             * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrRequest} message QueryLastPendingBatchRequestByAddrRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastPendingBatchRequestByAddrRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                return writer;
            };

            /**
             * Encodes the specified QueryLastPendingBatchRequestByAddrRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryLastPendingBatchRequestByAddrRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
             * @static
             * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrRequest} message QueryLastPendingBatchRequestByAddrRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastPendingBatchRequestByAddrRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryLastPendingBatchRequestByAddrRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryLastPendingBatchRequestByAddrRequest} QueryLastPendingBatchRequestByAddrRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastPendingBatchRequestByAddrRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastPendingBatchRequestByAddrRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryLastPendingBatchRequestByAddrRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryLastPendingBatchRequestByAddrRequest} QueryLastPendingBatchRequestByAddrRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastPendingBatchRequestByAddrRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryLastPendingBatchRequestByAddrRequest message.
             * @function verify
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryLastPendingBatchRequestByAddrRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                return null;
            };

            /**
             * Creates a QueryLastPendingBatchRequestByAddrRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryLastPendingBatchRequestByAddrRequest} QueryLastPendingBatchRequestByAddrRequest
             */
            QueryLastPendingBatchRequestByAddrRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryLastPendingBatchRequestByAddrRequest)
                    return object;
                let message = new $root.gravity.v1.QueryLastPendingBatchRequestByAddrRequest();
                if (object.address != null)
                    message.address = String(object.address);
                return message;
            };

            /**
             * Creates a plain object from a QueryLastPendingBatchRequestByAddrRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
             * @static
             * @param {gravity.v1.QueryLastPendingBatchRequestByAddrRequest} message QueryLastPendingBatchRequestByAddrRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryLastPendingBatchRequestByAddrRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.address = "";
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                return object;
            };

            /**
             * Converts this QueryLastPendingBatchRequestByAddrRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryLastPendingBatchRequestByAddrRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryLastPendingBatchRequestByAddrRequest;
        })();

        v1.QueryLastPendingBatchRequestByAddrResponse = (function() {

            /**
             * Properties of a QueryLastPendingBatchRequestByAddrResponse.
             * @memberof gravity.v1
             * @interface IQueryLastPendingBatchRequestByAddrResponse
             * @property {Array.<gravity.v1.IOutgoingTxBatch>|null} [batch] QueryLastPendingBatchRequestByAddrResponse batch
             */

            /**
             * Constructs a new QueryLastPendingBatchRequestByAddrResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryLastPendingBatchRequestByAddrResponse.
             * @implements IQueryLastPendingBatchRequestByAddrResponse
             * @constructor
             * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrResponse=} [properties] Properties to set
             */
            function QueryLastPendingBatchRequestByAddrResponse(properties) {
                this.batch = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryLastPendingBatchRequestByAddrResponse batch.
             * @member {Array.<gravity.v1.IOutgoingTxBatch>} batch
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
             * @instance
             */
            QueryLastPendingBatchRequestByAddrResponse.prototype.batch = $util.emptyArray;

            /**
             * Encodes the specified QueryLastPendingBatchRequestByAddrResponse message. Does not implicitly {@link gravity.v1.QueryLastPendingBatchRequestByAddrResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
             * @static
             * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrResponse} message QueryLastPendingBatchRequestByAddrResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastPendingBatchRequestByAddrResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.batch != null && message.batch.length)
                    for (let i = 0; i < message.batch.length; ++i)
                        $root.gravity.v1.OutgoingTxBatch.encode(message.batch[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryLastPendingBatchRequestByAddrResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryLastPendingBatchRequestByAddrResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
             * @static
             * @param {gravity.v1.IQueryLastPendingBatchRequestByAddrResponse} message QueryLastPendingBatchRequestByAddrResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastPendingBatchRequestByAddrResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryLastPendingBatchRequestByAddrResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryLastPendingBatchRequestByAddrResponse} QueryLastPendingBatchRequestByAddrResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastPendingBatchRequestByAddrResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastPendingBatchRequestByAddrResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.batch && message.batch.length))
                            message.batch = [];
                        message.batch.push($root.gravity.v1.OutgoingTxBatch.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryLastPendingBatchRequestByAddrResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryLastPendingBatchRequestByAddrResponse} QueryLastPendingBatchRequestByAddrResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastPendingBatchRequestByAddrResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryLastPendingBatchRequestByAddrResponse message.
             * @function verify
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryLastPendingBatchRequestByAddrResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.batch != null && message.hasOwnProperty("batch")) {
                    if (!Array.isArray(message.batch))
                        return "batch: array expected";
                    for (let i = 0; i < message.batch.length; ++i) {
                        let error = $root.gravity.v1.OutgoingTxBatch.verify(message.batch[i]);
                        if (error)
                            return "batch." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryLastPendingBatchRequestByAddrResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryLastPendingBatchRequestByAddrResponse} QueryLastPendingBatchRequestByAddrResponse
             */
            QueryLastPendingBatchRequestByAddrResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryLastPendingBatchRequestByAddrResponse)
                    return object;
                let message = new $root.gravity.v1.QueryLastPendingBatchRequestByAddrResponse();
                if (object.batch) {
                    if (!Array.isArray(object.batch))
                        throw TypeError(".gravity.v1.QueryLastPendingBatchRequestByAddrResponse.batch: array expected");
                    message.batch = [];
                    for (let i = 0; i < object.batch.length; ++i) {
                        if (typeof object.batch[i] !== "object")
                            throw TypeError(".gravity.v1.QueryLastPendingBatchRequestByAddrResponse.batch: object expected");
                        message.batch[i] = $root.gravity.v1.OutgoingTxBatch.fromObject(object.batch[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryLastPendingBatchRequestByAddrResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
             * @static
             * @param {gravity.v1.QueryLastPendingBatchRequestByAddrResponse} message QueryLastPendingBatchRequestByAddrResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryLastPendingBatchRequestByAddrResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.batch = [];
                if (message.batch && message.batch.length) {
                    object.batch = [];
                    for (let j = 0; j < message.batch.length; ++j)
                        object.batch[j] = $root.gravity.v1.OutgoingTxBatch.toObject(message.batch[j], options);
                }
                return object;
            };

            /**
             * Converts this QueryLastPendingBatchRequestByAddrResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryLastPendingBatchRequestByAddrResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryLastPendingBatchRequestByAddrResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryLastPendingBatchRequestByAddrResponse;
        })();

        v1.QueryLastPendingLogicCallByAddrRequest = (function() {

            /**
             * Properties of a QueryLastPendingLogicCallByAddrRequest.
             * @memberof gravity.v1
             * @interface IQueryLastPendingLogicCallByAddrRequest
             * @property {string|null} [address] QueryLastPendingLogicCallByAddrRequest address
             */

            /**
             * Constructs a new QueryLastPendingLogicCallByAddrRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryLastPendingLogicCallByAddrRequest.
             * @implements IQueryLastPendingLogicCallByAddrRequest
             * @constructor
             * @param {gravity.v1.IQueryLastPendingLogicCallByAddrRequest=} [properties] Properties to set
             */
            function QueryLastPendingLogicCallByAddrRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryLastPendingLogicCallByAddrRequest address.
             * @member {string} address
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
             * @instance
             */
            QueryLastPendingLogicCallByAddrRequest.prototype.address = "";

            /**
             * Encodes the specified QueryLastPendingLogicCallByAddrRequest message. Does not implicitly {@link gravity.v1.QueryLastPendingLogicCallByAddrRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
             * @static
             * @param {gravity.v1.IQueryLastPendingLogicCallByAddrRequest} message QueryLastPendingLogicCallByAddrRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastPendingLogicCallByAddrRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                return writer;
            };

            /**
             * Encodes the specified QueryLastPendingLogicCallByAddrRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryLastPendingLogicCallByAddrRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
             * @static
             * @param {gravity.v1.IQueryLastPendingLogicCallByAddrRequest} message QueryLastPendingLogicCallByAddrRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastPendingLogicCallByAddrRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryLastPendingLogicCallByAddrRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryLastPendingLogicCallByAddrRequest} QueryLastPendingLogicCallByAddrRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastPendingLogicCallByAddrRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastPendingLogicCallByAddrRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryLastPendingLogicCallByAddrRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryLastPendingLogicCallByAddrRequest} QueryLastPendingLogicCallByAddrRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastPendingLogicCallByAddrRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryLastPendingLogicCallByAddrRequest message.
             * @function verify
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryLastPendingLogicCallByAddrRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                return null;
            };

            /**
             * Creates a QueryLastPendingLogicCallByAddrRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryLastPendingLogicCallByAddrRequest} QueryLastPendingLogicCallByAddrRequest
             */
            QueryLastPendingLogicCallByAddrRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryLastPendingLogicCallByAddrRequest)
                    return object;
                let message = new $root.gravity.v1.QueryLastPendingLogicCallByAddrRequest();
                if (object.address != null)
                    message.address = String(object.address);
                return message;
            };

            /**
             * Creates a plain object from a QueryLastPendingLogicCallByAddrRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
             * @static
             * @param {gravity.v1.QueryLastPendingLogicCallByAddrRequest} message QueryLastPendingLogicCallByAddrRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryLastPendingLogicCallByAddrRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.address = "";
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                return object;
            };

            /**
             * Converts this QueryLastPendingLogicCallByAddrRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryLastPendingLogicCallByAddrRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryLastPendingLogicCallByAddrRequest;
        })();

        v1.QueryLastPendingLogicCallByAddrResponse = (function() {

            /**
             * Properties of a QueryLastPendingLogicCallByAddrResponse.
             * @memberof gravity.v1
             * @interface IQueryLastPendingLogicCallByAddrResponse
             * @property {Array.<gravity.v1.IOutgoingLogicCall>|null} [call] QueryLastPendingLogicCallByAddrResponse call
             */

            /**
             * Constructs a new QueryLastPendingLogicCallByAddrResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryLastPendingLogicCallByAddrResponse.
             * @implements IQueryLastPendingLogicCallByAddrResponse
             * @constructor
             * @param {gravity.v1.IQueryLastPendingLogicCallByAddrResponse=} [properties] Properties to set
             */
            function QueryLastPendingLogicCallByAddrResponse(properties) {
                this.call = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryLastPendingLogicCallByAddrResponse call.
             * @member {Array.<gravity.v1.IOutgoingLogicCall>} call
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
             * @instance
             */
            QueryLastPendingLogicCallByAddrResponse.prototype.call = $util.emptyArray;

            /**
             * Encodes the specified QueryLastPendingLogicCallByAddrResponse message. Does not implicitly {@link gravity.v1.QueryLastPendingLogicCallByAddrResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
             * @static
             * @param {gravity.v1.IQueryLastPendingLogicCallByAddrResponse} message QueryLastPendingLogicCallByAddrResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastPendingLogicCallByAddrResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.call != null && message.call.length)
                    for (let i = 0; i < message.call.length; ++i)
                        $root.gravity.v1.OutgoingLogicCall.encode(message.call[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryLastPendingLogicCallByAddrResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryLastPendingLogicCallByAddrResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
             * @static
             * @param {gravity.v1.IQueryLastPendingLogicCallByAddrResponse} message QueryLastPendingLogicCallByAddrResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastPendingLogicCallByAddrResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryLastPendingLogicCallByAddrResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryLastPendingLogicCallByAddrResponse} QueryLastPendingLogicCallByAddrResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastPendingLogicCallByAddrResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastPendingLogicCallByAddrResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.call && message.call.length))
                            message.call = [];
                        message.call.push($root.gravity.v1.OutgoingLogicCall.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryLastPendingLogicCallByAddrResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryLastPendingLogicCallByAddrResponse} QueryLastPendingLogicCallByAddrResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastPendingLogicCallByAddrResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryLastPendingLogicCallByAddrResponse message.
             * @function verify
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryLastPendingLogicCallByAddrResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.call != null && message.hasOwnProperty("call")) {
                    if (!Array.isArray(message.call))
                        return "call: array expected";
                    for (let i = 0; i < message.call.length; ++i) {
                        let error = $root.gravity.v1.OutgoingLogicCall.verify(message.call[i]);
                        if (error)
                            return "call." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryLastPendingLogicCallByAddrResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryLastPendingLogicCallByAddrResponse} QueryLastPendingLogicCallByAddrResponse
             */
            QueryLastPendingLogicCallByAddrResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryLastPendingLogicCallByAddrResponse)
                    return object;
                let message = new $root.gravity.v1.QueryLastPendingLogicCallByAddrResponse();
                if (object.call) {
                    if (!Array.isArray(object.call))
                        throw TypeError(".gravity.v1.QueryLastPendingLogicCallByAddrResponse.call: array expected");
                    message.call = [];
                    for (let i = 0; i < object.call.length; ++i) {
                        if (typeof object.call[i] !== "object")
                            throw TypeError(".gravity.v1.QueryLastPendingLogicCallByAddrResponse.call: object expected");
                        message.call[i] = $root.gravity.v1.OutgoingLogicCall.fromObject(object.call[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryLastPendingLogicCallByAddrResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
             * @static
             * @param {gravity.v1.QueryLastPendingLogicCallByAddrResponse} message QueryLastPendingLogicCallByAddrResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryLastPendingLogicCallByAddrResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.call = [];
                if (message.call && message.call.length) {
                    object.call = [];
                    for (let j = 0; j < message.call.length; ++j)
                        object.call[j] = $root.gravity.v1.OutgoingLogicCall.toObject(message.call[j], options);
                }
                return object;
            };

            /**
             * Converts this QueryLastPendingLogicCallByAddrResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryLastPendingLogicCallByAddrResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryLastPendingLogicCallByAddrResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryLastPendingLogicCallByAddrResponse;
        })();

        v1.QueryOutgoingTxBatchesRequest = (function() {

            /**
             * Properties of a QueryOutgoingTxBatchesRequest.
             * @memberof gravity.v1
             * @interface IQueryOutgoingTxBatchesRequest
             */

            /**
             * Constructs a new QueryOutgoingTxBatchesRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryOutgoingTxBatchesRequest.
             * @implements IQueryOutgoingTxBatchesRequest
             * @constructor
             * @param {gravity.v1.IQueryOutgoingTxBatchesRequest=} [properties] Properties to set
             */
            function QueryOutgoingTxBatchesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified QueryOutgoingTxBatchesRequest message. Does not implicitly {@link gravity.v1.QueryOutgoingTxBatchesRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
             * @static
             * @param {gravity.v1.IQueryOutgoingTxBatchesRequest} message QueryOutgoingTxBatchesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryOutgoingTxBatchesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified QueryOutgoingTxBatchesRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryOutgoingTxBatchesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
             * @static
             * @param {gravity.v1.IQueryOutgoingTxBatchesRequest} message QueryOutgoingTxBatchesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryOutgoingTxBatchesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryOutgoingTxBatchesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryOutgoingTxBatchesRequest} QueryOutgoingTxBatchesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryOutgoingTxBatchesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryOutgoingTxBatchesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryOutgoingTxBatchesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryOutgoingTxBatchesRequest} QueryOutgoingTxBatchesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryOutgoingTxBatchesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryOutgoingTxBatchesRequest message.
             * @function verify
             * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryOutgoingTxBatchesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a QueryOutgoingTxBatchesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryOutgoingTxBatchesRequest} QueryOutgoingTxBatchesRequest
             */
            QueryOutgoingTxBatchesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryOutgoingTxBatchesRequest)
                    return object;
                return new $root.gravity.v1.QueryOutgoingTxBatchesRequest();
            };

            /**
             * Creates a plain object from a QueryOutgoingTxBatchesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
             * @static
             * @param {gravity.v1.QueryOutgoingTxBatchesRequest} message QueryOutgoingTxBatchesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryOutgoingTxBatchesRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this QueryOutgoingTxBatchesRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryOutgoingTxBatchesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryOutgoingTxBatchesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryOutgoingTxBatchesRequest;
        })();

        v1.QueryOutgoingTxBatchesResponse = (function() {

            /**
             * Properties of a QueryOutgoingTxBatchesResponse.
             * @memberof gravity.v1
             * @interface IQueryOutgoingTxBatchesResponse
             * @property {Array.<gravity.v1.IOutgoingTxBatch>|null} [batches] QueryOutgoingTxBatchesResponse batches
             */

            /**
             * Constructs a new QueryOutgoingTxBatchesResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryOutgoingTxBatchesResponse.
             * @implements IQueryOutgoingTxBatchesResponse
             * @constructor
             * @param {gravity.v1.IQueryOutgoingTxBatchesResponse=} [properties] Properties to set
             */
            function QueryOutgoingTxBatchesResponse(properties) {
                this.batches = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryOutgoingTxBatchesResponse batches.
             * @member {Array.<gravity.v1.IOutgoingTxBatch>} batches
             * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
             * @instance
             */
            QueryOutgoingTxBatchesResponse.prototype.batches = $util.emptyArray;

            /**
             * Encodes the specified QueryOutgoingTxBatchesResponse message. Does not implicitly {@link gravity.v1.QueryOutgoingTxBatchesResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
             * @static
             * @param {gravity.v1.IQueryOutgoingTxBatchesResponse} message QueryOutgoingTxBatchesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryOutgoingTxBatchesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.batches != null && message.batches.length)
                    for (let i = 0; i < message.batches.length; ++i)
                        $root.gravity.v1.OutgoingTxBatch.encode(message.batches[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryOutgoingTxBatchesResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryOutgoingTxBatchesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
             * @static
             * @param {gravity.v1.IQueryOutgoingTxBatchesResponse} message QueryOutgoingTxBatchesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryOutgoingTxBatchesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryOutgoingTxBatchesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryOutgoingTxBatchesResponse} QueryOutgoingTxBatchesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryOutgoingTxBatchesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryOutgoingTxBatchesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.batches && message.batches.length))
                            message.batches = [];
                        message.batches.push($root.gravity.v1.OutgoingTxBatch.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryOutgoingTxBatchesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryOutgoingTxBatchesResponse} QueryOutgoingTxBatchesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryOutgoingTxBatchesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryOutgoingTxBatchesResponse message.
             * @function verify
             * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryOutgoingTxBatchesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.batches != null && message.hasOwnProperty("batches")) {
                    if (!Array.isArray(message.batches))
                        return "batches: array expected";
                    for (let i = 0; i < message.batches.length; ++i) {
                        let error = $root.gravity.v1.OutgoingTxBatch.verify(message.batches[i]);
                        if (error)
                            return "batches." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryOutgoingTxBatchesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryOutgoingTxBatchesResponse} QueryOutgoingTxBatchesResponse
             */
            QueryOutgoingTxBatchesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryOutgoingTxBatchesResponse)
                    return object;
                let message = new $root.gravity.v1.QueryOutgoingTxBatchesResponse();
                if (object.batches) {
                    if (!Array.isArray(object.batches))
                        throw TypeError(".gravity.v1.QueryOutgoingTxBatchesResponse.batches: array expected");
                    message.batches = [];
                    for (let i = 0; i < object.batches.length; ++i) {
                        if (typeof object.batches[i] !== "object")
                            throw TypeError(".gravity.v1.QueryOutgoingTxBatchesResponse.batches: object expected");
                        message.batches[i] = $root.gravity.v1.OutgoingTxBatch.fromObject(object.batches[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryOutgoingTxBatchesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
             * @static
             * @param {gravity.v1.QueryOutgoingTxBatchesResponse} message QueryOutgoingTxBatchesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryOutgoingTxBatchesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.batches = [];
                if (message.batches && message.batches.length) {
                    object.batches = [];
                    for (let j = 0; j < message.batches.length; ++j)
                        object.batches[j] = $root.gravity.v1.OutgoingTxBatch.toObject(message.batches[j], options);
                }
                return object;
            };

            /**
             * Converts this QueryOutgoingTxBatchesResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryOutgoingTxBatchesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryOutgoingTxBatchesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryOutgoingTxBatchesResponse;
        })();

        v1.QueryOutgoingLogicCallsRequest = (function() {

            /**
             * Properties of a QueryOutgoingLogicCallsRequest.
             * @memberof gravity.v1
             * @interface IQueryOutgoingLogicCallsRequest
             */

            /**
             * Constructs a new QueryOutgoingLogicCallsRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryOutgoingLogicCallsRequest.
             * @implements IQueryOutgoingLogicCallsRequest
             * @constructor
             * @param {gravity.v1.IQueryOutgoingLogicCallsRequest=} [properties] Properties to set
             */
            function QueryOutgoingLogicCallsRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified QueryOutgoingLogicCallsRequest message. Does not implicitly {@link gravity.v1.QueryOutgoingLogicCallsRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
             * @static
             * @param {gravity.v1.IQueryOutgoingLogicCallsRequest} message QueryOutgoingLogicCallsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryOutgoingLogicCallsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified QueryOutgoingLogicCallsRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryOutgoingLogicCallsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
             * @static
             * @param {gravity.v1.IQueryOutgoingLogicCallsRequest} message QueryOutgoingLogicCallsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryOutgoingLogicCallsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryOutgoingLogicCallsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryOutgoingLogicCallsRequest} QueryOutgoingLogicCallsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryOutgoingLogicCallsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryOutgoingLogicCallsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryOutgoingLogicCallsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryOutgoingLogicCallsRequest} QueryOutgoingLogicCallsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryOutgoingLogicCallsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryOutgoingLogicCallsRequest message.
             * @function verify
             * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryOutgoingLogicCallsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a QueryOutgoingLogicCallsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryOutgoingLogicCallsRequest} QueryOutgoingLogicCallsRequest
             */
            QueryOutgoingLogicCallsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryOutgoingLogicCallsRequest)
                    return object;
                return new $root.gravity.v1.QueryOutgoingLogicCallsRequest();
            };

            /**
             * Creates a plain object from a QueryOutgoingLogicCallsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
             * @static
             * @param {gravity.v1.QueryOutgoingLogicCallsRequest} message QueryOutgoingLogicCallsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryOutgoingLogicCallsRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this QueryOutgoingLogicCallsRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryOutgoingLogicCallsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryOutgoingLogicCallsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryOutgoingLogicCallsRequest;
        })();

        v1.QueryOutgoingLogicCallsResponse = (function() {

            /**
             * Properties of a QueryOutgoingLogicCallsResponse.
             * @memberof gravity.v1
             * @interface IQueryOutgoingLogicCallsResponse
             * @property {Array.<gravity.v1.IOutgoingLogicCall>|null} [calls] QueryOutgoingLogicCallsResponse calls
             */

            /**
             * Constructs a new QueryOutgoingLogicCallsResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryOutgoingLogicCallsResponse.
             * @implements IQueryOutgoingLogicCallsResponse
             * @constructor
             * @param {gravity.v1.IQueryOutgoingLogicCallsResponse=} [properties] Properties to set
             */
            function QueryOutgoingLogicCallsResponse(properties) {
                this.calls = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryOutgoingLogicCallsResponse calls.
             * @member {Array.<gravity.v1.IOutgoingLogicCall>} calls
             * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
             * @instance
             */
            QueryOutgoingLogicCallsResponse.prototype.calls = $util.emptyArray;

            /**
             * Encodes the specified QueryOutgoingLogicCallsResponse message. Does not implicitly {@link gravity.v1.QueryOutgoingLogicCallsResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
             * @static
             * @param {gravity.v1.IQueryOutgoingLogicCallsResponse} message QueryOutgoingLogicCallsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryOutgoingLogicCallsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.calls != null && message.calls.length)
                    for (let i = 0; i < message.calls.length; ++i)
                        $root.gravity.v1.OutgoingLogicCall.encode(message.calls[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryOutgoingLogicCallsResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryOutgoingLogicCallsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
             * @static
             * @param {gravity.v1.IQueryOutgoingLogicCallsResponse} message QueryOutgoingLogicCallsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryOutgoingLogicCallsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryOutgoingLogicCallsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryOutgoingLogicCallsResponse} QueryOutgoingLogicCallsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryOutgoingLogicCallsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryOutgoingLogicCallsResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.calls && message.calls.length))
                            message.calls = [];
                        message.calls.push($root.gravity.v1.OutgoingLogicCall.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryOutgoingLogicCallsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryOutgoingLogicCallsResponse} QueryOutgoingLogicCallsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryOutgoingLogicCallsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryOutgoingLogicCallsResponse message.
             * @function verify
             * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryOutgoingLogicCallsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.calls != null && message.hasOwnProperty("calls")) {
                    if (!Array.isArray(message.calls))
                        return "calls: array expected";
                    for (let i = 0; i < message.calls.length; ++i) {
                        let error = $root.gravity.v1.OutgoingLogicCall.verify(message.calls[i]);
                        if (error)
                            return "calls." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryOutgoingLogicCallsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryOutgoingLogicCallsResponse} QueryOutgoingLogicCallsResponse
             */
            QueryOutgoingLogicCallsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryOutgoingLogicCallsResponse)
                    return object;
                let message = new $root.gravity.v1.QueryOutgoingLogicCallsResponse();
                if (object.calls) {
                    if (!Array.isArray(object.calls))
                        throw TypeError(".gravity.v1.QueryOutgoingLogicCallsResponse.calls: array expected");
                    message.calls = [];
                    for (let i = 0; i < object.calls.length; ++i) {
                        if (typeof object.calls[i] !== "object")
                            throw TypeError(".gravity.v1.QueryOutgoingLogicCallsResponse.calls: object expected");
                        message.calls[i] = $root.gravity.v1.OutgoingLogicCall.fromObject(object.calls[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryOutgoingLogicCallsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
             * @static
             * @param {gravity.v1.QueryOutgoingLogicCallsResponse} message QueryOutgoingLogicCallsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryOutgoingLogicCallsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.calls = [];
                if (message.calls && message.calls.length) {
                    object.calls = [];
                    for (let j = 0; j < message.calls.length; ++j)
                        object.calls[j] = $root.gravity.v1.OutgoingLogicCall.toObject(message.calls[j], options);
                }
                return object;
            };

            /**
             * Converts this QueryOutgoingLogicCallsResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryOutgoingLogicCallsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryOutgoingLogicCallsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryOutgoingLogicCallsResponse;
        })();

        v1.QueryBatchRequestByNonceRequest = (function() {

            /**
             * Properties of a QueryBatchRequestByNonceRequest.
             * @memberof gravity.v1
             * @interface IQueryBatchRequestByNonceRequest
             * @property {Long|null} [nonce] QueryBatchRequestByNonceRequest nonce
             * @property {string|null} [contract_address] QueryBatchRequestByNonceRequest contract_address
             */

            /**
             * Constructs a new QueryBatchRequestByNonceRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryBatchRequestByNonceRequest.
             * @implements IQueryBatchRequestByNonceRequest
             * @constructor
             * @param {gravity.v1.IQueryBatchRequestByNonceRequest=} [properties] Properties to set
             */
            function QueryBatchRequestByNonceRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryBatchRequestByNonceRequest nonce.
             * @member {Long} nonce
             * @memberof gravity.v1.QueryBatchRequestByNonceRequest
             * @instance
             */
            QueryBatchRequestByNonceRequest.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * QueryBatchRequestByNonceRequest contract_address.
             * @member {string} contract_address
             * @memberof gravity.v1.QueryBatchRequestByNonceRequest
             * @instance
             */
            QueryBatchRequestByNonceRequest.prototype.contract_address = "";

            /**
             * Encodes the specified QueryBatchRequestByNonceRequest message. Does not implicitly {@link gravity.v1.QueryBatchRequestByNonceRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryBatchRequestByNonceRequest
             * @static
             * @param {gravity.v1.IQueryBatchRequestByNonceRequest} message QueryBatchRequestByNonceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryBatchRequestByNonceRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.contract_address != null && Object.hasOwnProperty.call(message, "contract_address"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.contract_address);
                return writer;
            };

            /**
             * Encodes the specified QueryBatchRequestByNonceRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryBatchRequestByNonceRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryBatchRequestByNonceRequest
             * @static
             * @param {gravity.v1.IQueryBatchRequestByNonceRequest} message QueryBatchRequestByNonceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryBatchRequestByNonceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryBatchRequestByNonceRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryBatchRequestByNonceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryBatchRequestByNonceRequest} QueryBatchRequestByNonceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryBatchRequestByNonceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryBatchRequestByNonceRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        message.contract_address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryBatchRequestByNonceRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryBatchRequestByNonceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryBatchRequestByNonceRequest} QueryBatchRequestByNonceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryBatchRequestByNonceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryBatchRequestByNonceRequest message.
             * @function verify
             * @memberof gravity.v1.QueryBatchRequestByNonceRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryBatchRequestByNonceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                    if (!$util.isString(message.contract_address))
                        return "contract_address: string expected";
                return null;
            };

            /**
             * Creates a QueryBatchRequestByNonceRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryBatchRequestByNonceRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryBatchRequestByNonceRequest} QueryBatchRequestByNonceRequest
             */
            QueryBatchRequestByNonceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryBatchRequestByNonceRequest)
                    return object;
                let message = new $root.gravity.v1.QueryBatchRequestByNonceRequest();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.contract_address != null)
                    message.contract_address = String(object.contract_address);
                return message;
            };

            /**
             * Creates a plain object from a QueryBatchRequestByNonceRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryBatchRequestByNonceRequest
             * @static
             * @param {gravity.v1.QueryBatchRequestByNonceRequest} message QueryBatchRequestByNonceRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryBatchRequestByNonceRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    object.contract_address = "";
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                    object.contract_address = message.contract_address;
                return object;
            };

            /**
             * Converts this QueryBatchRequestByNonceRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryBatchRequestByNonceRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryBatchRequestByNonceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryBatchRequestByNonceRequest;
        })();

        v1.QueryBatchRequestByNonceResponse = (function() {

            /**
             * Properties of a QueryBatchRequestByNonceResponse.
             * @memberof gravity.v1
             * @interface IQueryBatchRequestByNonceResponse
             * @property {gravity.v1.IOutgoingTxBatch|null} [batch] QueryBatchRequestByNonceResponse batch
             */

            /**
             * Constructs a new QueryBatchRequestByNonceResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryBatchRequestByNonceResponse.
             * @implements IQueryBatchRequestByNonceResponse
             * @constructor
             * @param {gravity.v1.IQueryBatchRequestByNonceResponse=} [properties] Properties to set
             */
            function QueryBatchRequestByNonceResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryBatchRequestByNonceResponse batch.
             * @member {gravity.v1.IOutgoingTxBatch|null|undefined} batch
             * @memberof gravity.v1.QueryBatchRequestByNonceResponse
             * @instance
             */
            QueryBatchRequestByNonceResponse.prototype.batch = null;

            /**
             * Encodes the specified QueryBatchRequestByNonceResponse message. Does not implicitly {@link gravity.v1.QueryBatchRequestByNonceResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryBatchRequestByNonceResponse
             * @static
             * @param {gravity.v1.IQueryBatchRequestByNonceResponse} message QueryBatchRequestByNonceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryBatchRequestByNonceResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.batch != null && Object.hasOwnProperty.call(message, "batch"))
                    $root.gravity.v1.OutgoingTxBatch.encode(message.batch, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryBatchRequestByNonceResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryBatchRequestByNonceResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryBatchRequestByNonceResponse
             * @static
             * @param {gravity.v1.IQueryBatchRequestByNonceResponse} message QueryBatchRequestByNonceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryBatchRequestByNonceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryBatchRequestByNonceResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryBatchRequestByNonceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryBatchRequestByNonceResponse} QueryBatchRequestByNonceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryBatchRequestByNonceResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryBatchRequestByNonceResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.batch = $root.gravity.v1.OutgoingTxBatch.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryBatchRequestByNonceResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryBatchRequestByNonceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryBatchRequestByNonceResponse} QueryBatchRequestByNonceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryBatchRequestByNonceResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryBatchRequestByNonceResponse message.
             * @function verify
             * @memberof gravity.v1.QueryBatchRequestByNonceResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryBatchRequestByNonceResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.batch != null && message.hasOwnProperty("batch")) {
                    let error = $root.gravity.v1.OutgoingTxBatch.verify(message.batch);
                    if (error)
                        return "batch." + error;
                }
                return null;
            };

            /**
             * Creates a QueryBatchRequestByNonceResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryBatchRequestByNonceResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryBatchRequestByNonceResponse} QueryBatchRequestByNonceResponse
             */
            QueryBatchRequestByNonceResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryBatchRequestByNonceResponse)
                    return object;
                let message = new $root.gravity.v1.QueryBatchRequestByNonceResponse();
                if (object.batch != null) {
                    if (typeof object.batch !== "object")
                        throw TypeError(".gravity.v1.QueryBatchRequestByNonceResponse.batch: object expected");
                    message.batch = $root.gravity.v1.OutgoingTxBatch.fromObject(object.batch);
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryBatchRequestByNonceResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryBatchRequestByNonceResponse
             * @static
             * @param {gravity.v1.QueryBatchRequestByNonceResponse} message QueryBatchRequestByNonceResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryBatchRequestByNonceResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.batch = null;
                if (message.batch != null && message.hasOwnProperty("batch"))
                    object.batch = $root.gravity.v1.OutgoingTxBatch.toObject(message.batch, options);
                return object;
            };

            /**
             * Converts this QueryBatchRequestByNonceResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryBatchRequestByNonceResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryBatchRequestByNonceResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryBatchRequestByNonceResponse;
        })();

        v1.QueryBatchConfirmsRequest = (function() {

            /**
             * Properties of a QueryBatchConfirmsRequest.
             * @memberof gravity.v1
             * @interface IQueryBatchConfirmsRequest
             * @property {Long|null} [nonce] QueryBatchConfirmsRequest nonce
             * @property {string|null} [contract_address] QueryBatchConfirmsRequest contract_address
             */

            /**
             * Constructs a new QueryBatchConfirmsRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryBatchConfirmsRequest.
             * @implements IQueryBatchConfirmsRequest
             * @constructor
             * @param {gravity.v1.IQueryBatchConfirmsRequest=} [properties] Properties to set
             */
            function QueryBatchConfirmsRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryBatchConfirmsRequest nonce.
             * @member {Long} nonce
             * @memberof gravity.v1.QueryBatchConfirmsRequest
             * @instance
             */
            QueryBatchConfirmsRequest.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * QueryBatchConfirmsRequest contract_address.
             * @member {string} contract_address
             * @memberof gravity.v1.QueryBatchConfirmsRequest
             * @instance
             */
            QueryBatchConfirmsRequest.prototype.contract_address = "";

            /**
             * Encodes the specified QueryBatchConfirmsRequest message. Does not implicitly {@link gravity.v1.QueryBatchConfirmsRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryBatchConfirmsRequest
             * @static
             * @param {gravity.v1.IQueryBatchConfirmsRequest} message QueryBatchConfirmsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryBatchConfirmsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.contract_address != null && Object.hasOwnProperty.call(message, "contract_address"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.contract_address);
                return writer;
            };

            /**
             * Encodes the specified QueryBatchConfirmsRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryBatchConfirmsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryBatchConfirmsRequest
             * @static
             * @param {gravity.v1.IQueryBatchConfirmsRequest} message QueryBatchConfirmsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryBatchConfirmsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryBatchConfirmsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryBatchConfirmsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryBatchConfirmsRequest} QueryBatchConfirmsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryBatchConfirmsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryBatchConfirmsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        message.contract_address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryBatchConfirmsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryBatchConfirmsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryBatchConfirmsRequest} QueryBatchConfirmsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryBatchConfirmsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryBatchConfirmsRequest message.
             * @function verify
             * @memberof gravity.v1.QueryBatchConfirmsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryBatchConfirmsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                    if (!$util.isString(message.contract_address))
                        return "contract_address: string expected";
                return null;
            };

            /**
             * Creates a QueryBatchConfirmsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryBatchConfirmsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryBatchConfirmsRequest} QueryBatchConfirmsRequest
             */
            QueryBatchConfirmsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryBatchConfirmsRequest)
                    return object;
                let message = new $root.gravity.v1.QueryBatchConfirmsRequest();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.contract_address != null)
                    message.contract_address = String(object.contract_address);
                return message;
            };

            /**
             * Creates a plain object from a QueryBatchConfirmsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryBatchConfirmsRequest
             * @static
             * @param {gravity.v1.QueryBatchConfirmsRequest} message QueryBatchConfirmsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryBatchConfirmsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    object.contract_address = "";
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                    object.contract_address = message.contract_address;
                return object;
            };

            /**
             * Converts this QueryBatchConfirmsRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryBatchConfirmsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryBatchConfirmsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryBatchConfirmsRequest;
        })();

        v1.QueryBatchConfirmsResponse = (function() {

            /**
             * Properties of a QueryBatchConfirmsResponse.
             * @memberof gravity.v1
             * @interface IQueryBatchConfirmsResponse
             * @property {Array.<gravity.v1.IMsgConfirmBatch>|null} [confirms] QueryBatchConfirmsResponse confirms
             */

            /**
             * Constructs a new QueryBatchConfirmsResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryBatchConfirmsResponse.
             * @implements IQueryBatchConfirmsResponse
             * @constructor
             * @param {gravity.v1.IQueryBatchConfirmsResponse=} [properties] Properties to set
             */
            function QueryBatchConfirmsResponse(properties) {
                this.confirms = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryBatchConfirmsResponse confirms.
             * @member {Array.<gravity.v1.IMsgConfirmBatch>} confirms
             * @memberof gravity.v1.QueryBatchConfirmsResponse
             * @instance
             */
            QueryBatchConfirmsResponse.prototype.confirms = $util.emptyArray;

            /**
             * Encodes the specified QueryBatchConfirmsResponse message. Does not implicitly {@link gravity.v1.QueryBatchConfirmsResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryBatchConfirmsResponse
             * @static
             * @param {gravity.v1.IQueryBatchConfirmsResponse} message QueryBatchConfirmsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryBatchConfirmsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.confirms != null && message.confirms.length)
                    for (let i = 0; i < message.confirms.length; ++i)
                        $root.gravity.v1.MsgConfirmBatch.encode(message.confirms[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryBatchConfirmsResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryBatchConfirmsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryBatchConfirmsResponse
             * @static
             * @param {gravity.v1.IQueryBatchConfirmsResponse} message QueryBatchConfirmsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryBatchConfirmsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryBatchConfirmsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryBatchConfirmsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryBatchConfirmsResponse} QueryBatchConfirmsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryBatchConfirmsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryBatchConfirmsResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.confirms && message.confirms.length))
                            message.confirms = [];
                        message.confirms.push($root.gravity.v1.MsgConfirmBatch.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryBatchConfirmsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryBatchConfirmsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryBatchConfirmsResponse} QueryBatchConfirmsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryBatchConfirmsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryBatchConfirmsResponse message.
             * @function verify
             * @memberof gravity.v1.QueryBatchConfirmsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryBatchConfirmsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.confirms != null && message.hasOwnProperty("confirms")) {
                    if (!Array.isArray(message.confirms))
                        return "confirms: array expected";
                    for (let i = 0; i < message.confirms.length; ++i) {
                        let error = $root.gravity.v1.MsgConfirmBatch.verify(message.confirms[i]);
                        if (error)
                            return "confirms." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryBatchConfirmsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryBatchConfirmsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryBatchConfirmsResponse} QueryBatchConfirmsResponse
             */
            QueryBatchConfirmsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryBatchConfirmsResponse)
                    return object;
                let message = new $root.gravity.v1.QueryBatchConfirmsResponse();
                if (object.confirms) {
                    if (!Array.isArray(object.confirms))
                        throw TypeError(".gravity.v1.QueryBatchConfirmsResponse.confirms: array expected");
                    message.confirms = [];
                    for (let i = 0; i < object.confirms.length; ++i) {
                        if (typeof object.confirms[i] !== "object")
                            throw TypeError(".gravity.v1.QueryBatchConfirmsResponse.confirms: object expected");
                        message.confirms[i] = $root.gravity.v1.MsgConfirmBatch.fromObject(object.confirms[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryBatchConfirmsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryBatchConfirmsResponse
             * @static
             * @param {gravity.v1.QueryBatchConfirmsResponse} message QueryBatchConfirmsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryBatchConfirmsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.confirms = [];
                if (message.confirms && message.confirms.length) {
                    object.confirms = [];
                    for (let j = 0; j < message.confirms.length; ++j)
                        object.confirms[j] = $root.gravity.v1.MsgConfirmBatch.toObject(message.confirms[j], options);
                }
                return object;
            };

            /**
             * Converts this QueryBatchConfirmsResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryBatchConfirmsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryBatchConfirmsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryBatchConfirmsResponse;
        })();

        v1.QueryLogicConfirmsRequest = (function() {

            /**
             * Properties of a QueryLogicConfirmsRequest.
             * @memberof gravity.v1
             * @interface IQueryLogicConfirmsRequest
             * @property {Uint8Array|null} [invalidation_id] QueryLogicConfirmsRequest invalidation_id
             * @property {Long|null} [invalidation_nonce] QueryLogicConfirmsRequest invalidation_nonce
             */

            /**
             * Constructs a new QueryLogicConfirmsRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryLogicConfirmsRequest.
             * @implements IQueryLogicConfirmsRequest
             * @constructor
             * @param {gravity.v1.IQueryLogicConfirmsRequest=} [properties] Properties to set
             */
            function QueryLogicConfirmsRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryLogicConfirmsRequest invalidation_id.
             * @member {Uint8Array} invalidation_id
             * @memberof gravity.v1.QueryLogicConfirmsRequest
             * @instance
             */
            QueryLogicConfirmsRequest.prototype.invalidation_id = $util.newBuffer([]);

            /**
             * QueryLogicConfirmsRequest invalidation_nonce.
             * @member {Long} invalidation_nonce
             * @memberof gravity.v1.QueryLogicConfirmsRequest
             * @instance
             */
            QueryLogicConfirmsRequest.prototype.invalidation_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified QueryLogicConfirmsRequest message. Does not implicitly {@link gravity.v1.QueryLogicConfirmsRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryLogicConfirmsRequest
             * @static
             * @param {gravity.v1.IQueryLogicConfirmsRequest} message QueryLogicConfirmsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLogicConfirmsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.invalidation_id != null && Object.hasOwnProperty.call(message, "invalidation_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.invalidation_id);
                if (message.invalidation_nonce != null && Object.hasOwnProperty.call(message, "invalidation_nonce"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.invalidation_nonce);
                return writer;
            };

            /**
             * Encodes the specified QueryLogicConfirmsRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryLogicConfirmsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryLogicConfirmsRequest
             * @static
             * @param {gravity.v1.IQueryLogicConfirmsRequest} message QueryLogicConfirmsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLogicConfirmsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryLogicConfirmsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryLogicConfirmsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryLogicConfirmsRequest} QueryLogicConfirmsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLogicConfirmsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLogicConfirmsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.invalidation_id = reader.bytes();
                        break;
                    case 2:
                        message.invalidation_nonce = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryLogicConfirmsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryLogicConfirmsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryLogicConfirmsRequest} QueryLogicConfirmsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLogicConfirmsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryLogicConfirmsRequest message.
             * @function verify
             * @memberof gravity.v1.QueryLogicConfirmsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryLogicConfirmsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.invalidation_id != null && message.hasOwnProperty("invalidation_id"))
                    if (!(message.invalidation_id && typeof message.invalidation_id.length === "number" || $util.isString(message.invalidation_id)))
                        return "invalidation_id: buffer expected";
                if (message.invalidation_nonce != null && message.hasOwnProperty("invalidation_nonce"))
                    if (!$util.isInteger(message.invalidation_nonce) && !(message.invalidation_nonce && $util.isInteger(message.invalidation_nonce.low) && $util.isInteger(message.invalidation_nonce.high)))
                        return "invalidation_nonce: integer|Long expected";
                return null;
            };

            /**
             * Creates a QueryLogicConfirmsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryLogicConfirmsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryLogicConfirmsRequest} QueryLogicConfirmsRequest
             */
            QueryLogicConfirmsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryLogicConfirmsRequest)
                    return object;
                let message = new $root.gravity.v1.QueryLogicConfirmsRequest();
                if (object.invalidation_id != null)
                    if (typeof object.invalidation_id === "string")
                        $util.base64.decode(object.invalidation_id, message.invalidation_id = $util.newBuffer($util.base64.length(object.invalidation_id)), 0);
                    else if (object.invalidation_id.length)
                        message.invalidation_id = object.invalidation_id;
                if (object.invalidation_nonce != null)
                    if ($util.Long)
                        (message.invalidation_nonce = $util.Long.fromValue(object.invalidation_nonce)).unsigned = true;
                    else if (typeof object.invalidation_nonce === "string")
                        message.invalidation_nonce = parseInt(object.invalidation_nonce, 10);
                    else if (typeof object.invalidation_nonce === "number")
                        message.invalidation_nonce = object.invalidation_nonce;
                    else if (typeof object.invalidation_nonce === "object")
                        message.invalidation_nonce = new $util.LongBits(object.invalidation_nonce.low >>> 0, object.invalidation_nonce.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a QueryLogicConfirmsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryLogicConfirmsRequest
             * @static
             * @param {gravity.v1.QueryLogicConfirmsRequest} message QueryLogicConfirmsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryLogicConfirmsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.invalidation_id = "";
                    else {
                        object.invalidation_id = [];
                        if (options.bytes !== Array)
                            object.invalidation_id = $util.newBuffer(object.invalidation_id);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.invalidation_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.invalidation_nonce = options.longs === String ? "0" : 0;
                }
                if (message.invalidation_id != null && message.hasOwnProperty("invalidation_id"))
                    object.invalidation_id = options.bytes === String ? $util.base64.encode(message.invalidation_id, 0, message.invalidation_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.invalidation_id) : message.invalidation_id;
                if (message.invalidation_nonce != null && message.hasOwnProperty("invalidation_nonce"))
                    if (typeof message.invalidation_nonce === "number")
                        object.invalidation_nonce = options.longs === String ? String(message.invalidation_nonce) : message.invalidation_nonce;
                    else
                        object.invalidation_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.invalidation_nonce) : options.longs === Number ? new $util.LongBits(message.invalidation_nonce.low >>> 0, message.invalidation_nonce.high >>> 0).toNumber(true) : message.invalidation_nonce;
                return object;
            };

            /**
             * Converts this QueryLogicConfirmsRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryLogicConfirmsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryLogicConfirmsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryLogicConfirmsRequest;
        })();

        v1.QueryLogicConfirmsResponse = (function() {

            /**
             * Properties of a QueryLogicConfirmsResponse.
             * @memberof gravity.v1
             * @interface IQueryLogicConfirmsResponse
             * @property {Array.<gravity.v1.IMsgConfirmLogicCall>|null} [confirms] QueryLogicConfirmsResponse confirms
             */

            /**
             * Constructs a new QueryLogicConfirmsResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryLogicConfirmsResponse.
             * @implements IQueryLogicConfirmsResponse
             * @constructor
             * @param {gravity.v1.IQueryLogicConfirmsResponse=} [properties] Properties to set
             */
            function QueryLogicConfirmsResponse(properties) {
                this.confirms = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryLogicConfirmsResponse confirms.
             * @member {Array.<gravity.v1.IMsgConfirmLogicCall>} confirms
             * @memberof gravity.v1.QueryLogicConfirmsResponse
             * @instance
             */
            QueryLogicConfirmsResponse.prototype.confirms = $util.emptyArray;

            /**
             * Encodes the specified QueryLogicConfirmsResponse message. Does not implicitly {@link gravity.v1.QueryLogicConfirmsResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryLogicConfirmsResponse
             * @static
             * @param {gravity.v1.IQueryLogicConfirmsResponse} message QueryLogicConfirmsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLogicConfirmsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.confirms != null && message.confirms.length)
                    for (let i = 0; i < message.confirms.length; ++i)
                        $root.gravity.v1.MsgConfirmLogicCall.encode(message.confirms[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryLogicConfirmsResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryLogicConfirmsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryLogicConfirmsResponse
             * @static
             * @param {gravity.v1.IQueryLogicConfirmsResponse} message QueryLogicConfirmsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLogicConfirmsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryLogicConfirmsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryLogicConfirmsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryLogicConfirmsResponse} QueryLogicConfirmsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLogicConfirmsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLogicConfirmsResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.confirms && message.confirms.length))
                            message.confirms = [];
                        message.confirms.push($root.gravity.v1.MsgConfirmLogicCall.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryLogicConfirmsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryLogicConfirmsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryLogicConfirmsResponse} QueryLogicConfirmsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLogicConfirmsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryLogicConfirmsResponse message.
             * @function verify
             * @memberof gravity.v1.QueryLogicConfirmsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryLogicConfirmsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.confirms != null && message.hasOwnProperty("confirms")) {
                    if (!Array.isArray(message.confirms))
                        return "confirms: array expected";
                    for (let i = 0; i < message.confirms.length; ++i) {
                        let error = $root.gravity.v1.MsgConfirmLogicCall.verify(message.confirms[i]);
                        if (error)
                            return "confirms." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryLogicConfirmsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryLogicConfirmsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryLogicConfirmsResponse} QueryLogicConfirmsResponse
             */
            QueryLogicConfirmsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryLogicConfirmsResponse)
                    return object;
                let message = new $root.gravity.v1.QueryLogicConfirmsResponse();
                if (object.confirms) {
                    if (!Array.isArray(object.confirms))
                        throw TypeError(".gravity.v1.QueryLogicConfirmsResponse.confirms: array expected");
                    message.confirms = [];
                    for (let i = 0; i < object.confirms.length; ++i) {
                        if (typeof object.confirms[i] !== "object")
                            throw TypeError(".gravity.v1.QueryLogicConfirmsResponse.confirms: object expected");
                        message.confirms[i] = $root.gravity.v1.MsgConfirmLogicCall.fromObject(object.confirms[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryLogicConfirmsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryLogicConfirmsResponse
             * @static
             * @param {gravity.v1.QueryLogicConfirmsResponse} message QueryLogicConfirmsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryLogicConfirmsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.confirms = [];
                if (message.confirms && message.confirms.length) {
                    object.confirms = [];
                    for (let j = 0; j < message.confirms.length; ++j)
                        object.confirms[j] = $root.gravity.v1.MsgConfirmLogicCall.toObject(message.confirms[j], options);
                }
                return object;
            };

            /**
             * Converts this QueryLogicConfirmsResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryLogicConfirmsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryLogicConfirmsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryLogicConfirmsResponse;
        })();

        v1.QueryLastEventNonceByAddrRequest = (function() {

            /**
             * Properties of a QueryLastEventNonceByAddrRequest.
             * @memberof gravity.v1
             * @interface IQueryLastEventNonceByAddrRequest
             * @property {string|null} [address] QueryLastEventNonceByAddrRequest address
             */

            /**
             * Constructs a new QueryLastEventNonceByAddrRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryLastEventNonceByAddrRequest.
             * @implements IQueryLastEventNonceByAddrRequest
             * @constructor
             * @param {gravity.v1.IQueryLastEventNonceByAddrRequest=} [properties] Properties to set
             */
            function QueryLastEventNonceByAddrRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryLastEventNonceByAddrRequest address.
             * @member {string} address
             * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
             * @instance
             */
            QueryLastEventNonceByAddrRequest.prototype.address = "";

            /**
             * Encodes the specified QueryLastEventNonceByAddrRequest message. Does not implicitly {@link gravity.v1.QueryLastEventNonceByAddrRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
             * @static
             * @param {gravity.v1.IQueryLastEventNonceByAddrRequest} message QueryLastEventNonceByAddrRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastEventNonceByAddrRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                return writer;
            };

            /**
             * Encodes the specified QueryLastEventNonceByAddrRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryLastEventNonceByAddrRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
             * @static
             * @param {gravity.v1.IQueryLastEventNonceByAddrRequest} message QueryLastEventNonceByAddrRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastEventNonceByAddrRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryLastEventNonceByAddrRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryLastEventNonceByAddrRequest} QueryLastEventNonceByAddrRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastEventNonceByAddrRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastEventNonceByAddrRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryLastEventNonceByAddrRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryLastEventNonceByAddrRequest} QueryLastEventNonceByAddrRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastEventNonceByAddrRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryLastEventNonceByAddrRequest message.
             * @function verify
             * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryLastEventNonceByAddrRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                return null;
            };

            /**
             * Creates a QueryLastEventNonceByAddrRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryLastEventNonceByAddrRequest} QueryLastEventNonceByAddrRequest
             */
            QueryLastEventNonceByAddrRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryLastEventNonceByAddrRequest)
                    return object;
                let message = new $root.gravity.v1.QueryLastEventNonceByAddrRequest();
                if (object.address != null)
                    message.address = String(object.address);
                return message;
            };

            /**
             * Creates a plain object from a QueryLastEventNonceByAddrRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
             * @static
             * @param {gravity.v1.QueryLastEventNonceByAddrRequest} message QueryLastEventNonceByAddrRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryLastEventNonceByAddrRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.address = "";
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                return object;
            };

            /**
             * Converts this QueryLastEventNonceByAddrRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryLastEventNonceByAddrRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryLastEventNonceByAddrRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryLastEventNonceByAddrRequest;
        })();

        v1.QueryLastEventNonceByAddrResponse = (function() {

            /**
             * Properties of a QueryLastEventNonceByAddrResponse.
             * @memberof gravity.v1
             * @interface IQueryLastEventNonceByAddrResponse
             * @property {Long|null} [event_nonce] QueryLastEventNonceByAddrResponse event_nonce
             */

            /**
             * Constructs a new QueryLastEventNonceByAddrResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryLastEventNonceByAddrResponse.
             * @implements IQueryLastEventNonceByAddrResponse
             * @constructor
             * @param {gravity.v1.IQueryLastEventNonceByAddrResponse=} [properties] Properties to set
             */
            function QueryLastEventNonceByAddrResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryLastEventNonceByAddrResponse event_nonce.
             * @member {Long} event_nonce
             * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
             * @instance
             */
            QueryLastEventNonceByAddrResponse.prototype.event_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified QueryLastEventNonceByAddrResponse message. Does not implicitly {@link gravity.v1.QueryLastEventNonceByAddrResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
             * @static
             * @param {gravity.v1.IQueryLastEventNonceByAddrResponse} message QueryLastEventNonceByAddrResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastEventNonceByAddrResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.event_nonce != null && Object.hasOwnProperty.call(message, "event_nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.event_nonce);
                return writer;
            };

            /**
             * Encodes the specified QueryLastEventNonceByAddrResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryLastEventNonceByAddrResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
             * @static
             * @param {gravity.v1.IQueryLastEventNonceByAddrResponse} message QueryLastEventNonceByAddrResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryLastEventNonceByAddrResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryLastEventNonceByAddrResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryLastEventNonceByAddrResponse} QueryLastEventNonceByAddrResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastEventNonceByAddrResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryLastEventNonceByAddrResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.event_nonce = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryLastEventNonceByAddrResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryLastEventNonceByAddrResponse} QueryLastEventNonceByAddrResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryLastEventNonceByAddrResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryLastEventNonceByAddrResponse message.
             * @function verify
             * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryLastEventNonceByAddrResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.event_nonce != null && message.hasOwnProperty("event_nonce"))
                    if (!$util.isInteger(message.event_nonce) && !(message.event_nonce && $util.isInteger(message.event_nonce.low) && $util.isInteger(message.event_nonce.high)))
                        return "event_nonce: integer|Long expected";
                return null;
            };

            /**
             * Creates a QueryLastEventNonceByAddrResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryLastEventNonceByAddrResponse} QueryLastEventNonceByAddrResponse
             */
            QueryLastEventNonceByAddrResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryLastEventNonceByAddrResponse)
                    return object;
                let message = new $root.gravity.v1.QueryLastEventNonceByAddrResponse();
                if (object.event_nonce != null)
                    if ($util.Long)
                        (message.event_nonce = $util.Long.fromValue(object.event_nonce)).unsigned = true;
                    else if (typeof object.event_nonce === "string")
                        message.event_nonce = parseInt(object.event_nonce, 10);
                    else if (typeof object.event_nonce === "number")
                        message.event_nonce = object.event_nonce;
                    else if (typeof object.event_nonce === "object")
                        message.event_nonce = new $util.LongBits(object.event_nonce.low >>> 0, object.event_nonce.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a QueryLastEventNonceByAddrResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
             * @static
             * @param {gravity.v1.QueryLastEventNonceByAddrResponse} message QueryLastEventNonceByAddrResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryLastEventNonceByAddrResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.event_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.event_nonce = options.longs === String ? "0" : 0;
                if (message.event_nonce != null && message.hasOwnProperty("event_nonce"))
                    if (typeof message.event_nonce === "number")
                        object.event_nonce = options.longs === String ? String(message.event_nonce) : message.event_nonce;
                    else
                        object.event_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.event_nonce) : options.longs === Number ? new $util.LongBits(message.event_nonce.low >>> 0, message.event_nonce.high >>> 0).toNumber(true) : message.event_nonce;
                return object;
            };

            /**
             * Converts this QueryLastEventNonceByAddrResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryLastEventNonceByAddrResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryLastEventNonceByAddrResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryLastEventNonceByAddrResponse;
        })();

        v1.QueryERC20ToDenomRequest = (function() {

            /**
             * Properties of a QueryERC20ToDenomRequest.
             * @memberof gravity.v1
             * @interface IQueryERC20ToDenomRequest
             * @property {string|null} [erc20] QueryERC20ToDenomRequest erc20
             */

            /**
             * Constructs a new QueryERC20ToDenomRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryERC20ToDenomRequest.
             * @implements IQueryERC20ToDenomRequest
             * @constructor
             * @param {gravity.v1.IQueryERC20ToDenomRequest=} [properties] Properties to set
             */
            function QueryERC20ToDenomRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryERC20ToDenomRequest erc20.
             * @member {string} erc20
             * @memberof gravity.v1.QueryERC20ToDenomRequest
             * @instance
             */
            QueryERC20ToDenomRequest.prototype.erc20 = "";

            /**
             * Encodes the specified QueryERC20ToDenomRequest message. Does not implicitly {@link gravity.v1.QueryERC20ToDenomRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryERC20ToDenomRequest
             * @static
             * @param {gravity.v1.IQueryERC20ToDenomRequest} message QueryERC20ToDenomRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryERC20ToDenomRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.erc20 != null && Object.hasOwnProperty.call(message, "erc20"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.erc20);
                return writer;
            };

            /**
             * Encodes the specified QueryERC20ToDenomRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryERC20ToDenomRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryERC20ToDenomRequest
             * @static
             * @param {gravity.v1.IQueryERC20ToDenomRequest} message QueryERC20ToDenomRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryERC20ToDenomRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryERC20ToDenomRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryERC20ToDenomRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryERC20ToDenomRequest} QueryERC20ToDenomRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryERC20ToDenomRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryERC20ToDenomRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.erc20 = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryERC20ToDenomRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryERC20ToDenomRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryERC20ToDenomRequest} QueryERC20ToDenomRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryERC20ToDenomRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryERC20ToDenomRequest message.
             * @function verify
             * @memberof gravity.v1.QueryERC20ToDenomRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryERC20ToDenomRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.erc20 != null && message.hasOwnProperty("erc20"))
                    if (!$util.isString(message.erc20))
                        return "erc20: string expected";
                return null;
            };

            /**
             * Creates a QueryERC20ToDenomRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryERC20ToDenomRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryERC20ToDenomRequest} QueryERC20ToDenomRequest
             */
            QueryERC20ToDenomRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryERC20ToDenomRequest)
                    return object;
                let message = new $root.gravity.v1.QueryERC20ToDenomRequest();
                if (object.erc20 != null)
                    message.erc20 = String(object.erc20);
                return message;
            };

            /**
             * Creates a plain object from a QueryERC20ToDenomRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryERC20ToDenomRequest
             * @static
             * @param {gravity.v1.QueryERC20ToDenomRequest} message QueryERC20ToDenomRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryERC20ToDenomRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.erc20 = "";
                if (message.erc20 != null && message.hasOwnProperty("erc20"))
                    object.erc20 = message.erc20;
                return object;
            };

            /**
             * Converts this QueryERC20ToDenomRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryERC20ToDenomRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryERC20ToDenomRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryERC20ToDenomRequest;
        })();

        v1.QueryERC20ToDenomResponse = (function() {

            /**
             * Properties of a QueryERC20ToDenomResponse.
             * @memberof gravity.v1
             * @interface IQueryERC20ToDenomResponse
             * @property {string|null} [denom] QueryERC20ToDenomResponse denom
             * @property {boolean|null} [cosmos_originated] QueryERC20ToDenomResponse cosmos_originated
             */

            /**
             * Constructs a new QueryERC20ToDenomResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryERC20ToDenomResponse.
             * @implements IQueryERC20ToDenomResponse
             * @constructor
             * @param {gravity.v1.IQueryERC20ToDenomResponse=} [properties] Properties to set
             */
            function QueryERC20ToDenomResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryERC20ToDenomResponse denom.
             * @member {string} denom
             * @memberof gravity.v1.QueryERC20ToDenomResponse
             * @instance
             */
            QueryERC20ToDenomResponse.prototype.denom = "";

            /**
             * QueryERC20ToDenomResponse cosmos_originated.
             * @member {boolean} cosmos_originated
             * @memberof gravity.v1.QueryERC20ToDenomResponse
             * @instance
             */
            QueryERC20ToDenomResponse.prototype.cosmos_originated = false;

            /**
             * Encodes the specified QueryERC20ToDenomResponse message. Does not implicitly {@link gravity.v1.QueryERC20ToDenomResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryERC20ToDenomResponse
             * @static
             * @param {gravity.v1.IQueryERC20ToDenomResponse} message QueryERC20ToDenomResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryERC20ToDenomResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
                if (message.cosmos_originated != null && Object.hasOwnProperty.call(message, "cosmos_originated"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.cosmos_originated);
                return writer;
            };

            /**
             * Encodes the specified QueryERC20ToDenomResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryERC20ToDenomResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryERC20ToDenomResponse
             * @static
             * @param {gravity.v1.IQueryERC20ToDenomResponse} message QueryERC20ToDenomResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryERC20ToDenomResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryERC20ToDenomResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryERC20ToDenomResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryERC20ToDenomResponse} QueryERC20ToDenomResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryERC20ToDenomResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryERC20ToDenomResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.denom = reader.string();
                        break;
                    case 2:
                        message.cosmos_originated = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryERC20ToDenomResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryERC20ToDenomResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryERC20ToDenomResponse} QueryERC20ToDenomResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryERC20ToDenomResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryERC20ToDenomResponse message.
             * @function verify
             * @memberof gravity.v1.QueryERC20ToDenomResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryERC20ToDenomResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.denom != null && message.hasOwnProperty("denom"))
                    if (!$util.isString(message.denom))
                        return "denom: string expected";
                if (message.cosmos_originated != null && message.hasOwnProperty("cosmos_originated"))
                    if (typeof message.cosmos_originated !== "boolean")
                        return "cosmos_originated: boolean expected";
                return null;
            };

            /**
             * Creates a QueryERC20ToDenomResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryERC20ToDenomResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryERC20ToDenomResponse} QueryERC20ToDenomResponse
             */
            QueryERC20ToDenomResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryERC20ToDenomResponse)
                    return object;
                let message = new $root.gravity.v1.QueryERC20ToDenomResponse();
                if (object.denom != null)
                    message.denom = String(object.denom);
                if (object.cosmos_originated != null)
                    message.cosmos_originated = Boolean(object.cosmos_originated);
                return message;
            };

            /**
             * Creates a plain object from a QueryERC20ToDenomResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryERC20ToDenomResponse
             * @static
             * @param {gravity.v1.QueryERC20ToDenomResponse} message QueryERC20ToDenomResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryERC20ToDenomResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.denom = "";
                    object.cosmos_originated = false;
                }
                if (message.denom != null && message.hasOwnProperty("denom"))
                    object.denom = message.denom;
                if (message.cosmos_originated != null && message.hasOwnProperty("cosmos_originated"))
                    object.cosmos_originated = message.cosmos_originated;
                return object;
            };

            /**
             * Converts this QueryERC20ToDenomResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryERC20ToDenomResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryERC20ToDenomResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryERC20ToDenomResponse;
        })();

        v1.QueryDenomToERC20Request = (function() {

            /**
             * Properties of a QueryDenomToERC20Request.
             * @memberof gravity.v1
             * @interface IQueryDenomToERC20Request
             * @property {string|null} [denom] QueryDenomToERC20Request denom
             */

            /**
             * Constructs a new QueryDenomToERC20Request.
             * @memberof gravity.v1
             * @classdesc Represents a QueryDenomToERC20Request.
             * @implements IQueryDenomToERC20Request
             * @constructor
             * @param {gravity.v1.IQueryDenomToERC20Request=} [properties] Properties to set
             */
            function QueryDenomToERC20Request(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryDenomToERC20Request denom.
             * @member {string} denom
             * @memberof gravity.v1.QueryDenomToERC20Request
             * @instance
             */
            QueryDenomToERC20Request.prototype.denom = "";

            /**
             * Encodes the specified QueryDenomToERC20Request message. Does not implicitly {@link gravity.v1.QueryDenomToERC20Request.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryDenomToERC20Request
             * @static
             * @param {gravity.v1.IQueryDenomToERC20Request} message QueryDenomToERC20Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDenomToERC20Request.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
                return writer;
            };

            /**
             * Encodes the specified QueryDenomToERC20Request message, length delimited. Does not implicitly {@link gravity.v1.QueryDenomToERC20Request.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryDenomToERC20Request
             * @static
             * @param {gravity.v1.IQueryDenomToERC20Request} message QueryDenomToERC20Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDenomToERC20Request.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryDenomToERC20Request message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryDenomToERC20Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryDenomToERC20Request} QueryDenomToERC20Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDenomToERC20Request.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDenomToERC20Request();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.denom = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryDenomToERC20Request message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryDenomToERC20Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryDenomToERC20Request} QueryDenomToERC20Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDenomToERC20Request.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryDenomToERC20Request message.
             * @function verify
             * @memberof gravity.v1.QueryDenomToERC20Request
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryDenomToERC20Request.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.denom != null && message.hasOwnProperty("denom"))
                    if (!$util.isString(message.denom))
                        return "denom: string expected";
                return null;
            };

            /**
             * Creates a QueryDenomToERC20Request message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryDenomToERC20Request
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryDenomToERC20Request} QueryDenomToERC20Request
             */
            QueryDenomToERC20Request.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryDenomToERC20Request)
                    return object;
                let message = new $root.gravity.v1.QueryDenomToERC20Request();
                if (object.denom != null)
                    message.denom = String(object.denom);
                return message;
            };

            /**
             * Creates a plain object from a QueryDenomToERC20Request message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryDenomToERC20Request
             * @static
             * @param {gravity.v1.QueryDenomToERC20Request} message QueryDenomToERC20Request
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryDenomToERC20Request.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.denom = "";
                if (message.denom != null && message.hasOwnProperty("denom"))
                    object.denom = message.denom;
                return object;
            };

            /**
             * Converts this QueryDenomToERC20Request to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryDenomToERC20Request
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryDenomToERC20Request.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryDenomToERC20Request;
        })();

        v1.QueryDenomToERC20Response = (function() {

            /**
             * Properties of a QueryDenomToERC20Response.
             * @memberof gravity.v1
             * @interface IQueryDenomToERC20Response
             * @property {string|null} [erc20] QueryDenomToERC20Response erc20
             * @property {boolean|null} [cosmos_originated] QueryDenomToERC20Response cosmos_originated
             */

            /**
             * Constructs a new QueryDenomToERC20Response.
             * @memberof gravity.v1
             * @classdesc Represents a QueryDenomToERC20Response.
             * @implements IQueryDenomToERC20Response
             * @constructor
             * @param {gravity.v1.IQueryDenomToERC20Response=} [properties] Properties to set
             */
            function QueryDenomToERC20Response(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryDenomToERC20Response erc20.
             * @member {string} erc20
             * @memberof gravity.v1.QueryDenomToERC20Response
             * @instance
             */
            QueryDenomToERC20Response.prototype.erc20 = "";

            /**
             * QueryDenomToERC20Response cosmos_originated.
             * @member {boolean} cosmos_originated
             * @memberof gravity.v1.QueryDenomToERC20Response
             * @instance
             */
            QueryDenomToERC20Response.prototype.cosmos_originated = false;

            /**
             * Encodes the specified QueryDenomToERC20Response message. Does not implicitly {@link gravity.v1.QueryDenomToERC20Response.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryDenomToERC20Response
             * @static
             * @param {gravity.v1.IQueryDenomToERC20Response} message QueryDenomToERC20Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDenomToERC20Response.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.erc20 != null && Object.hasOwnProperty.call(message, "erc20"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.erc20);
                if (message.cosmos_originated != null && Object.hasOwnProperty.call(message, "cosmos_originated"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.cosmos_originated);
                return writer;
            };

            /**
             * Encodes the specified QueryDenomToERC20Response message, length delimited. Does not implicitly {@link gravity.v1.QueryDenomToERC20Response.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryDenomToERC20Response
             * @static
             * @param {gravity.v1.IQueryDenomToERC20Response} message QueryDenomToERC20Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDenomToERC20Response.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryDenomToERC20Response message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryDenomToERC20Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryDenomToERC20Response} QueryDenomToERC20Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDenomToERC20Response.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDenomToERC20Response();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.erc20 = reader.string();
                        break;
                    case 2:
                        message.cosmos_originated = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryDenomToERC20Response message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryDenomToERC20Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryDenomToERC20Response} QueryDenomToERC20Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDenomToERC20Response.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryDenomToERC20Response message.
             * @function verify
             * @memberof gravity.v1.QueryDenomToERC20Response
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryDenomToERC20Response.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.erc20 != null && message.hasOwnProperty("erc20"))
                    if (!$util.isString(message.erc20))
                        return "erc20: string expected";
                if (message.cosmos_originated != null && message.hasOwnProperty("cosmos_originated"))
                    if (typeof message.cosmos_originated !== "boolean")
                        return "cosmos_originated: boolean expected";
                return null;
            };

            /**
             * Creates a QueryDenomToERC20Response message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryDenomToERC20Response
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryDenomToERC20Response} QueryDenomToERC20Response
             */
            QueryDenomToERC20Response.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryDenomToERC20Response)
                    return object;
                let message = new $root.gravity.v1.QueryDenomToERC20Response();
                if (object.erc20 != null)
                    message.erc20 = String(object.erc20);
                if (object.cosmos_originated != null)
                    message.cosmos_originated = Boolean(object.cosmos_originated);
                return message;
            };

            /**
             * Creates a plain object from a QueryDenomToERC20Response message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryDenomToERC20Response
             * @static
             * @param {gravity.v1.QueryDenomToERC20Response} message QueryDenomToERC20Response
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryDenomToERC20Response.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.erc20 = "";
                    object.cosmos_originated = false;
                }
                if (message.erc20 != null && message.hasOwnProperty("erc20"))
                    object.erc20 = message.erc20;
                if (message.cosmos_originated != null && message.hasOwnProperty("cosmos_originated"))
                    object.cosmos_originated = message.cosmos_originated;
                return object;
            };

            /**
             * Converts this QueryDenomToERC20Response to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryDenomToERC20Response
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryDenomToERC20Response.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryDenomToERC20Response;
        })();

        v1.QueryAttestationsRequest = (function() {

            /**
             * Properties of a QueryAttestationsRequest.
             * @memberof gravity.v1
             * @interface IQueryAttestationsRequest
             * @property {Long|null} [limit] QueryAttestationsRequest limit
             */

            /**
             * Constructs a new QueryAttestationsRequest.
             * @memberof gravity.v1
             * @classdesc Represents a QueryAttestationsRequest.
             * @implements IQueryAttestationsRequest
             * @constructor
             * @param {gravity.v1.IQueryAttestationsRequest=} [properties] Properties to set
             */
            function QueryAttestationsRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryAttestationsRequest limit.
             * @member {Long} limit
             * @memberof gravity.v1.QueryAttestationsRequest
             * @instance
             */
            QueryAttestationsRequest.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified QueryAttestationsRequest message. Does not implicitly {@link gravity.v1.QueryAttestationsRequest.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryAttestationsRequest
             * @static
             * @param {gravity.v1.IQueryAttestationsRequest} message QueryAttestationsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryAttestationsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.limit);
                return writer;
            };

            /**
             * Encodes the specified QueryAttestationsRequest message, length delimited. Does not implicitly {@link gravity.v1.QueryAttestationsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryAttestationsRequest
             * @static
             * @param {gravity.v1.IQueryAttestationsRequest} message QueryAttestationsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryAttestationsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryAttestationsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryAttestationsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryAttestationsRequest} QueryAttestationsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryAttestationsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryAttestationsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.limit = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryAttestationsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryAttestationsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryAttestationsRequest} QueryAttestationsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryAttestationsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryAttestationsRequest message.
             * @function verify
             * @memberof gravity.v1.QueryAttestationsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryAttestationsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                        return "limit: integer|Long expected";
                return null;
            };

            /**
             * Creates a QueryAttestationsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryAttestationsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryAttestationsRequest} QueryAttestationsRequest
             */
            QueryAttestationsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryAttestationsRequest)
                    return object;
                let message = new $root.gravity.v1.QueryAttestationsRequest();
                if (object.limit != null)
                    if ($util.Long)
                        (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                    else if (typeof object.limit === "string")
                        message.limit = parseInt(object.limit, 10);
                    else if (typeof object.limit === "number")
                        message.limit = object.limit;
                    else if (typeof object.limit === "object")
                        message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a QueryAttestationsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryAttestationsRequest
             * @static
             * @param {gravity.v1.QueryAttestationsRequest} message QueryAttestationsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryAttestationsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.limit = options.longs === String ? "0" : 0;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (typeof message.limit === "number")
                        object.limit = options.longs === String ? String(message.limit) : message.limit;
                    else
                        object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
                return object;
            };

            /**
             * Converts this QueryAttestationsRequest to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryAttestationsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryAttestationsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryAttestationsRequest;
        })();

        v1.QueryAttestationsResponse = (function() {

            /**
             * Properties of a QueryAttestationsResponse.
             * @memberof gravity.v1
             * @interface IQueryAttestationsResponse
             * @property {Array.<gravity.v1.IAttestation>|null} [attestations] QueryAttestationsResponse attestations
             */

            /**
             * Constructs a new QueryAttestationsResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryAttestationsResponse.
             * @implements IQueryAttestationsResponse
             * @constructor
             * @param {gravity.v1.IQueryAttestationsResponse=} [properties] Properties to set
             */
            function QueryAttestationsResponse(properties) {
                this.attestations = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryAttestationsResponse attestations.
             * @member {Array.<gravity.v1.IAttestation>} attestations
             * @memberof gravity.v1.QueryAttestationsResponse
             * @instance
             */
            QueryAttestationsResponse.prototype.attestations = $util.emptyArray;

            /**
             * Encodes the specified QueryAttestationsResponse message. Does not implicitly {@link gravity.v1.QueryAttestationsResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryAttestationsResponse
             * @static
             * @param {gravity.v1.IQueryAttestationsResponse} message QueryAttestationsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryAttestationsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.attestations != null && message.attestations.length)
                    for (let i = 0; i < message.attestations.length; ++i)
                        $root.gravity.v1.Attestation.encode(message.attestations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryAttestationsResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryAttestationsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryAttestationsResponse
             * @static
             * @param {gravity.v1.IQueryAttestationsResponse} message QueryAttestationsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryAttestationsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryAttestationsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryAttestationsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryAttestationsResponse} QueryAttestationsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryAttestationsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryAttestationsResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.attestations && message.attestations.length))
                            message.attestations = [];
                        message.attestations.push($root.gravity.v1.Attestation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryAttestationsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryAttestationsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryAttestationsResponse} QueryAttestationsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryAttestationsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryAttestationsResponse message.
             * @function verify
             * @memberof gravity.v1.QueryAttestationsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryAttestationsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.attestations != null && message.hasOwnProperty("attestations")) {
                    if (!Array.isArray(message.attestations))
                        return "attestations: array expected";
                    for (let i = 0; i < message.attestations.length; ++i) {
                        let error = $root.gravity.v1.Attestation.verify(message.attestations[i]);
                        if (error)
                            return "attestations." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryAttestationsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryAttestationsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryAttestationsResponse} QueryAttestationsResponse
             */
            QueryAttestationsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryAttestationsResponse)
                    return object;
                let message = new $root.gravity.v1.QueryAttestationsResponse();
                if (object.attestations) {
                    if (!Array.isArray(object.attestations))
                        throw TypeError(".gravity.v1.QueryAttestationsResponse.attestations: array expected");
                    message.attestations = [];
                    for (let i = 0; i < object.attestations.length; ++i) {
                        if (typeof object.attestations[i] !== "object")
                            throw TypeError(".gravity.v1.QueryAttestationsResponse.attestations: object expected");
                        message.attestations[i] = $root.gravity.v1.Attestation.fromObject(object.attestations[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryAttestationsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryAttestationsResponse
             * @static
             * @param {gravity.v1.QueryAttestationsResponse} message QueryAttestationsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryAttestationsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.attestations = [];
                if (message.attestations && message.attestations.length) {
                    object.attestations = [];
                    for (let j = 0; j < message.attestations.length; ++j)
                        object.attestations[j] = $root.gravity.v1.Attestation.toObject(message.attestations[j], options);
                }
                return object;
            };

            /**
             * Converts this QueryAttestationsResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryAttestationsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryAttestationsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryAttestationsResponse;
        })();

        v1.QueryDelegateKeysByValidatorAddress = (function() {

            /**
             * Properties of a QueryDelegateKeysByValidatorAddress.
             * @memberof gravity.v1
             * @interface IQueryDelegateKeysByValidatorAddress
             * @property {string|null} [validator_address] QueryDelegateKeysByValidatorAddress validator_address
             */

            /**
             * Constructs a new QueryDelegateKeysByValidatorAddress.
             * @memberof gravity.v1
             * @classdesc Represents a QueryDelegateKeysByValidatorAddress.
             * @implements IQueryDelegateKeysByValidatorAddress
             * @constructor
             * @param {gravity.v1.IQueryDelegateKeysByValidatorAddress=} [properties] Properties to set
             */
            function QueryDelegateKeysByValidatorAddress(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryDelegateKeysByValidatorAddress validator_address.
             * @member {string} validator_address
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
             * @instance
             */
            QueryDelegateKeysByValidatorAddress.prototype.validator_address = "";

            /**
             * Encodes the specified QueryDelegateKeysByValidatorAddress message. Does not implicitly {@link gravity.v1.QueryDelegateKeysByValidatorAddress.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
             * @static
             * @param {gravity.v1.IQueryDelegateKeysByValidatorAddress} message QueryDelegateKeysByValidatorAddress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDelegateKeysByValidatorAddress.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.validator_address != null && Object.hasOwnProperty.call(message, "validator_address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.validator_address);
                return writer;
            };

            /**
             * Encodes the specified QueryDelegateKeysByValidatorAddress message, length delimited. Does not implicitly {@link gravity.v1.QueryDelegateKeysByValidatorAddress.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
             * @static
             * @param {gravity.v1.IQueryDelegateKeysByValidatorAddress} message QueryDelegateKeysByValidatorAddress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDelegateKeysByValidatorAddress.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryDelegateKeysByValidatorAddress message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryDelegateKeysByValidatorAddress} QueryDelegateKeysByValidatorAddress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDelegateKeysByValidatorAddress.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDelegateKeysByValidatorAddress();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.validator_address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryDelegateKeysByValidatorAddress message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryDelegateKeysByValidatorAddress} QueryDelegateKeysByValidatorAddress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDelegateKeysByValidatorAddress.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryDelegateKeysByValidatorAddress message.
             * @function verify
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryDelegateKeysByValidatorAddress.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.validator_address != null && message.hasOwnProperty("validator_address"))
                    if (!$util.isString(message.validator_address))
                        return "validator_address: string expected";
                return null;
            };

            /**
             * Creates a QueryDelegateKeysByValidatorAddress message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryDelegateKeysByValidatorAddress} QueryDelegateKeysByValidatorAddress
             */
            QueryDelegateKeysByValidatorAddress.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryDelegateKeysByValidatorAddress)
                    return object;
                let message = new $root.gravity.v1.QueryDelegateKeysByValidatorAddress();
                if (object.validator_address != null)
                    message.validator_address = String(object.validator_address);
                return message;
            };

            /**
             * Creates a plain object from a QueryDelegateKeysByValidatorAddress message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
             * @static
             * @param {gravity.v1.QueryDelegateKeysByValidatorAddress} message QueryDelegateKeysByValidatorAddress
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryDelegateKeysByValidatorAddress.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.validator_address = "";
                if (message.validator_address != null && message.hasOwnProperty("validator_address"))
                    object.validator_address = message.validator_address;
                return object;
            };

            /**
             * Converts this QueryDelegateKeysByValidatorAddress to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddress
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryDelegateKeysByValidatorAddress.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryDelegateKeysByValidatorAddress;
        })();

        v1.QueryDelegateKeysByValidatorAddressResponse = (function() {

            /**
             * Properties of a QueryDelegateKeysByValidatorAddressResponse.
             * @memberof gravity.v1
             * @interface IQueryDelegateKeysByValidatorAddressResponse
             * @property {string|null} [eth_address] QueryDelegateKeysByValidatorAddressResponse eth_address
             * @property {string|null} [orchestrator_address] QueryDelegateKeysByValidatorAddressResponse orchestrator_address
             */

            /**
             * Constructs a new QueryDelegateKeysByValidatorAddressResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryDelegateKeysByValidatorAddressResponse.
             * @implements IQueryDelegateKeysByValidatorAddressResponse
             * @constructor
             * @param {gravity.v1.IQueryDelegateKeysByValidatorAddressResponse=} [properties] Properties to set
             */
            function QueryDelegateKeysByValidatorAddressResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryDelegateKeysByValidatorAddressResponse eth_address.
             * @member {string} eth_address
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
             * @instance
             */
            QueryDelegateKeysByValidatorAddressResponse.prototype.eth_address = "";

            /**
             * QueryDelegateKeysByValidatorAddressResponse orchestrator_address.
             * @member {string} orchestrator_address
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
             * @instance
             */
            QueryDelegateKeysByValidatorAddressResponse.prototype.orchestrator_address = "";

            /**
             * Encodes the specified QueryDelegateKeysByValidatorAddressResponse message. Does not implicitly {@link gravity.v1.QueryDelegateKeysByValidatorAddressResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
             * @static
             * @param {gravity.v1.IQueryDelegateKeysByValidatorAddressResponse} message QueryDelegateKeysByValidatorAddressResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDelegateKeysByValidatorAddressResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.eth_address != null && Object.hasOwnProperty.call(message, "eth_address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.eth_address);
                if (message.orchestrator_address != null && Object.hasOwnProperty.call(message, "orchestrator_address"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.orchestrator_address);
                return writer;
            };

            /**
             * Encodes the specified QueryDelegateKeysByValidatorAddressResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryDelegateKeysByValidatorAddressResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
             * @static
             * @param {gravity.v1.IQueryDelegateKeysByValidatorAddressResponse} message QueryDelegateKeysByValidatorAddressResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDelegateKeysByValidatorAddressResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryDelegateKeysByValidatorAddressResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryDelegateKeysByValidatorAddressResponse} QueryDelegateKeysByValidatorAddressResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDelegateKeysByValidatorAddressResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDelegateKeysByValidatorAddressResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.eth_address = reader.string();
                        break;
                    case 2:
                        message.orchestrator_address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryDelegateKeysByValidatorAddressResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryDelegateKeysByValidatorAddressResponse} QueryDelegateKeysByValidatorAddressResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDelegateKeysByValidatorAddressResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryDelegateKeysByValidatorAddressResponse message.
             * @function verify
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryDelegateKeysByValidatorAddressResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.eth_address != null && message.hasOwnProperty("eth_address"))
                    if (!$util.isString(message.eth_address))
                        return "eth_address: string expected";
                if (message.orchestrator_address != null && message.hasOwnProperty("orchestrator_address"))
                    if (!$util.isString(message.orchestrator_address))
                        return "orchestrator_address: string expected";
                return null;
            };

            /**
             * Creates a QueryDelegateKeysByValidatorAddressResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryDelegateKeysByValidatorAddressResponse} QueryDelegateKeysByValidatorAddressResponse
             */
            QueryDelegateKeysByValidatorAddressResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryDelegateKeysByValidatorAddressResponse)
                    return object;
                let message = new $root.gravity.v1.QueryDelegateKeysByValidatorAddressResponse();
                if (object.eth_address != null)
                    message.eth_address = String(object.eth_address);
                if (object.orchestrator_address != null)
                    message.orchestrator_address = String(object.orchestrator_address);
                return message;
            };

            /**
             * Creates a plain object from a QueryDelegateKeysByValidatorAddressResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
             * @static
             * @param {gravity.v1.QueryDelegateKeysByValidatorAddressResponse} message QueryDelegateKeysByValidatorAddressResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryDelegateKeysByValidatorAddressResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.eth_address = "";
                    object.orchestrator_address = "";
                }
                if (message.eth_address != null && message.hasOwnProperty("eth_address"))
                    object.eth_address = message.eth_address;
                if (message.orchestrator_address != null && message.hasOwnProperty("orchestrator_address"))
                    object.orchestrator_address = message.orchestrator_address;
                return object;
            };

            /**
             * Converts this QueryDelegateKeysByValidatorAddressResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryDelegateKeysByValidatorAddressResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryDelegateKeysByValidatorAddressResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryDelegateKeysByValidatorAddressResponse;
        })();

        v1.QueryDelegateKeysByEthAddress = (function() {

            /**
             * Properties of a QueryDelegateKeysByEthAddress.
             * @memberof gravity.v1
             * @interface IQueryDelegateKeysByEthAddress
             * @property {string|null} [eth_address] QueryDelegateKeysByEthAddress eth_address
             */

            /**
             * Constructs a new QueryDelegateKeysByEthAddress.
             * @memberof gravity.v1
             * @classdesc Represents a QueryDelegateKeysByEthAddress.
             * @implements IQueryDelegateKeysByEthAddress
             * @constructor
             * @param {gravity.v1.IQueryDelegateKeysByEthAddress=} [properties] Properties to set
             */
            function QueryDelegateKeysByEthAddress(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryDelegateKeysByEthAddress eth_address.
             * @member {string} eth_address
             * @memberof gravity.v1.QueryDelegateKeysByEthAddress
             * @instance
             */
            QueryDelegateKeysByEthAddress.prototype.eth_address = "";

            /**
             * Encodes the specified QueryDelegateKeysByEthAddress message. Does not implicitly {@link gravity.v1.QueryDelegateKeysByEthAddress.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryDelegateKeysByEthAddress
             * @static
             * @param {gravity.v1.IQueryDelegateKeysByEthAddress} message QueryDelegateKeysByEthAddress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDelegateKeysByEthAddress.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.eth_address != null && Object.hasOwnProperty.call(message, "eth_address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.eth_address);
                return writer;
            };

            /**
             * Encodes the specified QueryDelegateKeysByEthAddress message, length delimited. Does not implicitly {@link gravity.v1.QueryDelegateKeysByEthAddress.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryDelegateKeysByEthAddress
             * @static
             * @param {gravity.v1.IQueryDelegateKeysByEthAddress} message QueryDelegateKeysByEthAddress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDelegateKeysByEthAddress.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryDelegateKeysByEthAddress message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryDelegateKeysByEthAddress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryDelegateKeysByEthAddress} QueryDelegateKeysByEthAddress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDelegateKeysByEthAddress.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDelegateKeysByEthAddress();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.eth_address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryDelegateKeysByEthAddress message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryDelegateKeysByEthAddress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryDelegateKeysByEthAddress} QueryDelegateKeysByEthAddress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDelegateKeysByEthAddress.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryDelegateKeysByEthAddress message.
             * @function verify
             * @memberof gravity.v1.QueryDelegateKeysByEthAddress
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryDelegateKeysByEthAddress.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.eth_address != null && message.hasOwnProperty("eth_address"))
                    if (!$util.isString(message.eth_address))
                        return "eth_address: string expected";
                return null;
            };

            /**
             * Creates a QueryDelegateKeysByEthAddress message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryDelegateKeysByEthAddress
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryDelegateKeysByEthAddress} QueryDelegateKeysByEthAddress
             */
            QueryDelegateKeysByEthAddress.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryDelegateKeysByEthAddress)
                    return object;
                let message = new $root.gravity.v1.QueryDelegateKeysByEthAddress();
                if (object.eth_address != null)
                    message.eth_address = String(object.eth_address);
                return message;
            };

            /**
             * Creates a plain object from a QueryDelegateKeysByEthAddress message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryDelegateKeysByEthAddress
             * @static
             * @param {gravity.v1.QueryDelegateKeysByEthAddress} message QueryDelegateKeysByEthAddress
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryDelegateKeysByEthAddress.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.eth_address = "";
                if (message.eth_address != null && message.hasOwnProperty("eth_address"))
                    object.eth_address = message.eth_address;
                return object;
            };

            /**
             * Converts this QueryDelegateKeysByEthAddress to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryDelegateKeysByEthAddress
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryDelegateKeysByEthAddress.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryDelegateKeysByEthAddress;
        })();

        v1.QueryDelegateKeysByEthAddressResponse = (function() {

            /**
             * Properties of a QueryDelegateKeysByEthAddressResponse.
             * @memberof gravity.v1
             * @interface IQueryDelegateKeysByEthAddressResponse
             * @property {string|null} [validator_address] QueryDelegateKeysByEthAddressResponse validator_address
             * @property {string|null} [orchestrator_address] QueryDelegateKeysByEthAddressResponse orchestrator_address
             */

            /**
             * Constructs a new QueryDelegateKeysByEthAddressResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryDelegateKeysByEthAddressResponse.
             * @implements IQueryDelegateKeysByEthAddressResponse
             * @constructor
             * @param {gravity.v1.IQueryDelegateKeysByEthAddressResponse=} [properties] Properties to set
             */
            function QueryDelegateKeysByEthAddressResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryDelegateKeysByEthAddressResponse validator_address.
             * @member {string} validator_address
             * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
             * @instance
             */
            QueryDelegateKeysByEthAddressResponse.prototype.validator_address = "";

            /**
             * QueryDelegateKeysByEthAddressResponse orchestrator_address.
             * @member {string} orchestrator_address
             * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
             * @instance
             */
            QueryDelegateKeysByEthAddressResponse.prototype.orchestrator_address = "";

            /**
             * Encodes the specified QueryDelegateKeysByEthAddressResponse message. Does not implicitly {@link gravity.v1.QueryDelegateKeysByEthAddressResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
             * @static
             * @param {gravity.v1.IQueryDelegateKeysByEthAddressResponse} message QueryDelegateKeysByEthAddressResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDelegateKeysByEthAddressResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.validator_address != null && Object.hasOwnProperty.call(message, "validator_address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.validator_address);
                if (message.orchestrator_address != null && Object.hasOwnProperty.call(message, "orchestrator_address"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.orchestrator_address);
                return writer;
            };

            /**
             * Encodes the specified QueryDelegateKeysByEthAddressResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryDelegateKeysByEthAddressResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
             * @static
             * @param {gravity.v1.IQueryDelegateKeysByEthAddressResponse} message QueryDelegateKeysByEthAddressResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDelegateKeysByEthAddressResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryDelegateKeysByEthAddressResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryDelegateKeysByEthAddressResponse} QueryDelegateKeysByEthAddressResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDelegateKeysByEthAddressResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDelegateKeysByEthAddressResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.validator_address = reader.string();
                        break;
                    case 2:
                        message.orchestrator_address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryDelegateKeysByEthAddressResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryDelegateKeysByEthAddressResponse} QueryDelegateKeysByEthAddressResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDelegateKeysByEthAddressResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryDelegateKeysByEthAddressResponse message.
             * @function verify
             * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryDelegateKeysByEthAddressResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.validator_address != null && message.hasOwnProperty("validator_address"))
                    if (!$util.isString(message.validator_address))
                        return "validator_address: string expected";
                if (message.orchestrator_address != null && message.hasOwnProperty("orchestrator_address"))
                    if (!$util.isString(message.orchestrator_address))
                        return "orchestrator_address: string expected";
                return null;
            };

            /**
             * Creates a QueryDelegateKeysByEthAddressResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryDelegateKeysByEthAddressResponse} QueryDelegateKeysByEthAddressResponse
             */
            QueryDelegateKeysByEthAddressResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryDelegateKeysByEthAddressResponse)
                    return object;
                let message = new $root.gravity.v1.QueryDelegateKeysByEthAddressResponse();
                if (object.validator_address != null)
                    message.validator_address = String(object.validator_address);
                if (object.orchestrator_address != null)
                    message.orchestrator_address = String(object.orchestrator_address);
                return message;
            };

            /**
             * Creates a plain object from a QueryDelegateKeysByEthAddressResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
             * @static
             * @param {gravity.v1.QueryDelegateKeysByEthAddressResponse} message QueryDelegateKeysByEthAddressResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryDelegateKeysByEthAddressResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.validator_address = "";
                    object.orchestrator_address = "";
                }
                if (message.validator_address != null && message.hasOwnProperty("validator_address"))
                    object.validator_address = message.validator_address;
                if (message.orchestrator_address != null && message.hasOwnProperty("orchestrator_address"))
                    object.orchestrator_address = message.orchestrator_address;
                return object;
            };

            /**
             * Converts this QueryDelegateKeysByEthAddressResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryDelegateKeysByEthAddressResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryDelegateKeysByEthAddressResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryDelegateKeysByEthAddressResponse;
        })();

        v1.QueryDelegateKeysByOrchestratorAddress = (function() {

            /**
             * Properties of a QueryDelegateKeysByOrchestratorAddress.
             * @memberof gravity.v1
             * @interface IQueryDelegateKeysByOrchestratorAddress
             * @property {string|null} [orchestrator_address] QueryDelegateKeysByOrchestratorAddress orchestrator_address
             */

            /**
             * Constructs a new QueryDelegateKeysByOrchestratorAddress.
             * @memberof gravity.v1
             * @classdesc Represents a QueryDelegateKeysByOrchestratorAddress.
             * @implements IQueryDelegateKeysByOrchestratorAddress
             * @constructor
             * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddress=} [properties] Properties to set
             */
            function QueryDelegateKeysByOrchestratorAddress(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryDelegateKeysByOrchestratorAddress orchestrator_address.
             * @member {string} orchestrator_address
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
             * @instance
             */
            QueryDelegateKeysByOrchestratorAddress.prototype.orchestrator_address = "";

            /**
             * Encodes the specified QueryDelegateKeysByOrchestratorAddress message. Does not implicitly {@link gravity.v1.QueryDelegateKeysByOrchestratorAddress.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
             * @static
             * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddress} message QueryDelegateKeysByOrchestratorAddress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDelegateKeysByOrchestratorAddress.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.orchestrator_address != null && Object.hasOwnProperty.call(message, "orchestrator_address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.orchestrator_address);
                return writer;
            };

            /**
             * Encodes the specified QueryDelegateKeysByOrchestratorAddress message, length delimited. Does not implicitly {@link gravity.v1.QueryDelegateKeysByOrchestratorAddress.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
             * @static
             * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddress} message QueryDelegateKeysByOrchestratorAddress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDelegateKeysByOrchestratorAddress.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryDelegateKeysByOrchestratorAddress message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryDelegateKeysByOrchestratorAddress} QueryDelegateKeysByOrchestratorAddress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDelegateKeysByOrchestratorAddress.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDelegateKeysByOrchestratorAddress();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.orchestrator_address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryDelegateKeysByOrchestratorAddress message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryDelegateKeysByOrchestratorAddress} QueryDelegateKeysByOrchestratorAddress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDelegateKeysByOrchestratorAddress.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryDelegateKeysByOrchestratorAddress message.
             * @function verify
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryDelegateKeysByOrchestratorAddress.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.orchestrator_address != null && message.hasOwnProperty("orchestrator_address"))
                    if (!$util.isString(message.orchestrator_address))
                        return "orchestrator_address: string expected";
                return null;
            };

            /**
             * Creates a QueryDelegateKeysByOrchestratorAddress message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryDelegateKeysByOrchestratorAddress} QueryDelegateKeysByOrchestratorAddress
             */
            QueryDelegateKeysByOrchestratorAddress.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryDelegateKeysByOrchestratorAddress)
                    return object;
                let message = new $root.gravity.v1.QueryDelegateKeysByOrchestratorAddress();
                if (object.orchestrator_address != null)
                    message.orchestrator_address = String(object.orchestrator_address);
                return message;
            };

            /**
             * Creates a plain object from a QueryDelegateKeysByOrchestratorAddress message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
             * @static
             * @param {gravity.v1.QueryDelegateKeysByOrchestratorAddress} message QueryDelegateKeysByOrchestratorAddress
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryDelegateKeysByOrchestratorAddress.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.orchestrator_address = "";
                if (message.orchestrator_address != null && message.hasOwnProperty("orchestrator_address"))
                    object.orchestrator_address = message.orchestrator_address;
                return object;
            };

            /**
             * Converts this QueryDelegateKeysByOrchestratorAddress to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddress
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryDelegateKeysByOrchestratorAddress.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryDelegateKeysByOrchestratorAddress;
        })();

        v1.QueryDelegateKeysByOrchestratorAddressResponse = (function() {

            /**
             * Properties of a QueryDelegateKeysByOrchestratorAddressResponse.
             * @memberof gravity.v1
             * @interface IQueryDelegateKeysByOrchestratorAddressResponse
             * @property {string|null} [validator_address] QueryDelegateKeysByOrchestratorAddressResponse validator_address
             * @property {string|null} [eth_address] QueryDelegateKeysByOrchestratorAddressResponse eth_address
             */

            /**
             * Constructs a new QueryDelegateKeysByOrchestratorAddressResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryDelegateKeysByOrchestratorAddressResponse.
             * @implements IQueryDelegateKeysByOrchestratorAddressResponse
             * @constructor
             * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddressResponse=} [properties] Properties to set
             */
            function QueryDelegateKeysByOrchestratorAddressResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryDelegateKeysByOrchestratorAddressResponse validator_address.
             * @member {string} validator_address
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
             * @instance
             */
            QueryDelegateKeysByOrchestratorAddressResponse.prototype.validator_address = "";

            /**
             * QueryDelegateKeysByOrchestratorAddressResponse eth_address.
             * @member {string} eth_address
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
             * @instance
             */
            QueryDelegateKeysByOrchestratorAddressResponse.prototype.eth_address = "";

            /**
             * Encodes the specified QueryDelegateKeysByOrchestratorAddressResponse message. Does not implicitly {@link gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
             * @static
             * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddressResponse} message QueryDelegateKeysByOrchestratorAddressResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDelegateKeysByOrchestratorAddressResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.validator_address != null && Object.hasOwnProperty.call(message, "validator_address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.validator_address);
                if (message.eth_address != null && Object.hasOwnProperty.call(message, "eth_address"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.eth_address);
                return writer;
            };

            /**
             * Encodes the specified QueryDelegateKeysByOrchestratorAddressResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
             * @static
             * @param {gravity.v1.IQueryDelegateKeysByOrchestratorAddressResponse} message QueryDelegateKeysByOrchestratorAddressResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryDelegateKeysByOrchestratorAddressResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryDelegateKeysByOrchestratorAddressResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse} QueryDelegateKeysByOrchestratorAddressResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDelegateKeysByOrchestratorAddressResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.validator_address = reader.string();
                        break;
                    case 2:
                        message.eth_address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryDelegateKeysByOrchestratorAddressResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse} QueryDelegateKeysByOrchestratorAddressResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryDelegateKeysByOrchestratorAddressResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryDelegateKeysByOrchestratorAddressResponse message.
             * @function verify
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryDelegateKeysByOrchestratorAddressResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.validator_address != null && message.hasOwnProperty("validator_address"))
                    if (!$util.isString(message.validator_address))
                        return "validator_address: string expected";
                if (message.eth_address != null && message.hasOwnProperty("eth_address"))
                    if (!$util.isString(message.eth_address))
                        return "eth_address: string expected";
                return null;
            };

            /**
             * Creates a QueryDelegateKeysByOrchestratorAddressResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse} QueryDelegateKeysByOrchestratorAddressResponse
             */
            QueryDelegateKeysByOrchestratorAddressResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse)
                    return object;
                let message = new $root.gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse();
                if (object.validator_address != null)
                    message.validator_address = String(object.validator_address);
                if (object.eth_address != null)
                    message.eth_address = String(object.eth_address);
                return message;
            };

            /**
             * Creates a plain object from a QueryDelegateKeysByOrchestratorAddressResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
             * @static
             * @param {gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse} message QueryDelegateKeysByOrchestratorAddressResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryDelegateKeysByOrchestratorAddressResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.validator_address = "";
                    object.eth_address = "";
                }
                if (message.validator_address != null && message.hasOwnProperty("validator_address"))
                    object.validator_address = message.validator_address;
                if (message.eth_address != null && message.hasOwnProperty("eth_address"))
                    object.eth_address = message.eth_address;
                return object;
            };

            /**
             * Converts this QueryDelegateKeysByOrchestratorAddressResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryDelegateKeysByOrchestratorAddressResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryDelegateKeysByOrchestratorAddressResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryDelegateKeysByOrchestratorAddressResponse;
        })();

        v1.QueryPendingSendToEth = (function() {

            /**
             * Properties of a QueryPendingSendToEth.
             * @memberof gravity.v1
             * @interface IQueryPendingSendToEth
             * @property {string|null} [sender_address] QueryPendingSendToEth sender_address
             */

            /**
             * Constructs a new QueryPendingSendToEth.
             * @memberof gravity.v1
             * @classdesc Represents a QueryPendingSendToEth.
             * @implements IQueryPendingSendToEth
             * @constructor
             * @param {gravity.v1.IQueryPendingSendToEth=} [properties] Properties to set
             */
            function QueryPendingSendToEth(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryPendingSendToEth sender_address.
             * @member {string} sender_address
             * @memberof gravity.v1.QueryPendingSendToEth
             * @instance
             */
            QueryPendingSendToEth.prototype.sender_address = "";

            /**
             * Encodes the specified QueryPendingSendToEth message. Does not implicitly {@link gravity.v1.QueryPendingSendToEth.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryPendingSendToEth
             * @static
             * @param {gravity.v1.IQueryPendingSendToEth} message QueryPendingSendToEth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryPendingSendToEth.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sender_address != null && Object.hasOwnProperty.call(message, "sender_address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender_address);
                return writer;
            };

            /**
             * Encodes the specified QueryPendingSendToEth message, length delimited. Does not implicitly {@link gravity.v1.QueryPendingSendToEth.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryPendingSendToEth
             * @static
             * @param {gravity.v1.IQueryPendingSendToEth} message QueryPendingSendToEth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryPendingSendToEth.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryPendingSendToEth message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryPendingSendToEth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryPendingSendToEth} QueryPendingSendToEth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryPendingSendToEth.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryPendingSendToEth();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sender_address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryPendingSendToEth message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryPendingSendToEth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryPendingSendToEth} QueryPendingSendToEth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryPendingSendToEth.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryPendingSendToEth message.
             * @function verify
             * @memberof gravity.v1.QueryPendingSendToEth
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryPendingSendToEth.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sender_address != null && message.hasOwnProperty("sender_address"))
                    if (!$util.isString(message.sender_address))
                        return "sender_address: string expected";
                return null;
            };

            /**
             * Creates a QueryPendingSendToEth message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryPendingSendToEth
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryPendingSendToEth} QueryPendingSendToEth
             */
            QueryPendingSendToEth.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryPendingSendToEth)
                    return object;
                let message = new $root.gravity.v1.QueryPendingSendToEth();
                if (object.sender_address != null)
                    message.sender_address = String(object.sender_address);
                return message;
            };

            /**
             * Creates a plain object from a QueryPendingSendToEth message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryPendingSendToEth
             * @static
             * @param {gravity.v1.QueryPendingSendToEth} message QueryPendingSendToEth
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryPendingSendToEth.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.sender_address = "";
                if (message.sender_address != null && message.hasOwnProperty("sender_address"))
                    object.sender_address = message.sender_address;
                return object;
            };

            /**
             * Converts this QueryPendingSendToEth to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryPendingSendToEth
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryPendingSendToEth.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryPendingSendToEth;
        })();

        v1.QueryPendingSendToEthResponse = (function() {

            /**
             * Properties of a QueryPendingSendToEthResponse.
             * @memberof gravity.v1
             * @interface IQueryPendingSendToEthResponse
             * @property {Array.<gravity.v1.IOutgoingTransferTx>|null} [transfers_in_batches] QueryPendingSendToEthResponse transfers_in_batches
             * @property {Array.<gravity.v1.IOutgoingTransferTx>|null} [unbatched_transfers] QueryPendingSendToEthResponse unbatched_transfers
             */

            /**
             * Constructs a new QueryPendingSendToEthResponse.
             * @memberof gravity.v1
             * @classdesc Represents a QueryPendingSendToEthResponse.
             * @implements IQueryPendingSendToEthResponse
             * @constructor
             * @param {gravity.v1.IQueryPendingSendToEthResponse=} [properties] Properties to set
             */
            function QueryPendingSendToEthResponse(properties) {
                this.transfers_in_batches = [];
                this.unbatched_transfers = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryPendingSendToEthResponse transfers_in_batches.
             * @member {Array.<gravity.v1.IOutgoingTransferTx>} transfers_in_batches
             * @memberof gravity.v1.QueryPendingSendToEthResponse
             * @instance
             */
            QueryPendingSendToEthResponse.prototype.transfers_in_batches = $util.emptyArray;

            /**
             * QueryPendingSendToEthResponse unbatched_transfers.
             * @member {Array.<gravity.v1.IOutgoingTransferTx>} unbatched_transfers
             * @memberof gravity.v1.QueryPendingSendToEthResponse
             * @instance
             */
            QueryPendingSendToEthResponse.prototype.unbatched_transfers = $util.emptyArray;

            /**
             * Encodes the specified QueryPendingSendToEthResponse message. Does not implicitly {@link gravity.v1.QueryPendingSendToEthResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.QueryPendingSendToEthResponse
             * @static
             * @param {gravity.v1.IQueryPendingSendToEthResponse} message QueryPendingSendToEthResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryPendingSendToEthResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.transfers_in_batches != null && message.transfers_in_batches.length)
                    for (let i = 0; i < message.transfers_in_batches.length; ++i)
                        $root.gravity.v1.OutgoingTransferTx.encode(message.transfers_in_batches[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.unbatched_transfers != null && message.unbatched_transfers.length)
                    for (let i = 0; i < message.unbatched_transfers.length; ++i)
                        $root.gravity.v1.OutgoingTransferTx.encode(message.unbatched_transfers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryPendingSendToEthResponse message, length delimited. Does not implicitly {@link gravity.v1.QueryPendingSendToEthResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.QueryPendingSendToEthResponse
             * @static
             * @param {gravity.v1.IQueryPendingSendToEthResponse} message QueryPendingSendToEthResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryPendingSendToEthResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryPendingSendToEthResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.QueryPendingSendToEthResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.QueryPendingSendToEthResponse} QueryPendingSendToEthResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryPendingSendToEthResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.QueryPendingSendToEthResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.transfers_in_batches && message.transfers_in_batches.length))
                            message.transfers_in_batches = [];
                        message.transfers_in_batches.push($root.gravity.v1.OutgoingTransferTx.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.unbatched_transfers && message.unbatched_transfers.length))
                            message.unbatched_transfers = [];
                        message.unbatched_transfers.push($root.gravity.v1.OutgoingTransferTx.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryPendingSendToEthResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.QueryPendingSendToEthResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.QueryPendingSendToEthResponse} QueryPendingSendToEthResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryPendingSendToEthResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryPendingSendToEthResponse message.
             * @function verify
             * @memberof gravity.v1.QueryPendingSendToEthResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryPendingSendToEthResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.transfers_in_batches != null && message.hasOwnProperty("transfers_in_batches")) {
                    if (!Array.isArray(message.transfers_in_batches))
                        return "transfers_in_batches: array expected";
                    for (let i = 0; i < message.transfers_in_batches.length; ++i) {
                        let error = $root.gravity.v1.OutgoingTransferTx.verify(message.transfers_in_batches[i]);
                        if (error)
                            return "transfers_in_batches." + error;
                    }
                }
                if (message.unbatched_transfers != null && message.hasOwnProperty("unbatched_transfers")) {
                    if (!Array.isArray(message.unbatched_transfers))
                        return "unbatched_transfers: array expected";
                    for (let i = 0; i < message.unbatched_transfers.length; ++i) {
                        let error = $root.gravity.v1.OutgoingTransferTx.verify(message.unbatched_transfers[i]);
                        if (error)
                            return "unbatched_transfers." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryPendingSendToEthResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.QueryPendingSendToEthResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.QueryPendingSendToEthResponse} QueryPendingSendToEthResponse
             */
            QueryPendingSendToEthResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.QueryPendingSendToEthResponse)
                    return object;
                let message = new $root.gravity.v1.QueryPendingSendToEthResponse();
                if (object.transfers_in_batches) {
                    if (!Array.isArray(object.transfers_in_batches))
                        throw TypeError(".gravity.v1.QueryPendingSendToEthResponse.transfers_in_batches: array expected");
                    message.transfers_in_batches = [];
                    for (let i = 0; i < object.transfers_in_batches.length; ++i) {
                        if (typeof object.transfers_in_batches[i] !== "object")
                            throw TypeError(".gravity.v1.QueryPendingSendToEthResponse.transfers_in_batches: object expected");
                        message.transfers_in_batches[i] = $root.gravity.v1.OutgoingTransferTx.fromObject(object.transfers_in_batches[i]);
                    }
                }
                if (object.unbatched_transfers) {
                    if (!Array.isArray(object.unbatched_transfers))
                        throw TypeError(".gravity.v1.QueryPendingSendToEthResponse.unbatched_transfers: array expected");
                    message.unbatched_transfers = [];
                    for (let i = 0; i < object.unbatched_transfers.length; ++i) {
                        if (typeof object.unbatched_transfers[i] !== "object")
                            throw TypeError(".gravity.v1.QueryPendingSendToEthResponse.unbatched_transfers: object expected");
                        message.unbatched_transfers[i] = $root.gravity.v1.OutgoingTransferTx.fromObject(object.unbatched_transfers[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryPendingSendToEthResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.QueryPendingSendToEthResponse
             * @static
             * @param {gravity.v1.QueryPendingSendToEthResponse} message QueryPendingSendToEthResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryPendingSendToEthResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.transfers_in_batches = [];
                    object.unbatched_transfers = [];
                }
                if (message.transfers_in_batches && message.transfers_in_batches.length) {
                    object.transfers_in_batches = [];
                    for (let j = 0; j < message.transfers_in_batches.length; ++j)
                        object.transfers_in_batches[j] = $root.gravity.v1.OutgoingTransferTx.toObject(message.transfers_in_batches[j], options);
                }
                if (message.unbatched_transfers && message.unbatched_transfers.length) {
                    object.unbatched_transfers = [];
                    for (let j = 0; j < message.unbatched_transfers.length; ++j)
                        object.unbatched_transfers[j] = $root.gravity.v1.OutgoingTransferTx.toObject(message.unbatched_transfers[j], options);
                }
                return object;
            };

            /**
             * Converts this QueryPendingSendToEthResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.QueryPendingSendToEthResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryPendingSendToEthResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryPendingSendToEthResponse;
        })();

        v1.Params = (function() {

            /**
             * Properties of a Params.
             * @memberof gravity.v1
             * @interface IParams
             * @property {string|null} [gravity_id] Params gravity_id
             * @property {string|null} [contract_source_hash] Params contract_source_hash
             * @property {string|null} [bridge_ethereum_address] Params bridge_ethereum_address
             * @property {Long|null} [bridge_chain_id] Params bridge_chain_id
             * @property {Long|null} [signed_valsets_window] Params signed_valsets_window
             * @property {Long|null} [signed_batches_window] Params signed_batches_window
             * @property {Long|null} [signed_logic_calls_window] Params signed_logic_calls_window
             * @property {Long|null} [target_batch_timeout] Params target_batch_timeout
             * @property {Long|null} [average_block_time] Params average_block_time
             * @property {Long|null} [average_ethereum_block_time] Params average_ethereum_block_time
             * @property {Uint8Array|null} [slash_fraction_valset] Params slash_fraction_valset
             * @property {Uint8Array|null} [slash_fraction_batch] Params slash_fraction_batch
             * @property {Uint8Array|null} [slash_fraction_logic_call] Params slash_fraction_logic_call
             * @property {Long|null} [unbond_slashing_valsets_window] Params unbond_slashing_valsets_window
             * @property {Uint8Array|null} [slash_fraction_bad_eth_signature] Params slash_fraction_bad_eth_signature
             * @property {cosmos.base.v1beta1.ICoin|null} [valset_reward] Params valset_reward
             * @property {boolean|null} [bridge_active] Params bridge_active
             * @property {Array.<string>|null} [ethereum_blacklist] Params ethereum_blacklist
             */

            /**
             * Constructs a new Params.
             * @memberof gravity.v1
             * @classdesc Represents a Params.
             * @implements IParams
             * @constructor
             * @param {gravity.v1.IParams=} [properties] Properties to set
             */
            function Params(properties) {
                this.ethereum_blacklist = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Params gravity_id.
             * @member {string} gravity_id
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.gravity_id = "";

            /**
             * Params contract_source_hash.
             * @member {string} contract_source_hash
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.contract_source_hash = "";

            /**
             * Params bridge_ethereum_address.
             * @member {string} bridge_ethereum_address
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.bridge_ethereum_address = "";

            /**
             * Params bridge_chain_id.
             * @member {Long} bridge_chain_id
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.bridge_chain_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Params signed_valsets_window.
             * @member {Long} signed_valsets_window
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.signed_valsets_window = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Params signed_batches_window.
             * @member {Long} signed_batches_window
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.signed_batches_window = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Params signed_logic_calls_window.
             * @member {Long} signed_logic_calls_window
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.signed_logic_calls_window = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Params target_batch_timeout.
             * @member {Long} target_batch_timeout
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.target_batch_timeout = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Params average_block_time.
             * @member {Long} average_block_time
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.average_block_time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Params average_ethereum_block_time.
             * @member {Long} average_ethereum_block_time
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.average_ethereum_block_time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Params slash_fraction_valset.
             * @member {Uint8Array} slash_fraction_valset
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.slash_fraction_valset = $util.newBuffer([]);

            /**
             * Params slash_fraction_batch.
             * @member {Uint8Array} slash_fraction_batch
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.slash_fraction_batch = $util.newBuffer([]);

            /**
             * Params slash_fraction_logic_call.
             * @member {Uint8Array} slash_fraction_logic_call
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.slash_fraction_logic_call = $util.newBuffer([]);

            /**
             * Params unbond_slashing_valsets_window.
             * @member {Long} unbond_slashing_valsets_window
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.unbond_slashing_valsets_window = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Params slash_fraction_bad_eth_signature.
             * @member {Uint8Array} slash_fraction_bad_eth_signature
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.slash_fraction_bad_eth_signature = $util.newBuffer([]);

            /**
             * Params valset_reward.
             * @member {cosmos.base.v1beta1.ICoin|null|undefined} valset_reward
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.valset_reward = null;

            /**
             * Params bridge_active.
             * @member {boolean} bridge_active
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.bridge_active = false;

            /**
             * Params ethereum_blacklist.
             * @member {Array.<string>} ethereum_blacklist
             * @memberof gravity.v1.Params
             * @instance
             */
            Params.prototype.ethereum_blacklist = $util.emptyArray;

            /**
             * Encodes the specified Params message. Does not implicitly {@link gravity.v1.Params.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.Params
             * @static
             * @param {gravity.v1.IParams} message Params message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Params.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.gravity_id != null && Object.hasOwnProperty.call(message, "gravity_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.gravity_id);
                if (message.contract_source_hash != null && Object.hasOwnProperty.call(message, "contract_source_hash"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.contract_source_hash);
                if (message.bridge_ethereum_address != null && Object.hasOwnProperty.call(message, "bridge_ethereum_address"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.bridge_ethereum_address);
                if (message.bridge_chain_id != null && Object.hasOwnProperty.call(message, "bridge_chain_id"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.bridge_chain_id);
                if (message.signed_valsets_window != null && Object.hasOwnProperty.call(message, "signed_valsets_window"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.signed_valsets_window);
                if (message.signed_batches_window != null && Object.hasOwnProperty.call(message, "signed_batches_window"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.signed_batches_window);
                if (message.signed_logic_calls_window != null && Object.hasOwnProperty.call(message, "signed_logic_calls_window"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.signed_logic_calls_window);
                if (message.target_batch_timeout != null && Object.hasOwnProperty.call(message, "target_batch_timeout"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.target_batch_timeout);
                if (message.average_block_time != null && Object.hasOwnProperty.call(message, "average_block_time"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.average_block_time);
                if (message.average_ethereum_block_time != null && Object.hasOwnProperty.call(message, "average_ethereum_block_time"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.average_ethereum_block_time);
                if (message.slash_fraction_valset != null && Object.hasOwnProperty.call(message, "slash_fraction_valset"))
                    writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.slash_fraction_valset);
                if (message.slash_fraction_batch != null && Object.hasOwnProperty.call(message, "slash_fraction_batch"))
                    writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.slash_fraction_batch);
                if (message.slash_fraction_logic_call != null && Object.hasOwnProperty.call(message, "slash_fraction_logic_call"))
                    writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.slash_fraction_logic_call);
                if (message.unbond_slashing_valsets_window != null && Object.hasOwnProperty.call(message, "unbond_slashing_valsets_window"))
                    writer.uint32(/* id 15, wireType 0 =*/120).uint64(message.unbond_slashing_valsets_window);
                if (message.slash_fraction_bad_eth_signature != null && Object.hasOwnProperty.call(message, "slash_fraction_bad_eth_signature"))
                    writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.slash_fraction_bad_eth_signature);
                if (message.valset_reward != null && Object.hasOwnProperty.call(message, "valset_reward"))
                    $root.cosmos.base.v1beta1.Coin.encode(message.valset_reward, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.bridge_active != null && Object.hasOwnProperty.call(message, "bridge_active"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.bridge_active);
                if (message.ethereum_blacklist != null && message.ethereum_blacklist.length)
                    for (let i = 0; i < message.ethereum_blacklist.length; ++i)
                        writer.uint32(/* id 19, wireType 2 =*/154).string(message.ethereum_blacklist[i]);
                return writer;
            };

            /**
             * Encodes the specified Params message, length delimited. Does not implicitly {@link gravity.v1.Params.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.Params
             * @static
             * @param {gravity.v1.IParams} message Params message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Params.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Params message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.Params
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.Params} Params
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Params.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.Params();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.gravity_id = reader.string();
                        break;
                    case 2:
                        message.contract_source_hash = reader.string();
                        break;
                    case 4:
                        message.bridge_ethereum_address = reader.string();
                        break;
                    case 5:
                        message.bridge_chain_id = reader.uint64();
                        break;
                    case 6:
                        message.signed_valsets_window = reader.uint64();
                        break;
                    case 7:
                        message.signed_batches_window = reader.uint64();
                        break;
                    case 8:
                        message.signed_logic_calls_window = reader.uint64();
                        break;
                    case 9:
                        message.target_batch_timeout = reader.uint64();
                        break;
                    case 10:
                        message.average_block_time = reader.uint64();
                        break;
                    case 11:
                        message.average_ethereum_block_time = reader.uint64();
                        break;
                    case 12:
                        message.slash_fraction_valset = reader.bytes();
                        break;
                    case 13:
                        message.slash_fraction_batch = reader.bytes();
                        break;
                    case 14:
                        message.slash_fraction_logic_call = reader.bytes();
                        break;
                    case 15:
                        message.unbond_slashing_valsets_window = reader.uint64();
                        break;
                    case 16:
                        message.slash_fraction_bad_eth_signature = reader.bytes();
                        break;
                    case 17:
                        message.valset_reward = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.bridge_active = reader.bool();
                        break;
                    case 19:
                        if (!(message.ethereum_blacklist && message.ethereum_blacklist.length))
                            message.ethereum_blacklist = [];
                        message.ethereum_blacklist.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Params message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.Params
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.Params} Params
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Params.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Params message.
             * @function verify
             * @memberof gravity.v1.Params
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Params.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.gravity_id != null && message.hasOwnProperty("gravity_id"))
                    if (!$util.isString(message.gravity_id))
                        return "gravity_id: string expected";
                if (message.contract_source_hash != null && message.hasOwnProperty("contract_source_hash"))
                    if (!$util.isString(message.contract_source_hash))
                        return "contract_source_hash: string expected";
                if (message.bridge_ethereum_address != null && message.hasOwnProperty("bridge_ethereum_address"))
                    if (!$util.isString(message.bridge_ethereum_address))
                        return "bridge_ethereum_address: string expected";
                if (message.bridge_chain_id != null && message.hasOwnProperty("bridge_chain_id"))
                    if (!$util.isInteger(message.bridge_chain_id) && !(message.bridge_chain_id && $util.isInteger(message.bridge_chain_id.low) && $util.isInteger(message.bridge_chain_id.high)))
                        return "bridge_chain_id: integer|Long expected";
                if (message.signed_valsets_window != null && message.hasOwnProperty("signed_valsets_window"))
                    if (!$util.isInteger(message.signed_valsets_window) && !(message.signed_valsets_window && $util.isInteger(message.signed_valsets_window.low) && $util.isInteger(message.signed_valsets_window.high)))
                        return "signed_valsets_window: integer|Long expected";
                if (message.signed_batches_window != null && message.hasOwnProperty("signed_batches_window"))
                    if (!$util.isInteger(message.signed_batches_window) && !(message.signed_batches_window && $util.isInteger(message.signed_batches_window.low) && $util.isInteger(message.signed_batches_window.high)))
                        return "signed_batches_window: integer|Long expected";
                if (message.signed_logic_calls_window != null && message.hasOwnProperty("signed_logic_calls_window"))
                    if (!$util.isInteger(message.signed_logic_calls_window) && !(message.signed_logic_calls_window && $util.isInteger(message.signed_logic_calls_window.low) && $util.isInteger(message.signed_logic_calls_window.high)))
                        return "signed_logic_calls_window: integer|Long expected";
                if (message.target_batch_timeout != null && message.hasOwnProperty("target_batch_timeout"))
                    if (!$util.isInteger(message.target_batch_timeout) && !(message.target_batch_timeout && $util.isInteger(message.target_batch_timeout.low) && $util.isInteger(message.target_batch_timeout.high)))
                        return "target_batch_timeout: integer|Long expected";
                if (message.average_block_time != null && message.hasOwnProperty("average_block_time"))
                    if (!$util.isInteger(message.average_block_time) && !(message.average_block_time && $util.isInteger(message.average_block_time.low) && $util.isInteger(message.average_block_time.high)))
                        return "average_block_time: integer|Long expected";
                if (message.average_ethereum_block_time != null && message.hasOwnProperty("average_ethereum_block_time"))
                    if (!$util.isInteger(message.average_ethereum_block_time) && !(message.average_ethereum_block_time && $util.isInteger(message.average_ethereum_block_time.low) && $util.isInteger(message.average_ethereum_block_time.high)))
                        return "average_ethereum_block_time: integer|Long expected";
                if (message.slash_fraction_valset != null && message.hasOwnProperty("slash_fraction_valset"))
                    if (!(message.slash_fraction_valset && typeof message.slash_fraction_valset.length === "number" || $util.isString(message.slash_fraction_valset)))
                        return "slash_fraction_valset: buffer expected";
                if (message.slash_fraction_batch != null && message.hasOwnProperty("slash_fraction_batch"))
                    if (!(message.slash_fraction_batch && typeof message.slash_fraction_batch.length === "number" || $util.isString(message.slash_fraction_batch)))
                        return "slash_fraction_batch: buffer expected";
                if (message.slash_fraction_logic_call != null && message.hasOwnProperty("slash_fraction_logic_call"))
                    if (!(message.slash_fraction_logic_call && typeof message.slash_fraction_logic_call.length === "number" || $util.isString(message.slash_fraction_logic_call)))
                        return "slash_fraction_logic_call: buffer expected";
                if (message.unbond_slashing_valsets_window != null && message.hasOwnProperty("unbond_slashing_valsets_window"))
                    if (!$util.isInteger(message.unbond_slashing_valsets_window) && !(message.unbond_slashing_valsets_window && $util.isInteger(message.unbond_slashing_valsets_window.low) && $util.isInteger(message.unbond_slashing_valsets_window.high)))
                        return "unbond_slashing_valsets_window: integer|Long expected";
                if (message.slash_fraction_bad_eth_signature != null && message.hasOwnProperty("slash_fraction_bad_eth_signature"))
                    if (!(message.slash_fraction_bad_eth_signature && typeof message.slash_fraction_bad_eth_signature.length === "number" || $util.isString(message.slash_fraction_bad_eth_signature)))
                        return "slash_fraction_bad_eth_signature: buffer expected";
                if (message.valset_reward != null && message.hasOwnProperty("valset_reward")) {
                    let error = $root.cosmos.base.v1beta1.Coin.verify(message.valset_reward);
                    if (error)
                        return "valset_reward." + error;
                }
                if (message.bridge_active != null && message.hasOwnProperty("bridge_active"))
                    if (typeof message.bridge_active !== "boolean")
                        return "bridge_active: boolean expected";
                if (message.ethereum_blacklist != null && message.hasOwnProperty("ethereum_blacklist")) {
                    if (!Array.isArray(message.ethereum_blacklist))
                        return "ethereum_blacklist: array expected";
                    for (let i = 0; i < message.ethereum_blacklist.length; ++i)
                        if (!$util.isString(message.ethereum_blacklist[i]))
                            return "ethereum_blacklist: string[] expected";
                }
                return null;
            };

            /**
             * Creates a Params message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.Params
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.Params} Params
             */
            Params.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.Params)
                    return object;
                let message = new $root.gravity.v1.Params();
                if (object.gravity_id != null)
                    message.gravity_id = String(object.gravity_id);
                if (object.contract_source_hash != null)
                    message.contract_source_hash = String(object.contract_source_hash);
                if (object.bridge_ethereum_address != null)
                    message.bridge_ethereum_address = String(object.bridge_ethereum_address);
                if (object.bridge_chain_id != null)
                    if ($util.Long)
                        (message.bridge_chain_id = $util.Long.fromValue(object.bridge_chain_id)).unsigned = true;
                    else if (typeof object.bridge_chain_id === "string")
                        message.bridge_chain_id = parseInt(object.bridge_chain_id, 10);
                    else if (typeof object.bridge_chain_id === "number")
                        message.bridge_chain_id = object.bridge_chain_id;
                    else if (typeof object.bridge_chain_id === "object")
                        message.bridge_chain_id = new $util.LongBits(object.bridge_chain_id.low >>> 0, object.bridge_chain_id.high >>> 0).toNumber(true);
                if (object.signed_valsets_window != null)
                    if ($util.Long)
                        (message.signed_valsets_window = $util.Long.fromValue(object.signed_valsets_window)).unsigned = true;
                    else if (typeof object.signed_valsets_window === "string")
                        message.signed_valsets_window = parseInt(object.signed_valsets_window, 10);
                    else if (typeof object.signed_valsets_window === "number")
                        message.signed_valsets_window = object.signed_valsets_window;
                    else if (typeof object.signed_valsets_window === "object")
                        message.signed_valsets_window = new $util.LongBits(object.signed_valsets_window.low >>> 0, object.signed_valsets_window.high >>> 0).toNumber(true);
                if (object.signed_batches_window != null)
                    if ($util.Long)
                        (message.signed_batches_window = $util.Long.fromValue(object.signed_batches_window)).unsigned = true;
                    else if (typeof object.signed_batches_window === "string")
                        message.signed_batches_window = parseInt(object.signed_batches_window, 10);
                    else if (typeof object.signed_batches_window === "number")
                        message.signed_batches_window = object.signed_batches_window;
                    else if (typeof object.signed_batches_window === "object")
                        message.signed_batches_window = new $util.LongBits(object.signed_batches_window.low >>> 0, object.signed_batches_window.high >>> 0).toNumber(true);
                if (object.signed_logic_calls_window != null)
                    if ($util.Long)
                        (message.signed_logic_calls_window = $util.Long.fromValue(object.signed_logic_calls_window)).unsigned = true;
                    else if (typeof object.signed_logic_calls_window === "string")
                        message.signed_logic_calls_window = parseInt(object.signed_logic_calls_window, 10);
                    else if (typeof object.signed_logic_calls_window === "number")
                        message.signed_logic_calls_window = object.signed_logic_calls_window;
                    else if (typeof object.signed_logic_calls_window === "object")
                        message.signed_logic_calls_window = new $util.LongBits(object.signed_logic_calls_window.low >>> 0, object.signed_logic_calls_window.high >>> 0).toNumber(true);
                if (object.target_batch_timeout != null)
                    if ($util.Long)
                        (message.target_batch_timeout = $util.Long.fromValue(object.target_batch_timeout)).unsigned = true;
                    else if (typeof object.target_batch_timeout === "string")
                        message.target_batch_timeout = parseInt(object.target_batch_timeout, 10);
                    else if (typeof object.target_batch_timeout === "number")
                        message.target_batch_timeout = object.target_batch_timeout;
                    else if (typeof object.target_batch_timeout === "object")
                        message.target_batch_timeout = new $util.LongBits(object.target_batch_timeout.low >>> 0, object.target_batch_timeout.high >>> 0).toNumber(true);
                if (object.average_block_time != null)
                    if ($util.Long)
                        (message.average_block_time = $util.Long.fromValue(object.average_block_time)).unsigned = true;
                    else if (typeof object.average_block_time === "string")
                        message.average_block_time = parseInt(object.average_block_time, 10);
                    else if (typeof object.average_block_time === "number")
                        message.average_block_time = object.average_block_time;
                    else if (typeof object.average_block_time === "object")
                        message.average_block_time = new $util.LongBits(object.average_block_time.low >>> 0, object.average_block_time.high >>> 0).toNumber(true);
                if (object.average_ethereum_block_time != null)
                    if ($util.Long)
                        (message.average_ethereum_block_time = $util.Long.fromValue(object.average_ethereum_block_time)).unsigned = true;
                    else if (typeof object.average_ethereum_block_time === "string")
                        message.average_ethereum_block_time = parseInt(object.average_ethereum_block_time, 10);
                    else if (typeof object.average_ethereum_block_time === "number")
                        message.average_ethereum_block_time = object.average_ethereum_block_time;
                    else if (typeof object.average_ethereum_block_time === "object")
                        message.average_ethereum_block_time = new $util.LongBits(object.average_ethereum_block_time.low >>> 0, object.average_ethereum_block_time.high >>> 0).toNumber(true);
                if (object.slash_fraction_valset != null)
                    if (typeof object.slash_fraction_valset === "string")
                        $util.base64.decode(object.slash_fraction_valset, message.slash_fraction_valset = $util.newBuffer($util.base64.length(object.slash_fraction_valset)), 0);
                    else if (object.slash_fraction_valset.length)
                        message.slash_fraction_valset = object.slash_fraction_valset;
                if (object.slash_fraction_batch != null)
                    if (typeof object.slash_fraction_batch === "string")
                        $util.base64.decode(object.slash_fraction_batch, message.slash_fraction_batch = $util.newBuffer($util.base64.length(object.slash_fraction_batch)), 0);
                    else if (object.slash_fraction_batch.length)
                        message.slash_fraction_batch = object.slash_fraction_batch;
                if (object.slash_fraction_logic_call != null)
                    if (typeof object.slash_fraction_logic_call === "string")
                        $util.base64.decode(object.slash_fraction_logic_call, message.slash_fraction_logic_call = $util.newBuffer($util.base64.length(object.slash_fraction_logic_call)), 0);
                    else if (object.slash_fraction_logic_call.length)
                        message.slash_fraction_logic_call = object.slash_fraction_logic_call;
                if (object.unbond_slashing_valsets_window != null)
                    if ($util.Long)
                        (message.unbond_slashing_valsets_window = $util.Long.fromValue(object.unbond_slashing_valsets_window)).unsigned = true;
                    else if (typeof object.unbond_slashing_valsets_window === "string")
                        message.unbond_slashing_valsets_window = parseInt(object.unbond_slashing_valsets_window, 10);
                    else if (typeof object.unbond_slashing_valsets_window === "number")
                        message.unbond_slashing_valsets_window = object.unbond_slashing_valsets_window;
                    else if (typeof object.unbond_slashing_valsets_window === "object")
                        message.unbond_slashing_valsets_window = new $util.LongBits(object.unbond_slashing_valsets_window.low >>> 0, object.unbond_slashing_valsets_window.high >>> 0).toNumber(true);
                if (object.slash_fraction_bad_eth_signature != null)
                    if (typeof object.slash_fraction_bad_eth_signature === "string")
                        $util.base64.decode(object.slash_fraction_bad_eth_signature, message.slash_fraction_bad_eth_signature = $util.newBuffer($util.base64.length(object.slash_fraction_bad_eth_signature)), 0);
                    else if (object.slash_fraction_bad_eth_signature.length)
                        message.slash_fraction_bad_eth_signature = object.slash_fraction_bad_eth_signature;
                if (object.valset_reward != null) {
                    if (typeof object.valset_reward !== "object")
                        throw TypeError(".gravity.v1.Params.valset_reward: object expected");
                    message.valset_reward = $root.cosmos.base.v1beta1.Coin.fromObject(object.valset_reward);
                }
                if (object.bridge_active != null)
                    message.bridge_active = Boolean(object.bridge_active);
                if (object.ethereum_blacklist) {
                    if (!Array.isArray(object.ethereum_blacklist))
                        throw TypeError(".gravity.v1.Params.ethereum_blacklist: array expected");
                    message.ethereum_blacklist = [];
                    for (let i = 0; i < object.ethereum_blacklist.length; ++i)
                        message.ethereum_blacklist[i] = String(object.ethereum_blacklist[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a Params message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.Params
             * @static
             * @param {gravity.v1.Params} message Params
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Params.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.ethereum_blacklist = [];
                if (options.defaults) {
                    object.gravity_id = "";
                    object.contract_source_hash = "";
                    object.bridge_ethereum_address = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.bridge_chain_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.bridge_chain_id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.signed_valsets_window = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.signed_valsets_window = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.signed_batches_window = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.signed_batches_window = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.signed_logic_calls_window = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.signed_logic_calls_window = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.target_batch_timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.target_batch_timeout = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.average_block_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.average_block_time = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.average_ethereum_block_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.average_ethereum_block_time = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.slash_fraction_valset = "";
                    else {
                        object.slash_fraction_valset = [];
                        if (options.bytes !== Array)
                            object.slash_fraction_valset = $util.newBuffer(object.slash_fraction_valset);
                    }
                    if (options.bytes === String)
                        object.slash_fraction_batch = "";
                    else {
                        object.slash_fraction_batch = [];
                        if (options.bytes !== Array)
                            object.slash_fraction_batch = $util.newBuffer(object.slash_fraction_batch);
                    }
                    if (options.bytes === String)
                        object.slash_fraction_logic_call = "";
                    else {
                        object.slash_fraction_logic_call = [];
                        if (options.bytes !== Array)
                            object.slash_fraction_logic_call = $util.newBuffer(object.slash_fraction_logic_call);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.unbond_slashing_valsets_window = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.unbond_slashing_valsets_window = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.slash_fraction_bad_eth_signature = "";
                    else {
                        object.slash_fraction_bad_eth_signature = [];
                        if (options.bytes !== Array)
                            object.slash_fraction_bad_eth_signature = $util.newBuffer(object.slash_fraction_bad_eth_signature);
                    }
                    object.valset_reward = null;
                    object.bridge_active = false;
                }
                if (message.gravity_id != null && message.hasOwnProperty("gravity_id"))
                    object.gravity_id = message.gravity_id;
                if (message.contract_source_hash != null && message.hasOwnProperty("contract_source_hash"))
                    object.contract_source_hash = message.contract_source_hash;
                if (message.bridge_ethereum_address != null && message.hasOwnProperty("bridge_ethereum_address"))
                    object.bridge_ethereum_address = message.bridge_ethereum_address;
                if (message.bridge_chain_id != null && message.hasOwnProperty("bridge_chain_id"))
                    if (typeof message.bridge_chain_id === "number")
                        object.bridge_chain_id = options.longs === String ? String(message.bridge_chain_id) : message.bridge_chain_id;
                    else
                        object.bridge_chain_id = options.longs === String ? $util.Long.prototype.toString.call(message.bridge_chain_id) : options.longs === Number ? new $util.LongBits(message.bridge_chain_id.low >>> 0, message.bridge_chain_id.high >>> 0).toNumber(true) : message.bridge_chain_id;
                if (message.signed_valsets_window != null && message.hasOwnProperty("signed_valsets_window"))
                    if (typeof message.signed_valsets_window === "number")
                        object.signed_valsets_window = options.longs === String ? String(message.signed_valsets_window) : message.signed_valsets_window;
                    else
                        object.signed_valsets_window = options.longs === String ? $util.Long.prototype.toString.call(message.signed_valsets_window) : options.longs === Number ? new $util.LongBits(message.signed_valsets_window.low >>> 0, message.signed_valsets_window.high >>> 0).toNumber(true) : message.signed_valsets_window;
                if (message.signed_batches_window != null && message.hasOwnProperty("signed_batches_window"))
                    if (typeof message.signed_batches_window === "number")
                        object.signed_batches_window = options.longs === String ? String(message.signed_batches_window) : message.signed_batches_window;
                    else
                        object.signed_batches_window = options.longs === String ? $util.Long.prototype.toString.call(message.signed_batches_window) : options.longs === Number ? new $util.LongBits(message.signed_batches_window.low >>> 0, message.signed_batches_window.high >>> 0).toNumber(true) : message.signed_batches_window;
                if (message.signed_logic_calls_window != null && message.hasOwnProperty("signed_logic_calls_window"))
                    if (typeof message.signed_logic_calls_window === "number")
                        object.signed_logic_calls_window = options.longs === String ? String(message.signed_logic_calls_window) : message.signed_logic_calls_window;
                    else
                        object.signed_logic_calls_window = options.longs === String ? $util.Long.prototype.toString.call(message.signed_logic_calls_window) : options.longs === Number ? new $util.LongBits(message.signed_logic_calls_window.low >>> 0, message.signed_logic_calls_window.high >>> 0).toNumber(true) : message.signed_logic_calls_window;
                if (message.target_batch_timeout != null && message.hasOwnProperty("target_batch_timeout"))
                    if (typeof message.target_batch_timeout === "number")
                        object.target_batch_timeout = options.longs === String ? String(message.target_batch_timeout) : message.target_batch_timeout;
                    else
                        object.target_batch_timeout = options.longs === String ? $util.Long.prototype.toString.call(message.target_batch_timeout) : options.longs === Number ? new $util.LongBits(message.target_batch_timeout.low >>> 0, message.target_batch_timeout.high >>> 0).toNumber(true) : message.target_batch_timeout;
                if (message.average_block_time != null && message.hasOwnProperty("average_block_time"))
                    if (typeof message.average_block_time === "number")
                        object.average_block_time = options.longs === String ? String(message.average_block_time) : message.average_block_time;
                    else
                        object.average_block_time = options.longs === String ? $util.Long.prototype.toString.call(message.average_block_time) : options.longs === Number ? new $util.LongBits(message.average_block_time.low >>> 0, message.average_block_time.high >>> 0).toNumber(true) : message.average_block_time;
                if (message.average_ethereum_block_time != null && message.hasOwnProperty("average_ethereum_block_time"))
                    if (typeof message.average_ethereum_block_time === "number")
                        object.average_ethereum_block_time = options.longs === String ? String(message.average_ethereum_block_time) : message.average_ethereum_block_time;
                    else
                        object.average_ethereum_block_time = options.longs === String ? $util.Long.prototype.toString.call(message.average_ethereum_block_time) : options.longs === Number ? new $util.LongBits(message.average_ethereum_block_time.low >>> 0, message.average_ethereum_block_time.high >>> 0).toNumber(true) : message.average_ethereum_block_time;
                if (message.slash_fraction_valset != null && message.hasOwnProperty("slash_fraction_valset"))
                    object.slash_fraction_valset = options.bytes === String ? $util.base64.encode(message.slash_fraction_valset, 0, message.slash_fraction_valset.length) : options.bytes === Array ? Array.prototype.slice.call(message.slash_fraction_valset) : message.slash_fraction_valset;
                if (message.slash_fraction_batch != null && message.hasOwnProperty("slash_fraction_batch"))
                    object.slash_fraction_batch = options.bytes === String ? $util.base64.encode(message.slash_fraction_batch, 0, message.slash_fraction_batch.length) : options.bytes === Array ? Array.prototype.slice.call(message.slash_fraction_batch) : message.slash_fraction_batch;
                if (message.slash_fraction_logic_call != null && message.hasOwnProperty("slash_fraction_logic_call"))
                    object.slash_fraction_logic_call = options.bytes === String ? $util.base64.encode(message.slash_fraction_logic_call, 0, message.slash_fraction_logic_call.length) : options.bytes === Array ? Array.prototype.slice.call(message.slash_fraction_logic_call) : message.slash_fraction_logic_call;
                if (message.unbond_slashing_valsets_window != null && message.hasOwnProperty("unbond_slashing_valsets_window"))
                    if (typeof message.unbond_slashing_valsets_window === "number")
                        object.unbond_slashing_valsets_window = options.longs === String ? String(message.unbond_slashing_valsets_window) : message.unbond_slashing_valsets_window;
                    else
                        object.unbond_slashing_valsets_window = options.longs === String ? $util.Long.prototype.toString.call(message.unbond_slashing_valsets_window) : options.longs === Number ? new $util.LongBits(message.unbond_slashing_valsets_window.low >>> 0, message.unbond_slashing_valsets_window.high >>> 0).toNumber(true) : message.unbond_slashing_valsets_window;
                if (message.slash_fraction_bad_eth_signature != null && message.hasOwnProperty("slash_fraction_bad_eth_signature"))
                    object.slash_fraction_bad_eth_signature = options.bytes === String ? $util.base64.encode(message.slash_fraction_bad_eth_signature, 0, message.slash_fraction_bad_eth_signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.slash_fraction_bad_eth_signature) : message.slash_fraction_bad_eth_signature;
                if (message.valset_reward != null && message.hasOwnProperty("valset_reward"))
                    object.valset_reward = $root.cosmos.base.v1beta1.Coin.toObject(message.valset_reward, options);
                if (message.bridge_active != null && message.hasOwnProperty("bridge_active"))
                    object.bridge_active = message.bridge_active;
                if (message.ethereum_blacklist && message.ethereum_blacklist.length) {
                    object.ethereum_blacklist = [];
                    for (let j = 0; j < message.ethereum_blacklist.length; ++j)
                        object.ethereum_blacklist[j] = message.ethereum_blacklist[j];
                }
                return object;
            };

            /**
             * Converts this Params to JSON.
             * @function toJSON
             * @memberof gravity.v1.Params
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Params.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Params;
        })();

        v1.GenesisState = (function() {

            /**
             * Properties of a GenesisState.
             * @memberof gravity.v1
             * @interface IGenesisState
             * @property {gravity.v1.IParams|null} [params] GenesisState params
             * @property {gravity.v1.IGravityNonces|null} [gravity_nonces] GenesisState gravity_nonces
             * @property {Array.<gravity.v1.IValset>|null} [valsets] GenesisState valsets
             * @property {Array.<gravity.v1.IMsgValsetConfirm>|null} [valset_confirms] GenesisState valset_confirms
             * @property {Array.<gravity.v1.IOutgoingTxBatch>|null} [batches] GenesisState batches
             * @property {Array.<gravity.v1.IMsgConfirmBatch>|null} [batch_confirms] GenesisState batch_confirms
             * @property {Array.<gravity.v1.IOutgoingLogicCall>|null} [logic_calls] GenesisState logic_calls
             * @property {Array.<gravity.v1.IMsgConfirmLogicCall>|null} [logic_call_confirms] GenesisState logic_call_confirms
             * @property {Array.<gravity.v1.IAttestation>|null} [attestations] GenesisState attestations
             * @property {Array.<gravity.v1.IMsgSetOrchestratorAddress>|null} [delegate_keys] GenesisState delegate_keys
             * @property {Array.<gravity.v1.IERC20ToDenom>|null} [erc20_to_denoms] GenesisState erc20_to_denoms
             * @property {Array.<gravity.v1.IOutgoingTransferTx>|null} [unbatched_transfers] GenesisState unbatched_transfers
             */

            /**
             * Constructs a new GenesisState.
             * @memberof gravity.v1
             * @classdesc Represents a GenesisState.
             * @implements IGenesisState
             * @constructor
             * @param {gravity.v1.IGenesisState=} [properties] Properties to set
             */
            function GenesisState(properties) {
                this.valsets = [];
                this.valset_confirms = [];
                this.batches = [];
                this.batch_confirms = [];
                this.logic_calls = [];
                this.logic_call_confirms = [];
                this.attestations = [];
                this.delegate_keys = [];
                this.erc20_to_denoms = [];
                this.unbatched_transfers = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GenesisState params.
             * @member {gravity.v1.IParams|null|undefined} params
             * @memberof gravity.v1.GenesisState
             * @instance
             */
            GenesisState.prototype.params = null;

            /**
             * GenesisState gravity_nonces.
             * @member {gravity.v1.IGravityNonces|null|undefined} gravity_nonces
             * @memberof gravity.v1.GenesisState
             * @instance
             */
            GenesisState.prototype.gravity_nonces = null;

            /**
             * GenesisState valsets.
             * @member {Array.<gravity.v1.IValset>} valsets
             * @memberof gravity.v1.GenesisState
             * @instance
             */
            GenesisState.prototype.valsets = $util.emptyArray;

            /**
             * GenesisState valset_confirms.
             * @member {Array.<gravity.v1.IMsgValsetConfirm>} valset_confirms
             * @memberof gravity.v1.GenesisState
             * @instance
             */
            GenesisState.prototype.valset_confirms = $util.emptyArray;

            /**
             * GenesisState batches.
             * @member {Array.<gravity.v1.IOutgoingTxBatch>} batches
             * @memberof gravity.v1.GenesisState
             * @instance
             */
            GenesisState.prototype.batches = $util.emptyArray;

            /**
             * GenesisState batch_confirms.
             * @member {Array.<gravity.v1.IMsgConfirmBatch>} batch_confirms
             * @memberof gravity.v1.GenesisState
             * @instance
             */
            GenesisState.prototype.batch_confirms = $util.emptyArray;

            /**
             * GenesisState logic_calls.
             * @member {Array.<gravity.v1.IOutgoingLogicCall>} logic_calls
             * @memberof gravity.v1.GenesisState
             * @instance
             */
            GenesisState.prototype.logic_calls = $util.emptyArray;

            /**
             * GenesisState logic_call_confirms.
             * @member {Array.<gravity.v1.IMsgConfirmLogicCall>} logic_call_confirms
             * @memberof gravity.v1.GenesisState
             * @instance
             */
            GenesisState.prototype.logic_call_confirms = $util.emptyArray;

            /**
             * GenesisState attestations.
             * @member {Array.<gravity.v1.IAttestation>} attestations
             * @memberof gravity.v1.GenesisState
             * @instance
             */
            GenesisState.prototype.attestations = $util.emptyArray;

            /**
             * GenesisState delegate_keys.
             * @member {Array.<gravity.v1.IMsgSetOrchestratorAddress>} delegate_keys
             * @memberof gravity.v1.GenesisState
             * @instance
             */
            GenesisState.prototype.delegate_keys = $util.emptyArray;

            /**
             * GenesisState erc20_to_denoms.
             * @member {Array.<gravity.v1.IERC20ToDenom>} erc20_to_denoms
             * @memberof gravity.v1.GenesisState
             * @instance
             */
            GenesisState.prototype.erc20_to_denoms = $util.emptyArray;

            /**
             * GenesisState unbatched_transfers.
             * @member {Array.<gravity.v1.IOutgoingTransferTx>} unbatched_transfers
             * @memberof gravity.v1.GenesisState
             * @instance
             */
            GenesisState.prototype.unbatched_transfers = $util.emptyArray;

            /**
             * Encodes the specified GenesisState message. Does not implicitly {@link gravity.v1.GenesisState.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.GenesisState
             * @static
             * @param {gravity.v1.IGenesisState} message GenesisState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GenesisState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                    $root.gravity.v1.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.gravity_nonces != null && Object.hasOwnProperty.call(message, "gravity_nonces"))
                    $root.gravity.v1.GravityNonces.encode(message.gravity_nonces, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.valsets != null && message.valsets.length)
                    for (let i = 0; i < message.valsets.length; ++i)
                        $root.gravity.v1.Valset.encode(message.valsets[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.valset_confirms != null && message.valset_confirms.length)
                    for (let i = 0; i < message.valset_confirms.length; ++i)
                        $root.gravity.v1.MsgValsetConfirm.encode(message.valset_confirms[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.batches != null && message.batches.length)
                    for (let i = 0; i < message.batches.length; ++i)
                        $root.gravity.v1.OutgoingTxBatch.encode(message.batches[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.batch_confirms != null && message.batch_confirms.length)
                    for (let i = 0; i < message.batch_confirms.length; ++i)
                        $root.gravity.v1.MsgConfirmBatch.encode(message.batch_confirms[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.logic_calls != null && message.logic_calls.length)
                    for (let i = 0; i < message.logic_calls.length; ++i)
                        $root.gravity.v1.OutgoingLogicCall.encode(message.logic_calls[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.logic_call_confirms != null && message.logic_call_confirms.length)
                    for (let i = 0; i < message.logic_call_confirms.length; ++i)
                        $root.gravity.v1.MsgConfirmLogicCall.encode(message.logic_call_confirms[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.attestations != null && message.attestations.length)
                    for (let i = 0; i < message.attestations.length; ++i)
                        $root.gravity.v1.Attestation.encode(message.attestations[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.delegate_keys != null && message.delegate_keys.length)
                    for (let i = 0; i < message.delegate_keys.length; ++i)
                        $root.gravity.v1.MsgSetOrchestratorAddress.encode(message.delegate_keys[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.erc20_to_denoms != null && message.erc20_to_denoms.length)
                    for (let i = 0; i < message.erc20_to_denoms.length; ++i)
                        $root.gravity.v1.ERC20ToDenom.encode(message.erc20_to_denoms[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.unbatched_transfers != null && message.unbatched_transfers.length)
                    for (let i = 0; i < message.unbatched_transfers.length; ++i)
                        $root.gravity.v1.OutgoingTransferTx.encode(message.unbatched_transfers[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link gravity.v1.GenesisState.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.GenesisState
             * @static
             * @param {gravity.v1.IGenesisState} message GenesisState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GenesisState message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.GenesisState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.GenesisState} GenesisState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GenesisState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.GenesisState();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.params = $root.gravity.v1.Params.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.gravity_nonces = $root.gravity.v1.GravityNonces.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (!(message.valsets && message.valsets.length))
                            message.valsets = [];
                        message.valsets.push($root.gravity.v1.Valset.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.valset_confirms && message.valset_confirms.length))
                            message.valset_confirms = [];
                        message.valset_confirms.push($root.gravity.v1.MsgValsetConfirm.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.batches && message.batches.length))
                            message.batches = [];
                        message.batches.push($root.gravity.v1.OutgoingTxBatch.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.batch_confirms && message.batch_confirms.length))
                            message.batch_confirms = [];
                        message.batch_confirms.push($root.gravity.v1.MsgConfirmBatch.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.logic_calls && message.logic_calls.length))
                            message.logic_calls = [];
                        message.logic_calls.push($root.gravity.v1.OutgoingLogicCall.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.logic_call_confirms && message.logic_call_confirms.length))
                            message.logic_call_confirms = [];
                        message.logic_call_confirms.push($root.gravity.v1.MsgConfirmLogicCall.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.attestations && message.attestations.length))
                            message.attestations = [];
                        message.attestations.push($root.gravity.v1.Attestation.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.delegate_keys && message.delegate_keys.length))
                            message.delegate_keys = [];
                        message.delegate_keys.push($root.gravity.v1.MsgSetOrchestratorAddress.decode(reader, reader.uint32()));
                        break;
                    case 11:
                        if (!(message.erc20_to_denoms && message.erc20_to_denoms.length))
                            message.erc20_to_denoms = [];
                        message.erc20_to_denoms.push($root.gravity.v1.ERC20ToDenom.decode(reader, reader.uint32()));
                        break;
                    case 12:
                        if (!(message.unbatched_transfers && message.unbatched_transfers.length))
                            message.unbatched_transfers = [];
                        message.unbatched_transfers.push($root.gravity.v1.OutgoingTransferTx.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GenesisState message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.GenesisState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.GenesisState} GenesisState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GenesisState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GenesisState message.
             * @function verify
             * @memberof gravity.v1.GenesisState
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GenesisState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.params != null && message.hasOwnProperty("params")) {
                    let error = $root.gravity.v1.Params.verify(message.params);
                    if (error)
                        return "params." + error;
                }
                if (message.gravity_nonces != null && message.hasOwnProperty("gravity_nonces")) {
                    let error = $root.gravity.v1.GravityNonces.verify(message.gravity_nonces);
                    if (error)
                        return "gravity_nonces." + error;
                }
                if (message.valsets != null && message.hasOwnProperty("valsets")) {
                    if (!Array.isArray(message.valsets))
                        return "valsets: array expected";
                    for (let i = 0; i < message.valsets.length; ++i) {
                        let error = $root.gravity.v1.Valset.verify(message.valsets[i]);
                        if (error)
                            return "valsets." + error;
                    }
                }
                if (message.valset_confirms != null && message.hasOwnProperty("valset_confirms")) {
                    if (!Array.isArray(message.valset_confirms))
                        return "valset_confirms: array expected";
                    for (let i = 0; i < message.valset_confirms.length; ++i) {
                        let error = $root.gravity.v1.MsgValsetConfirm.verify(message.valset_confirms[i]);
                        if (error)
                            return "valset_confirms." + error;
                    }
                }
                if (message.batches != null && message.hasOwnProperty("batches")) {
                    if (!Array.isArray(message.batches))
                        return "batches: array expected";
                    for (let i = 0; i < message.batches.length; ++i) {
                        let error = $root.gravity.v1.OutgoingTxBatch.verify(message.batches[i]);
                        if (error)
                            return "batches." + error;
                    }
                }
                if (message.batch_confirms != null && message.hasOwnProperty("batch_confirms")) {
                    if (!Array.isArray(message.batch_confirms))
                        return "batch_confirms: array expected";
                    for (let i = 0; i < message.batch_confirms.length; ++i) {
                        let error = $root.gravity.v1.MsgConfirmBatch.verify(message.batch_confirms[i]);
                        if (error)
                            return "batch_confirms." + error;
                    }
                }
                if (message.logic_calls != null && message.hasOwnProperty("logic_calls")) {
                    if (!Array.isArray(message.logic_calls))
                        return "logic_calls: array expected";
                    for (let i = 0; i < message.logic_calls.length; ++i) {
                        let error = $root.gravity.v1.OutgoingLogicCall.verify(message.logic_calls[i]);
                        if (error)
                            return "logic_calls." + error;
                    }
                }
                if (message.logic_call_confirms != null && message.hasOwnProperty("logic_call_confirms")) {
                    if (!Array.isArray(message.logic_call_confirms))
                        return "logic_call_confirms: array expected";
                    for (let i = 0; i < message.logic_call_confirms.length; ++i) {
                        let error = $root.gravity.v1.MsgConfirmLogicCall.verify(message.logic_call_confirms[i]);
                        if (error)
                            return "logic_call_confirms." + error;
                    }
                }
                if (message.attestations != null && message.hasOwnProperty("attestations")) {
                    if (!Array.isArray(message.attestations))
                        return "attestations: array expected";
                    for (let i = 0; i < message.attestations.length; ++i) {
                        let error = $root.gravity.v1.Attestation.verify(message.attestations[i]);
                        if (error)
                            return "attestations." + error;
                    }
                }
                if (message.delegate_keys != null && message.hasOwnProperty("delegate_keys")) {
                    if (!Array.isArray(message.delegate_keys))
                        return "delegate_keys: array expected";
                    for (let i = 0; i < message.delegate_keys.length; ++i) {
                        let error = $root.gravity.v1.MsgSetOrchestratorAddress.verify(message.delegate_keys[i]);
                        if (error)
                            return "delegate_keys." + error;
                    }
                }
                if (message.erc20_to_denoms != null && message.hasOwnProperty("erc20_to_denoms")) {
                    if (!Array.isArray(message.erc20_to_denoms))
                        return "erc20_to_denoms: array expected";
                    for (let i = 0; i < message.erc20_to_denoms.length; ++i) {
                        let error = $root.gravity.v1.ERC20ToDenom.verify(message.erc20_to_denoms[i]);
                        if (error)
                            return "erc20_to_denoms." + error;
                    }
                }
                if (message.unbatched_transfers != null && message.hasOwnProperty("unbatched_transfers")) {
                    if (!Array.isArray(message.unbatched_transfers))
                        return "unbatched_transfers: array expected";
                    for (let i = 0; i < message.unbatched_transfers.length; ++i) {
                        let error = $root.gravity.v1.OutgoingTransferTx.verify(message.unbatched_transfers[i]);
                        if (error)
                            return "unbatched_transfers." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.GenesisState
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.GenesisState} GenesisState
             */
            GenesisState.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.GenesisState)
                    return object;
                let message = new $root.gravity.v1.GenesisState();
                if (object.params != null) {
                    if (typeof object.params !== "object")
                        throw TypeError(".gravity.v1.GenesisState.params: object expected");
                    message.params = $root.gravity.v1.Params.fromObject(object.params);
                }
                if (object.gravity_nonces != null) {
                    if (typeof object.gravity_nonces !== "object")
                        throw TypeError(".gravity.v1.GenesisState.gravity_nonces: object expected");
                    message.gravity_nonces = $root.gravity.v1.GravityNonces.fromObject(object.gravity_nonces);
                }
                if (object.valsets) {
                    if (!Array.isArray(object.valsets))
                        throw TypeError(".gravity.v1.GenesisState.valsets: array expected");
                    message.valsets = [];
                    for (let i = 0; i < object.valsets.length; ++i) {
                        if (typeof object.valsets[i] !== "object")
                            throw TypeError(".gravity.v1.GenesisState.valsets: object expected");
                        message.valsets[i] = $root.gravity.v1.Valset.fromObject(object.valsets[i]);
                    }
                }
                if (object.valset_confirms) {
                    if (!Array.isArray(object.valset_confirms))
                        throw TypeError(".gravity.v1.GenesisState.valset_confirms: array expected");
                    message.valset_confirms = [];
                    for (let i = 0; i < object.valset_confirms.length; ++i) {
                        if (typeof object.valset_confirms[i] !== "object")
                            throw TypeError(".gravity.v1.GenesisState.valset_confirms: object expected");
                        message.valset_confirms[i] = $root.gravity.v1.MsgValsetConfirm.fromObject(object.valset_confirms[i]);
                    }
                }
                if (object.batches) {
                    if (!Array.isArray(object.batches))
                        throw TypeError(".gravity.v1.GenesisState.batches: array expected");
                    message.batches = [];
                    for (let i = 0; i < object.batches.length; ++i) {
                        if (typeof object.batches[i] !== "object")
                            throw TypeError(".gravity.v1.GenesisState.batches: object expected");
                        message.batches[i] = $root.gravity.v1.OutgoingTxBatch.fromObject(object.batches[i]);
                    }
                }
                if (object.batch_confirms) {
                    if (!Array.isArray(object.batch_confirms))
                        throw TypeError(".gravity.v1.GenesisState.batch_confirms: array expected");
                    message.batch_confirms = [];
                    for (let i = 0; i < object.batch_confirms.length; ++i) {
                        if (typeof object.batch_confirms[i] !== "object")
                            throw TypeError(".gravity.v1.GenesisState.batch_confirms: object expected");
                        message.batch_confirms[i] = $root.gravity.v1.MsgConfirmBatch.fromObject(object.batch_confirms[i]);
                    }
                }
                if (object.logic_calls) {
                    if (!Array.isArray(object.logic_calls))
                        throw TypeError(".gravity.v1.GenesisState.logic_calls: array expected");
                    message.logic_calls = [];
                    for (let i = 0; i < object.logic_calls.length; ++i) {
                        if (typeof object.logic_calls[i] !== "object")
                            throw TypeError(".gravity.v1.GenesisState.logic_calls: object expected");
                        message.logic_calls[i] = $root.gravity.v1.OutgoingLogicCall.fromObject(object.logic_calls[i]);
                    }
                }
                if (object.logic_call_confirms) {
                    if (!Array.isArray(object.logic_call_confirms))
                        throw TypeError(".gravity.v1.GenesisState.logic_call_confirms: array expected");
                    message.logic_call_confirms = [];
                    for (let i = 0; i < object.logic_call_confirms.length; ++i) {
                        if (typeof object.logic_call_confirms[i] !== "object")
                            throw TypeError(".gravity.v1.GenesisState.logic_call_confirms: object expected");
                        message.logic_call_confirms[i] = $root.gravity.v1.MsgConfirmLogicCall.fromObject(object.logic_call_confirms[i]);
                    }
                }
                if (object.attestations) {
                    if (!Array.isArray(object.attestations))
                        throw TypeError(".gravity.v1.GenesisState.attestations: array expected");
                    message.attestations = [];
                    for (let i = 0; i < object.attestations.length; ++i) {
                        if (typeof object.attestations[i] !== "object")
                            throw TypeError(".gravity.v1.GenesisState.attestations: object expected");
                        message.attestations[i] = $root.gravity.v1.Attestation.fromObject(object.attestations[i]);
                    }
                }
                if (object.delegate_keys) {
                    if (!Array.isArray(object.delegate_keys))
                        throw TypeError(".gravity.v1.GenesisState.delegate_keys: array expected");
                    message.delegate_keys = [];
                    for (let i = 0; i < object.delegate_keys.length; ++i) {
                        if (typeof object.delegate_keys[i] !== "object")
                            throw TypeError(".gravity.v1.GenesisState.delegate_keys: object expected");
                        message.delegate_keys[i] = $root.gravity.v1.MsgSetOrchestratorAddress.fromObject(object.delegate_keys[i]);
                    }
                }
                if (object.erc20_to_denoms) {
                    if (!Array.isArray(object.erc20_to_denoms))
                        throw TypeError(".gravity.v1.GenesisState.erc20_to_denoms: array expected");
                    message.erc20_to_denoms = [];
                    for (let i = 0; i < object.erc20_to_denoms.length; ++i) {
                        if (typeof object.erc20_to_denoms[i] !== "object")
                            throw TypeError(".gravity.v1.GenesisState.erc20_to_denoms: object expected");
                        message.erc20_to_denoms[i] = $root.gravity.v1.ERC20ToDenom.fromObject(object.erc20_to_denoms[i]);
                    }
                }
                if (object.unbatched_transfers) {
                    if (!Array.isArray(object.unbatched_transfers))
                        throw TypeError(".gravity.v1.GenesisState.unbatched_transfers: array expected");
                    message.unbatched_transfers = [];
                    for (let i = 0; i < object.unbatched_transfers.length; ++i) {
                        if (typeof object.unbatched_transfers[i] !== "object")
                            throw TypeError(".gravity.v1.GenesisState.unbatched_transfers: object expected");
                        message.unbatched_transfers[i] = $root.gravity.v1.OutgoingTransferTx.fromObject(object.unbatched_transfers[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.GenesisState
             * @static
             * @param {gravity.v1.GenesisState} message GenesisState
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GenesisState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.valsets = [];
                    object.valset_confirms = [];
                    object.batches = [];
                    object.batch_confirms = [];
                    object.logic_calls = [];
                    object.logic_call_confirms = [];
                    object.attestations = [];
                    object.delegate_keys = [];
                    object.erc20_to_denoms = [];
                    object.unbatched_transfers = [];
                }
                if (options.defaults) {
                    object.params = null;
                    object.gravity_nonces = null;
                }
                if (message.params != null && message.hasOwnProperty("params"))
                    object.params = $root.gravity.v1.Params.toObject(message.params, options);
                if (message.gravity_nonces != null && message.hasOwnProperty("gravity_nonces"))
                    object.gravity_nonces = $root.gravity.v1.GravityNonces.toObject(message.gravity_nonces, options);
                if (message.valsets && message.valsets.length) {
                    object.valsets = [];
                    for (let j = 0; j < message.valsets.length; ++j)
                        object.valsets[j] = $root.gravity.v1.Valset.toObject(message.valsets[j], options);
                }
                if (message.valset_confirms && message.valset_confirms.length) {
                    object.valset_confirms = [];
                    for (let j = 0; j < message.valset_confirms.length; ++j)
                        object.valset_confirms[j] = $root.gravity.v1.MsgValsetConfirm.toObject(message.valset_confirms[j], options);
                }
                if (message.batches && message.batches.length) {
                    object.batches = [];
                    for (let j = 0; j < message.batches.length; ++j)
                        object.batches[j] = $root.gravity.v1.OutgoingTxBatch.toObject(message.batches[j], options);
                }
                if (message.batch_confirms && message.batch_confirms.length) {
                    object.batch_confirms = [];
                    for (let j = 0; j < message.batch_confirms.length; ++j)
                        object.batch_confirms[j] = $root.gravity.v1.MsgConfirmBatch.toObject(message.batch_confirms[j], options);
                }
                if (message.logic_calls && message.logic_calls.length) {
                    object.logic_calls = [];
                    for (let j = 0; j < message.logic_calls.length; ++j)
                        object.logic_calls[j] = $root.gravity.v1.OutgoingLogicCall.toObject(message.logic_calls[j], options);
                }
                if (message.logic_call_confirms && message.logic_call_confirms.length) {
                    object.logic_call_confirms = [];
                    for (let j = 0; j < message.logic_call_confirms.length; ++j)
                        object.logic_call_confirms[j] = $root.gravity.v1.MsgConfirmLogicCall.toObject(message.logic_call_confirms[j], options);
                }
                if (message.attestations && message.attestations.length) {
                    object.attestations = [];
                    for (let j = 0; j < message.attestations.length; ++j)
                        object.attestations[j] = $root.gravity.v1.Attestation.toObject(message.attestations[j], options);
                }
                if (message.delegate_keys && message.delegate_keys.length) {
                    object.delegate_keys = [];
                    for (let j = 0; j < message.delegate_keys.length; ++j)
                        object.delegate_keys[j] = $root.gravity.v1.MsgSetOrchestratorAddress.toObject(message.delegate_keys[j], options);
                }
                if (message.erc20_to_denoms && message.erc20_to_denoms.length) {
                    object.erc20_to_denoms = [];
                    for (let j = 0; j < message.erc20_to_denoms.length; ++j)
                        object.erc20_to_denoms[j] = $root.gravity.v1.ERC20ToDenom.toObject(message.erc20_to_denoms[j], options);
                }
                if (message.unbatched_transfers && message.unbatched_transfers.length) {
                    object.unbatched_transfers = [];
                    for (let j = 0; j < message.unbatched_transfers.length; ++j)
                        object.unbatched_transfers[j] = $root.gravity.v1.OutgoingTransferTx.toObject(message.unbatched_transfers[j], options);
                }
                return object;
            };

            /**
             * Converts this GenesisState to JSON.
             * @function toJSON
             * @memberof gravity.v1.GenesisState
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GenesisState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GenesisState;
        })();

        v1.GravityNonces = (function() {

            /**
             * Properties of a GravityNonces.
             * @memberof gravity.v1
             * @interface IGravityNonces
             * @property {Long|null} [latest_valset_nonce] GravityNonces latest_valset_nonce
             * @property {Long|null} [last_observed_nonce] GravityNonces last_observed_nonce
             * @property {Long|null} [last_slashed_valset_nonce] GravityNonces last_slashed_valset_nonce
             * @property {Long|null} [last_slashed_batch_block] GravityNonces last_slashed_batch_block
             * @property {Long|null} [last_slashed_logic_call_block] GravityNonces last_slashed_logic_call_block
             * @property {Long|null} [last_tx_pool_id] GravityNonces last_tx_pool_id
             * @property {Long|null} [last_batch_id] GravityNonces last_batch_id
             */

            /**
             * Constructs a new GravityNonces.
             * @memberof gravity.v1
             * @classdesc Represents a GravityNonces.
             * @implements IGravityNonces
             * @constructor
             * @param {gravity.v1.IGravityNonces=} [properties] Properties to set
             */
            function GravityNonces(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GravityNonces latest_valset_nonce.
             * @member {Long} latest_valset_nonce
             * @memberof gravity.v1.GravityNonces
             * @instance
             */
            GravityNonces.prototype.latest_valset_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GravityNonces last_observed_nonce.
             * @member {Long} last_observed_nonce
             * @memberof gravity.v1.GravityNonces
             * @instance
             */
            GravityNonces.prototype.last_observed_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GravityNonces last_slashed_valset_nonce.
             * @member {Long} last_slashed_valset_nonce
             * @memberof gravity.v1.GravityNonces
             * @instance
             */
            GravityNonces.prototype.last_slashed_valset_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GravityNonces last_slashed_batch_block.
             * @member {Long} last_slashed_batch_block
             * @memberof gravity.v1.GravityNonces
             * @instance
             */
            GravityNonces.prototype.last_slashed_batch_block = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GravityNonces last_slashed_logic_call_block.
             * @member {Long} last_slashed_logic_call_block
             * @memberof gravity.v1.GravityNonces
             * @instance
             */
            GravityNonces.prototype.last_slashed_logic_call_block = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GravityNonces last_tx_pool_id.
             * @member {Long} last_tx_pool_id
             * @memberof gravity.v1.GravityNonces
             * @instance
             */
            GravityNonces.prototype.last_tx_pool_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GravityNonces last_batch_id.
             * @member {Long} last_batch_id
             * @memberof gravity.v1.GravityNonces
             * @instance
             */
            GravityNonces.prototype.last_batch_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified GravityNonces message. Does not implicitly {@link gravity.v1.GravityNonces.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.GravityNonces
             * @static
             * @param {gravity.v1.IGravityNonces} message GravityNonces message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GravityNonces.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.latest_valset_nonce != null && Object.hasOwnProperty.call(message, "latest_valset_nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.latest_valset_nonce);
                if (message.last_observed_nonce != null && Object.hasOwnProperty.call(message, "last_observed_nonce"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.last_observed_nonce);
                if (message.last_slashed_valset_nonce != null && Object.hasOwnProperty.call(message, "last_slashed_valset_nonce"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.last_slashed_valset_nonce);
                if (message.last_slashed_batch_block != null && Object.hasOwnProperty.call(message, "last_slashed_batch_block"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.last_slashed_batch_block);
                if (message.last_slashed_logic_call_block != null && Object.hasOwnProperty.call(message, "last_slashed_logic_call_block"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.last_slashed_logic_call_block);
                if (message.last_tx_pool_id != null && Object.hasOwnProperty.call(message, "last_tx_pool_id"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.last_tx_pool_id);
                if (message.last_batch_id != null && Object.hasOwnProperty.call(message, "last_batch_id"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.last_batch_id);
                return writer;
            };

            /**
             * Encodes the specified GravityNonces message, length delimited. Does not implicitly {@link gravity.v1.GravityNonces.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.GravityNonces
             * @static
             * @param {gravity.v1.IGravityNonces} message GravityNonces message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GravityNonces.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GravityNonces message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.GravityNonces
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.GravityNonces} GravityNonces
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GravityNonces.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.GravityNonces();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.latest_valset_nonce = reader.uint64();
                        break;
                    case 2:
                        message.last_observed_nonce = reader.uint64();
                        break;
                    case 3:
                        message.last_slashed_valset_nonce = reader.uint64();
                        break;
                    case 4:
                        message.last_slashed_batch_block = reader.uint64();
                        break;
                    case 5:
                        message.last_slashed_logic_call_block = reader.uint64();
                        break;
                    case 6:
                        message.last_tx_pool_id = reader.uint64();
                        break;
                    case 7:
                        message.last_batch_id = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GravityNonces message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.GravityNonces
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.GravityNonces} GravityNonces
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GravityNonces.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GravityNonces message.
             * @function verify
             * @memberof gravity.v1.GravityNonces
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GravityNonces.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.latest_valset_nonce != null && message.hasOwnProperty("latest_valset_nonce"))
                    if (!$util.isInteger(message.latest_valset_nonce) && !(message.latest_valset_nonce && $util.isInteger(message.latest_valset_nonce.low) && $util.isInteger(message.latest_valset_nonce.high)))
                        return "latest_valset_nonce: integer|Long expected";
                if (message.last_observed_nonce != null && message.hasOwnProperty("last_observed_nonce"))
                    if (!$util.isInteger(message.last_observed_nonce) && !(message.last_observed_nonce && $util.isInteger(message.last_observed_nonce.low) && $util.isInteger(message.last_observed_nonce.high)))
                        return "last_observed_nonce: integer|Long expected";
                if (message.last_slashed_valset_nonce != null && message.hasOwnProperty("last_slashed_valset_nonce"))
                    if (!$util.isInteger(message.last_slashed_valset_nonce) && !(message.last_slashed_valset_nonce && $util.isInteger(message.last_slashed_valset_nonce.low) && $util.isInteger(message.last_slashed_valset_nonce.high)))
                        return "last_slashed_valset_nonce: integer|Long expected";
                if (message.last_slashed_batch_block != null && message.hasOwnProperty("last_slashed_batch_block"))
                    if (!$util.isInteger(message.last_slashed_batch_block) && !(message.last_slashed_batch_block && $util.isInteger(message.last_slashed_batch_block.low) && $util.isInteger(message.last_slashed_batch_block.high)))
                        return "last_slashed_batch_block: integer|Long expected";
                if (message.last_slashed_logic_call_block != null && message.hasOwnProperty("last_slashed_logic_call_block"))
                    if (!$util.isInteger(message.last_slashed_logic_call_block) && !(message.last_slashed_logic_call_block && $util.isInteger(message.last_slashed_logic_call_block.low) && $util.isInteger(message.last_slashed_logic_call_block.high)))
                        return "last_slashed_logic_call_block: integer|Long expected";
                if (message.last_tx_pool_id != null && message.hasOwnProperty("last_tx_pool_id"))
                    if (!$util.isInteger(message.last_tx_pool_id) && !(message.last_tx_pool_id && $util.isInteger(message.last_tx_pool_id.low) && $util.isInteger(message.last_tx_pool_id.high)))
                        return "last_tx_pool_id: integer|Long expected";
                if (message.last_batch_id != null && message.hasOwnProperty("last_batch_id"))
                    if (!$util.isInteger(message.last_batch_id) && !(message.last_batch_id && $util.isInteger(message.last_batch_id.low) && $util.isInteger(message.last_batch_id.high)))
                        return "last_batch_id: integer|Long expected";
                return null;
            };

            /**
             * Creates a GravityNonces message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.GravityNonces
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.GravityNonces} GravityNonces
             */
            GravityNonces.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.GravityNonces)
                    return object;
                let message = new $root.gravity.v1.GravityNonces();
                if (object.latest_valset_nonce != null)
                    if ($util.Long)
                        (message.latest_valset_nonce = $util.Long.fromValue(object.latest_valset_nonce)).unsigned = true;
                    else if (typeof object.latest_valset_nonce === "string")
                        message.latest_valset_nonce = parseInt(object.latest_valset_nonce, 10);
                    else if (typeof object.latest_valset_nonce === "number")
                        message.latest_valset_nonce = object.latest_valset_nonce;
                    else if (typeof object.latest_valset_nonce === "object")
                        message.latest_valset_nonce = new $util.LongBits(object.latest_valset_nonce.low >>> 0, object.latest_valset_nonce.high >>> 0).toNumber(true);
                if (object.last_observed_nonce != null)
                    if ($util.Long)
                        (message.last_observed_nonce = $util.Long.fromValue(object.last_observed_nonce)).unsigned = true;
                    else if (typeof object.last_observed_nonce === "string")
                        message.last_observed_nonce = parseInt(object.last_observed_nonce, 10);
                    else if (typeof object.last_observed_nonce === "number")
                        message.last_observed_nonce = object.last_observed_nonce;
                    else if (typeof object.last_observed_nonce === "object")
                        message.last_observed_nonce = new $util.LongBits(object.last_observed_nonce.low >>> 0, object.last_observed_nonce.high >>> 0).toNumber(true);
                if (object.last_slashed_valset_nonce != null)
                    if ($util.Long)
                        (message.last_slashed_valset_nonce = $util.Long.fromValue(object.last_slashed_valset_nonce)).unsigned = true;
                    else if (typeof object.last_slashed_valset_nonce === "string")
                        message.last_slashed_valset_nonce = parseInt(object.last_slashed_valset_nonce, 10);
                    else if (typeof object.last_slashed_valset_nonce === "number")
                        message.last_slashed_valset_nonce = object.last_slashed_valset_nonce;
                    else if (typeof object.last_slashed_valset_nonce === "object")
                        message.last_slashed_valset_nonce = new $util.LongBits(object.last_slashed_valset_nonce.low >>> 0, object.last_slashed_valset_nonce.high >>> 0).toNumber(true);
                if (object.last_slashed_batch_block != null)
                    if ($util.Long)
                        (message.last_slashed_batch_block = $util.Long.fromValue(object.last_slashed_batch_block)).unsigned = true;
                    else if (typeof object.last_slashed_batch_block === "string")
                        message.last_slashed_batch_block = parseInt(object.last_slashed_batch_block, 10);
                    else if (typeof object.last_slashed_batch_block === "number")
                        message.last_slashed_batch_block = object.last_slashed_batch_block;
                    else if (typeof object.last_slashed_batch_block === "object")
                        message.last_slashed_batch_block = new $util.LongBits(object.last_slashed_batch_block.low >>> 0, object.last_slashed_batch_block.high >>> 0).toNumber(true);
                if (object.last_slashed_logic_call_block != null)
                    if ($util.Long)
                        (message.last_slashed_logic_call_block = $util.Long.fromValue(object.last_slashed_logic_call_block)).unsigned = true;
                    else if (typeof object.last_slashed_logic_call_block === "string")
                        message.last_slashed_logic_call_block = parseInt(object.last_slashed_logic_call_block, 10);
                    else if (typeof object.last_slashed_logic_call_block === "number")
                        message.last_slashed_logic_call_block = object.last_slashed_logic_call_block;
                    else if (typeof object.last_slashed_logic_call_block === "object")
                        message.last_slashed_logic_call_block = new $util.LongBits(object.last_slashed_logic_call_block.low >>> 0, object.last_slashed_logic_call_block.high >>> 0).toNumber(true);
                if (object.last_tx_pool_id != null)
                    if ($util.Long)
                        (message.last_tx_pool_id = $util.Long.fromValue(object.last_tx_pool_id)).unsigned = true;
                    else if (typeof object.last_tx_pool_id === "string")
                        message.last_tx_pool_id = parseInt(object.last_tx_pool_id, 10);
                    else if (typeof object.last_tx_pool_id === "number")
                        message.last_tx_pool_id = object.last_tx_pool_id;
                    else if (typeof object.last_tx_pool_id === "object")
                        message.last_tx_pool_id = new $util.LongBits(object.last_tx_pool_id.low >>> 0, object.last_tx_pool_id.high >>> 0).toNumber(true);
                if (object.last_batch_id != null)
                    if ($util.Long)
                        (message.last_batch_id = $util.Long.fromValue(object.last_batch_id)).unsigned = true;
                    else if (typeof object.last_batch_id === "string")
                        message.last_batch_id = parseInt(object.last_batch_id, 10);
                    else if (typeof object.last_batch_id === "number")
                        message.last_batch_id = object.last_batch_id;
                    else if (typeof object.last_batch_id === "object")
                        message.last_batch_id = new $util.LongBits(object.last_batch_id.low >>> 0, object.last_batch_id.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GravityNonces message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.GravityNonces
             * @static
             * @param {gravity.v1.GravityNonces} message GravityNonces
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GravityNonces.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.latest_valset_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.latest_valset_nonce = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.last_observed_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.last_observed_nonce = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.last_slashed_valset_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.last_slashed_valset_nonce = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.last_slashed_batch_block = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.last_slashed_batch_block = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.last_slashed_logic_call_block = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.last_slashed_logic_call_block = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.last_tx_pool_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.last_tx_pool_id = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.last_batch_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.last_batch_id = options.longs === String ? "0" : 0;
                }
                if (message.latest_valset_nonce != null && message.hasOwnProperty("latest_valset_nonce"))
                    if (typeof message.latest_valset_nonce === "number")
                        object.latest_valset_nonce = options.longs === String ? String(message.latest_valset_nonce) : message.latest_valset_nonce;
                    else
                        object.latest_valset_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.latest_valset_nonce) : options.longs === Number ? new $util.LongBits(message.latest_valset_nonce.low >>> 0, message.latest_valset_nonce.high >>> 0).toNumber(true) : message.latest_valset_nonce;
                if (message.last_observed_nonce != null && message.hasOwnProperty("last_observed_nonce"))
                    if (typeof message.last_observed_nonce === "number")
                        object.last_observed_nonce = options.longs === String ? String(message.last_observed_nonce) : message.last_observed_nonce;
                    else
                        object.last_observed_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.last_observed_nonce) : options.longs === Number ? new $util.LongBits(message.last_observed_nonce.low >>> 0, message.last_observed_nonce.high >>> 0).toNumber(true) : message.last_observed_nonce;
                if (message.last_slashed_valset_nonce != null && message.hasOwnProperty("last_slashed_valset_nonce"))
                    if (typeof message.last_slashed_valset_nonce === "number")
                        object.last_slashed_valset_nonce = options.longs === String ? String(message.last_slashed_valset_nonce) : message.last_slashed_valset_nonce;
                    else
                        object.last_slashed_valset_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.last_slashed_valset_nonce) : options.longs === Number ? new $util.LongBits(message.last_slashed_valset_nonce.low >>> 0, message.last_slashed_valset_nonce.high >>> 0).toNumber(true) : message.last_slashed_valset_nonce;
                if (message.last_slashed_batch_block != null && message.hasOwnProperty("last_slashed_batch_block"))
                    if (typeof message.last_slashed_batch_block === "number")
                        object.last_slashed_batch_block = options.longs === String ? String(message.last_slashed_batch_block) : message.last_slashed_batch_block;
                    else
                        object.last_slashed_batch_block = options.longs === String ? $util.Long.prototype.toString.call(message.last_slashed_batch_block) : options.longs === Number ? new $util.LongBits(message.last_slashed_batch_block.low >>> 0, message.last_slashed_batch_block.high >>> 0).toNumber(true) : message.last_slashed_batch_block;
                if (message.last_slashed_logic_call_block != null && message.hasOwnProperty("last_slashed_logic_call_block"))
                    if (typeof message.last_slashed_logic_call_block === "number")
                        object.last_slashed_logic_call_block = options.longs === String ? String(message.last_slashed_logic_call_block) : message.last_slashed_logic_call_block;
                    else
                        object.last_slashed_logic_call_block = options.longs === String ? $util.Long.prototype.toString.call(message.last_slashed_logic_call_block) : options.longs === Number ? new $util.LongBits(message.last_slashed_logic_call_block.low >>> 0, message.last_slashed_logic_call_block.high >>> 0).toNumber(true) : message.last_slashed_logic_call_block;
                if (message.last_tx_pool_id != null && message.hasOwnProperty("last_tx_pool_id"))
                    if (typeof message.last_tx_pool_id === "number")
                        object.last_tx_pool_id = options.longs === String ? String(message.last_tx_pool_id) : message.last_tx_pool_id;
                    else
                        object.last_tx_pool_id = options.longs === String ? $util.Long.prototype.toString.call(message.last_tx_pool_id) : options.longs === Number ? new $util.LongBits(message.last_tx_pool_id.low >>> 0, message.last_tx_pool_id.high >>> 0).toNumber(true) : message.last_tx_pool_id;
                if (message.last_batch_id != null && message.hasOwnProperty("last_batch_id"))
                    if (typeof message.last_batch_id === "number")
                        object.last_batch_id = options.longs === String ? String(message.last_batch_id) : message.last_batch_id;
                    else
                        object.last_batch_id = options.longs === String ? $util.Long.prototype.toString.call(message.last_batch_id) : options.longs === Number ? new $util.LongBits(message.last_batch_id.low >>> 0, message.last_batch_id.high >>> 0).toNumber(true) : message.last_batch_id;
                return object;
            };

            /**
             * Converts this GravityNonces to JSON.
             * @function toJSON
             * @memberof gravity.v1.GravityNonces
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GravityNonces.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GravityNonces;
        })();

        v1.Msg = (function() {

            /**
             * Constructs a new Msg service.
             * @memberof gravity.v1
             * @classdesc Represents a Msg
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Msg(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

            /**
             * Callback as used by {@link gravity.v1.Msg#valsetConfirm}.
             * @memberof gravity.v1.Msg
             * @typedef ValsetConfirmCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.MsgValsetConfirmResponse} [response] MsgValsetConfirmResponse
             */

            /**
             * Calls ValsetConfirm.
             * @function valsetConfirm
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgValsetConfirm} request MsgValsetConfirm message or plain object
             * @param {gravity.v1.Msg.ValsetConfirmCallback} callback Node-style callback called with the error, if any, and MsgValsetConfirmResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Msg.prototype.valsetConfirm = function valsetConfirm(request, callback) {
                return this.rpcCall(valsetConfirm, $root.gravity.v1.MsgValsetConfirm, $root.gravity.v1.MsgValsetConfirmResponse, request, callback);
            }, "name", { value: "ValsetConfirm" });

            /**
             * Calls ValsetConfirm.
             * @function valsetConfirm
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgValsetConfirm} request MsgValsetConfirm message or plain object
             * @returns {Promise<gravity.v1.MsgValsetConfirmResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Msg#sendToEth}.
             * @memberof gravity.v1.Msg
             * @typedef SendToEthCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.MsgSendToEthResponse} [response] MsgSendToEthResponse
             */

            /**
             * Calls SendToEth.
             * @function sendToEth
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgSendToEth} request MsgSendToEth message or plain object
             * @param {gravity.v1.Msg.SendToEthCallback} callback Node-style callback called with the error, if any, and MsgSendToEthResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Msg.prototype.sendToEth = function sendToEth(request, callback) {
                return this.rpcCall(sendToEth, $root.gravity.v1.MsgSendToEth, $root.gravity.v1.MsgSendToEthResponse, request, callback);
            }, "name", { value: "SendToEth" });

            /**
             * Calls SendToEth.
             * @function sendToEth
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgSendToEth} request MsgSendToEth message or plain object
             * @returns {Promise<gravity.v1.MsgSendToEthResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Msg#requestBatch}.
             * @memberof gravity.v1.Msg
             * @typedef RequestBatchCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.MsgRequestBatchResponse} [response] MsgRequestBatchResponse
             */

            /**
             * Calls RequestBatch.
             * @function requestBatch
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgRequestBatch} request MsgRequestBatch message or plain object
             * @param {gravity.v1.Msg.RequestBatchCallback} callback Node-style callback called with the error, if any, and MsgRequestBatchResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Msg.prototype.requestBatch = function requestBatch(request, callback) {
                return this.rpcCall(requestBatch, $root.gravity.v1.MsgRequestBatch, $root.gravity.v1.MsgRequestBatchResponse, request, callback);
            }, "name", { value: "RequestBatch" });

            /**
             * Calls RequestBatch.
             * @function requestBatch
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgRequestBatch} request MsgRequestBatch message or plain object
             * @returns {Promise<gravity.v1.MsgRequestBatchResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Msg#confirmBatch}.
             * @memberof gravity.v1.Msg
             * @typedef ConfirmBatchCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.MsgConfirmBatchResponse} [response] MsgConfirmBatchResponse
             */

            /**
             * Calls ConfirmBatch.
             * @function confirmBatch
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgConfirmBatch} request MsgConfirmBatch message or plain object
             * @param {gravity.v1.Msg.ConfirmBatchCallback} callback Node-style callback called with the error, if any, and MsgConfirmBatchResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Msg.prototype.confirmBatch = function confirmBatch(request, callback) {
                return this.rpcCall(confirmBatch, $root.gravity.v1.MsgConfirmBatch, $root.gravity.v1.MsgConfirmBatchResponse, request, callback);
            }, "name", { value: "ConfirmBatch" });

            /**
             * Calls ConfirmBatch.
             * @function confirmBatch
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgConfirmBatch} request MsgConfirmBatch message or plain object
             * @returns {Promise<gravity.v1.MsgConfirmBatchResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Msg#confirmLogicCall}.
             * @memberof gravity.v1.Msg
             * @typedef ConfirmLogicCallCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.MsgConfirmLogicCallResponse} [response] MsgConfirmLogicCallResponse
             */

            /**
             * Calls ConfirmLogicCall.
             * @function confirmLogicCall
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgConfirmLogicCall} request MsgConfirmLogicCall message or plain object
             * @param {gravity.v1.Msg.ConfirmLogicCallCallback} callback Node-style callback called with the error, if any, and MsgConfirmLogicCallResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Msg.prototype.confirmLogicCall = function confirmLogicCall(request, callback) {
                return this.rpcCall(confirmLogicCall, $root.gravity.v1.MsgConfirmLogicCall, $root.gravity.v1.MsgConfirmLogicCallResponse, request, callback);
            }, "name", { value: "ConfirmLogicCall" });

            /**
             * Calls ConfirmLogicCall.
             * @function confirmLogicCall
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgConfirmLogicCall} request MsgConfirmLogicCall message or plain object
             * @returns {Promise<gravity.v1.MsgConfirmLogicCallResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Msg#sendToCosmosClaim}.
             * @memberof gravity.v1.Msg
             * @typedef SendToCosmosClaimCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.MsgSendToCosmosClaimResponse} [response] MsgSendToCosmosClaimResponse
             */

            /**
             * Calls SendToCosmosClaim.
             * @function sendToCosmosClaim
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgSendToCosmosClaim} request MsgSendToCosmosClaim message or plain object
             * @param {gravity.v1.Msg.SendToCosmosClaimCallback} callback Node-style callback called with the error, if any, and MsgSendToCosmosClaimResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Msg.prototype.sendToCosmosClaim = function sendToCosmosClaim(request, callback) {
                return this.rpcCall(sendToCosmosClaim, $root.gravity.v1.MsgSendToCosmosClaim, $root.gravity.v1.MsgSendToCosmosClaimResponse, request, callback);
            }, "name", { value: "SendToCosmosClaim" });

            /**
             * Calls SendToCosmosClaim.
             * @function sendToCosmosClaim
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgSendToCosmosClaim} request MsgSendToCosmosClaim message or plain object
             * @returns {Promise<gravity.v1.MsgSendToCosmosClaimResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Msg#batchSendToEthClaim}.
             * @memberof gravity.v1.Msg
             * @typedef BatchSendToEthClaimCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.MsgBatchSendToEthClaimResponse} [response] MsgBatchSendToEthClaimResponse
             */

            /**
             * Calls BatchSendToEthClaim.
             * @function batchSendToEthClaim
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgBatchSendToEthClaim} request MsgBatchSendToEthClaim message or plain object
             * @param {gravity.v1.Msg.BatchSendToEthClaimCallback} callback Node-style callback called with the error, if any, and MsgBatchSendToEthClaimResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Msg.prototype.batchSendToEthClaim = function batchSendToEthClaim(request, callback) {
                return this.rpcCall(batchSendToEthClaim, $root.gravity.v1.MsgBatchSendToEthClaim, $root.gravity.v1.MsgBatchSendToEthClaimResponse, request, callback);
            }, "name", { value: "BatchSendToEthClaim" });

            /**
             * Calls BatchSendToEthClaim.
             * @function batchSendToEthClaim
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgBatchSendToEthClaim} request MsgBatchSendToEthClaim message or plain object
             * @returns {Promise<gravity.v1.MsgBatchSendToEthClaimResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Msg#valsetUpdateClaim}.
             * @memberof gravity.v1.Msg
             * @typedef ValsetUpdateClaimCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.MsgValsetUpdatedClaimResponse} [response] MsgValsetUpdatedClaimResponse
             */

            /**
             * Calls ValsetUpdateClaim.
             * @function valsetUpdateClaim
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgValsetUpdatedClaim} request MsgValsetUpdatedClaim message or plain object
             * @param {gravity.v1.Msg.ValsetUpdateClaimCallback} callback Node-style callback called with the error, if any, and MsgValsetUpdatedClaimResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Msg.prototype.valsetUpdateClaim = function valsetUpdateClaim(request, callback) {
                return this.rpcCall(valsetUpdateClaim, $root.gravity.v1.MsgValsetUpdatedClaim, $root.gravity.v1.MsgValsetUpdatedClaimResponse, request, callback);
            }, "name", { value: "ValsetUpdateClaim" });

            /**
             * Calls ValsetUpdateClaim.
             * @function valsetUpdateClaim
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgValsetUpdatedClaim} request MsgValsetUpdatedClaim message or plain object
             * @returns {Promise<gravity.v1.MsgValsetUpdatedClaimResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Msg#eRC20DeployedClaim}.
             * @memberof gravity.v1.Msg
             * @typedef ERC20DeployedClaimCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.MsgERC20DeployedClaimResponse} [response] MsgERC20DeployedClaimResponse
             */

            /**
             * Calls ERC20DeployedClaim.
             * @function eRC20DeployedClaim
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgERC20DeployedClaim} request MsgERC20DeployedClaim message or plain object
             * @param {gravity.v1.Msg.ERC20DeployedClaimCallback} callback Node-style callback called with the error, if any, and MsgERC20DeployedClaimResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Msg.prototype.eRC20DeployedClaim = function eRC20DeployedClaim(request, callback) {
                return this.rpcCall(eRC20DeployedClaim, $root.gravity.v1.MsgERC20DeployedClaim, $root.gravity.v1.MsgERC20DeployedClaimResponse, request, callback);
            }, "name", { value: "ERC20DeployedClaim" });

            /**
             * Calls ERC20DeployedClaim.
             * @function eRC20DeployedClaim
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgERC20DeployedClaim} request MsgERC20DeployedClaim message or plain object
             * @returns {Promise<gravity.v1.MsgERC20DeployedClaimResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Msg#logicCallExecutedClaim}.
             * @memberof gravity.v1.Msg
             * @typedef LogicCallExecutedClaimCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.MsgLogicCallExecutedClaimResponse} [response] MsgLogicCallExecutedClaimResponse
             */

            /**
             * Calls LogicCallExecutedClaim.
             * @function logicCallExecutedClaim
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgLogicCallExecutedClaim} request MsgLogicCallExecutedClaim message or plain object
             * @param {gravity.v1.Msg.LogicCallExecutedClaimCallback} callback Node-style callback called with the error, if any, and MsgLogicCallExecutedClaimResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Msg.prototype.logicCallExecutedClaim = function logicCallExecutedClaim(request, callback) {
                return this.rpcCall(logicCallExecutedClaim, $root.gravity.v1.MsgLogicCallExecutedClaim, $root.gravity.v1.MsgLogicCallExecutedClaimResponse, request, callback);
            }, "name", { value: "LogicCallExecutedClaim" });

            /**
             * Calls LogicCallExecutedClaim.
             * @function logicCallExecutedClaim
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgLogicCallExecutedClaim} request MsgLogicCallExecutedClaim message or plain object
             * @returns {Promise<gravity.v1.MsgLogicCallExecutedClaimResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Msg#setOrchestratorAddress}.
             * @memberof gravity.v1.Msg
             * @typedef SetOrchestratorAddressCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.MsgSetOrchestratorAddressResponse} [response] MsgSetOrchestratorAddressResponse
             */

            /**
             * Calls SetOrchestratorAddress.
             * @function setOrchestratorAddress
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgSetOrchestratorAddress} request MsgSetOrchestratorAddress message or plain object
             * @param {gravity.v1.Msg.SetOrchestratorAddressCallback} callback Node-style callback called with the error, if any, and MsgSetOrchestratorAddressResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Msg.prototype.setOrchestratorAddress = function setOrchestratorAddress(request, callback) {
                return this.rpcCall(setOrchestratorAddress, $root.gravity.v1.MsgSetOrchestratorAddress, $root.gravity.v1.MsgSetOrchestratorAddressResponse, request, callback);
            }, "name", { value: "SetOrchestratorAddress" });

            /**
             * Calls SetOrchestratorAddress.
             * @function setOrchestratorAddress
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgSetOrchestratorAddress} request MsgSetOrchestratorAddress message or plain object
             * @returns {Promise<gravity.v1.MsgSetOrchestratorAddressResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Msg#cancelSendToEth}.
             * @memberof gravity.v1.Msg
             * @typedef CancelSendToEthCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.MsgCancelSendToEthResponse} [response] MsgCancelSendToEthResponse
             */

            /**
             * Calls CancelSendToEth.
             * @function cancelSendToEth
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgCancelSendToEth} request MsgCancelSendToEth message or plain object
             * @param {gravity.v1.Msg.CancelSendToEthCallback} callback Node-style callback called with the error, if any, and MsgCancelSendToEthResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Msg.prototype.cancelSendToEth = function cancelSendToEth(request, callback) {
                return this.rpcCall(cancelSendToEth, $root.gravity.v1.MsgCancelSendToEth, $root.gravity.v1.MsgCancelSendToEthResponse, request, callback);
            }, "name", { value: "CancelSendToEth" });

            /**
             * Calls CancelSendToEth.
             * @function cancelSendToEth
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgCancelSendToEth} request MsgCancelSendToEth message or plain object
             * @returns {Promise<gravity.v1.MsgCancelSendToEthResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link gravity.v1.Msg#submitBadSignatureEvidence}.
             * @memberof gravity.v1.Msg
             * @typedef SubmitBadSignatureEvidenceCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gravity.v1.MsgSubmitBadSignatureEvidenceResponse} [response] MsgSubmitBadSignatureEvidenceResponse
             */

            /**
             * Calls SubmitBadSignatureEvidence.
             * @function submitBadSignatureEvidence
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgSubmitBadSignatureEvidence} request MsgSubmitBadSignatureEvidence message or plain object
             * @param {gravity.v1.Msg.SubmitBadSignatureEvidenceCallback} callback Node-style callback called with the error, if any, and MsgSubmitBadSignatureEvidenceResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Msg.prototype.submitBadSignatureEvidence = function submitBadSignatureEvidence(request, callback) {
                return this.rpcCall(submitBadSignatureEvidence, $root.gravity.v1.MsgSubmitBadSignatureEvidence, $root.gravity.v1.MsgSubmitBadSignatureEvidenceResponse, request, callback);
            }, "name", { value: "SubmitBadSignatureEvidence" });

            /**
             * Calls SubmitBadSignatureEvidence.
             * @function submitBadSignatureEvidence
             * @memberof gravity.v1.Msg
             * @instance
             * @param {gravity.v1.IMsgSubmitBadSignatureEvidence} request MsgSubmitBadSignatureEvidence message or plain object
             * @returns {Promise<gravity.v1.MsgSubmitBadSignatureEvidenceResponse>} Promise
             * @variation 2
             */

            return Msg;
        })();

        v1.MsgSetOrchestratorAddress = (function() {

            /**
             * Properties of a MsgSetOrchestratorAddress.
             * @memberof gravity.v1
             * @interface IMsgSetOrchestratorAddress
             * @property {string|null} [validator] MsgSetOrchestratorAddress validator
             * @property {string|null} [orchestrator] MsgSetOrchestratorAddress orchestrator
             * @property {string|null} [eth_address] MsgSetOrchestratorAddress eth_address
             */

            /**
             * Constructs a new MsgSetOrchestratorAddress.
             * @memberof gravity.v1
             * @classdesc Represents a MsgSetOrchestratorAddress.
             * @implements IMsgSetOrchestratorAddress
             * @constructor
             * @param {gravity.v1.IMsgSetOrchestratorAddress=} [properties] Properties to set
             */
            function MsgSetOrchestratorAddress(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgSetOrchestratorAddress validator.
             * @member {string} validator
             * @memberof gravity.v1.MsgSetOrchestratorAddress
             * @instance
             */
            MsgSetOrchestratorAddress.prototype.validator = "";

            /**
             * MsgSetOrchestratorAddress orchestrator.
             * @member {string} orchestrator
             * @memberof gravity.v1.MsgSetOrchestratorAddress
             * @instance
             */
            MsgSetOrchestratorAddress.prototype.orchestrator = "";

            /**
             * MsgSetOrchestratorAddress eth_address.
             * @member {string} eth_address
             * @memberof gravity.v1.MsgSetOrchestratorAddress
             * @instance
             */
            MsgSetOrchestratorAddress.prototype.eth_address = "";

            /**
             * Encodes the specified MsgSetOrchestratorAddress message. Does not implicitly {@link gravity.v1.MsgSetOrchestratorAddress.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgSetOrchestratorAddress
             * @static
             * @param {gravity.v1.IMsgSetOrchestratorAddress} message MsgSetOrchestratorAddress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSetOrchestratorAddress.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.validator != null && Object.hasOwnProperty.call(message, "validator"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.validator);
                if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.orchestrator);
                if (message.eth_address != null && Object.hasOwnProperty.call(message, "eth_address"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.eth_address);
                return writer;
            };

            /**
             * Encodes the specified MsgSetOrchestratorAddress message, length delimited. Does not implicitly {@link gravity.v1.MsgSetOrchestratorAddress.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgSetOrchestratorAddress
             * @static
             * @param {gravity.v1.IMsgSetOrchestratorAddress} message MsgSetOrchestratorAddress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSetOrchestratorAddress.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgSetOrchestratorAddress message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgSetOrchestratorAddress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgSetOrchestratorAddress} MsgSetOrchestratorAddress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSetOrchestratorAddress.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSetOrchestratorAddress();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.validator = reader.string();
                        break;
                    case 2:
                        message.orchestrator = reader.string();
                        break;
                    case 3:
                        message.eth_address = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgSetOrchestratorAddress message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgSetOrchestratorAddress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgSetOrchestratorAddress} MsgSetOrchestratorAddress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSetOrchestratorAddress.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgSetOrchestratorAddress message.
             * @function verify
             * @memberof gravity.v1.MsgSetOrchestratorAddress
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgSetOrchestratorAddress.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.validator != null && message.hasOwnProperty("validator"))
                    if (!$util.isString(message.validator))
                        return "validator: string expected";
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    if (!$util.isString(message.orchestrator))
                        return "orchestrator: string expected";
                if (message.eth_address != null && message.hasOwnProperty("eth_address"))
                    if (!$util.isString(message.eth_address))
                        return "eth_address: string expected";
                return null;
            };

            /**
             * Creates a MsgSetOrchestratorAddress message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgSetOrchestratorAddress
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgSetOrchestratorAddress} MsgSetOrchestratorAddress
             */
            MsgSetOrchestratorAddress.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgSetOrchestratorAddress)
                    return object;
                let message = new $root.gravity.v1.MsgSetOrchestratorAddress();
                if (object.validator != null)
                    message.validator = String(object.validator);
                if (object.orchestrator != null)
                    message.orchestrator = String(object.orchestrator);
                if (object.eth_address != null)
                    message.eth_address = String(object.eth_address);
                return message;
            };

            /**
             * Creates a plain object from a MsgSetOrchestratorAddress message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgSetOrchestratorAddress
             * @static
             * @param {gravity.v1.MsgSetOrchestratorAddress} message MsgSetOrchestratorAddress
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgSetOrchestratorAddress.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.validator = "";
                    object.orchestrator = "";
                    object.eth_address = "";
                }
                if (message.validator != null && message.hasOwnProperty("validator"))
                    object.validator = message.validator;
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    object.orchestrator = message.orchestrator;
                if (message.eth_address != null && message.hasOwnProperty("eth_address"))
                    object.eth_address = message.eth_address;
                return object;
            };

            /**
             * Converts this MsgSetOrchestratorAddress to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgSetOrchestratorAddress
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgSetOrchestratorAddress.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgSetOrchestratorAddress;
        })();

        v1.MsgSetOrchestratorAddressResponse = (function() {

            /**
             * Properties of a MsgSetOrchestratorAddressResponse.
             * @memberof gravity.v1
             * @interface IMsgSetOrchestratorAddressResponse
             */

            /**
             * Constructs a new MsgSetOrchestratorAddressResponse.
             * @memberof gravity.v1
             * @classdesc Represents a MsgSetOrchestratorAddressResponse.
             * @implements IMsgSetOrchestratorAddressResponse
             * @constructor
             * @param {gravity.v1.IMsgSetOrchestratorAddressResponse=} [properties] Properties to set
             */
            function MsgSetOrchestratorAddressResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified MsgSetOrchestratorAddressResponse message. Does not implicitly {@link gravity.v1.MsgSetOrchestratorAddressResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
             * @static
             * @param {gravity.v1.IMsgSetOrchestratorAddressResponse} message MsgSetOrchestratorAddressResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSetOrchestratorAddressResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified MsgSetOrchestratorAddressResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgSetOrchestratorAddressResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
             * @static
             * @param {gravity.v1.IMsgSetOrchestratorAddressResponse} message MsgSetOrchestratorAddressResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSetOrchestratorAddressResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgSetOrchestratorAddressResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgSetOrchestratorAddressResponse} MsgSetOrchestratorAddressResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSetOrchestratorAddressResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSetOrchestratorAddressResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgSetOrchestratorAddressResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgSetOrchestratorAddressResponse} MsgSetOrchestratorAddressResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSetOrchestratorAddressResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgSetOrchestratorAddressResponse message.
             * @function verify
             * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgSetOrchestratorAddressResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a MsgSetOrchestratorAddressResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgSetOrchestratorAddressResponse} MsgSetOrchestratorAddressResponse
             */
            MsgSetOrchestratorAddressResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgSetOrchestratorAddressResponse)
                    return object;
                return new $root.gravity.v1.MsgSetOrchestratorAddressResponse();
            };

            /**
             * Creates a plain object from a MsgSetOrchestratorAddressResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
             * @static
             * @param {gravity.v1.MsgSetOrchestratorAddressResponse} message MsgSetOrchestratorAddressResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgSetOrchestratorAddressResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this MsgSetOrchestratorAddressResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgSetOrchestratorAddressResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgSetOrchestratorAddressResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgSetOrchestratorAddressResponse;
        })();

        v1.MsgValsetConfirm = (function() {

            /**
             * Properties of a MsgValsetConfirm.
             * @memberof gravity.v1
             * @interface IMsgValsetConfirm
             * @property {Long|null} [nonce] MsgValsetConfirm nonce
             * @property {string|null} [orchestrator] MsgValsetConfirm orchestrator
             * @property {string|null} [eth_address] MsgValsetConfirm eth_address
             * @property {string|null} [signature] MsgValsetConfirm signature
             */

            /**
             * Constructs a new MsgValsetConfirm.
             * @memberof gravity.v1
             * @classdesc Represents a MsgValsetConfirm.
             * @implements IMsgValsetConfirm
             * @constructor
             * @param {gravity.v1.IMsgValsetConfirm=} [properties] Properties to set
             */
            function MsgValsetConfirm(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgValsetConfirm nonce.
             * @member {Long} nonce
             * @memberof gravity.v1.MsgValsetConfirm
             * @instance
             */
            MsgValsetConfirm.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgValsetConfirm orchestrator.
             * @member {string} orchestrator
             * @memberof gravity.v1.MsgValsetConfirm
             * @instance
             */
            MsgValsetConfirm.prototype.orchestrator = "";

            /**
             * MsgValsetConfirm eth_address.
             * @member {string} eth_address
             * @memberof gravity.v1.MsgValsetConfirm
             * @instance
             */
            MsgValsetConfirm.prototype.eth_address = "";

            /**
             * MsgValsetConfirm signature.
             * @member {string} signature
             * @memberof gravity.v1.MsgValsetConfirm
             * @instance
             */
            MsgValsetConfirm.prototype.signature = "";

            /**
             * Encodes the specified MsgValsetConfirm message. Does not implicitly {@link gravity.v1.MsgValsetConfirm.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgValsetConfirm
             * @static
             * @param {gravity.v1.IMsgValsetConfirm} message MsgValsetConfirm message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgValsetConfirm.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.orchestrator);
                if (message.eth_address != null && Object.hasOwnProperty.call(message, "eth_address"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.eth_address);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.signature);
                return writer;
            };

            /**
             * Encodes the specified MsgValsetConfirm message, length delimited. Does not implicitly {@link gravity.v1.MsgValsetConfirm.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgValsetConfirm
             * @static
             * @param {gravity.v1.IMsgValsetConfirm} message MsgValsetConfirm message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgValsetConfirm.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgValsetConfirm message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgValsetConfirm
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgValsetConfirm} MsgValsetConfirm
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgValsetConfirm.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgValsetConfirm();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        message.orchestrator = reader.string();
                        break;
                    case 3:
                        message.eth_address = reader.string();
                        break;
                    case 4:
                        message.signature = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgValsetConfirm message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgValsetConfirm
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgValsetConfirm} MsgValsetConfirm
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgValsetConfirm.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgValsetConfirm message.
             * @function verify
             * @memberof gravity.v1.MsgValsetConfirm
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgValsetConfirm.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    if (!$util.isString(message.orchestrator))
                        return "orchestrator: string expected";
                if (message.eth_address != null && message.hasOwnProperty("eth_address"))
                    if (!$util.isString(message.eth_address))
                        return "eth_address: string expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!$util.isString(message.signature))
                        return "signature: string expected";
                return null;
            };

            /**
             * Creates a MsgValsetConfirm message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgValsetConfirm
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgValsetConfirm} MsgValsetConfirm
             */
            MsgValsetConfirm.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgValsetConfirm)
                    return object;
                let message = new $root.gravity.v1.MsgValsetConfirm();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.orchestrator != null)
                    message.orchestrator = String(object.orchestrator);
                if (object.eth_address != null)
                    message.eth_address = String(object.eth_address);
                if (object.signature != null)
                    message.signature = String(object.signature);
                return message;
            };

            /**
             * Creates a plain object from a MsgValsetConfirm message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgValsetConfirm
             * @static
             * @param {gravity.v1.MsgValsetConfirm} message MsgValsetConfirm
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgValsetConfirm.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    object.orchestrator = "";
                    object.eth_address = "";
                    object.signature = "";
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    object.orchestrator = message.orchestrator;
                if (message.eth_address != null && message.hasOwnProperty("eth_address"))
                    object.eth_address = message.eth_address;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = message.signature;
                return object;
            };

            /**
             * Converts this MsgValsetConfirm to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgValsetConfirm
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgValsetConfirm.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgValsetConfirm;
        })();

        v1.MsgValsetConfirmResponse = (function() {

            /**
             * Properties of a MsgValsetConfirmResponse.
             * @memberof gravity.v1
             * @interface IMsgValsetConfirmResponse
             */

            /**
             * Constructs a new MsgValsetConfirmResponse.
             * @memberof gravity.v1
             * @classdesc Represents a MsgValsetConfirmResponse.
             * @implements IMsgValsetConfirmResponse
             * @constructor
             * @param {gravity.v1.IMsgValsetConfirmResponse=} [properties] Properties to set
             */
            function MsgValsetConfirmResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified MsgValsetConfirmResponse message. Does not implicitly {@link gravity.v1.MsgValsetConfirmResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgValsetConfirmResponse
             * @static
             * @param {gravity.v1.IMsgValsetConfirmResponse} message MsgValsetConfirmResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgValsetConfirmResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified MsgValsetConfirmResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgValsetConfirmResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgValsetConfirmResponse
             * @static
             * @param {gravity.v1.IMsgValsetConfirmResponse} message MsgValsetConfirmResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgValsetConfirmResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgValsetConfirmResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgValsetConfirmResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgValsetConfirmResponse} MsgValsetConfirmResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgValsetConfirmResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgValsetConfirmResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgValsetConfirmResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgValsetConfirmResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgValsetConfirmResponse} MsgValsetConfirmResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgValsetConfirmResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgValsetConfirmResponse message.
             * @function verify
             * @memberof gravity.v1.MsgValsetConfirmResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgValsetConfirmResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a MsgValsetConfirmResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgValsetConfirmResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgValsetConfirmResponse} MsgValsetConfirmResponse
             */
            MsgValsetConfirmResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgValsetConfirmResponse)
                    return object;
                return new $root.gravity.v1.MsgValsetConfirmResponse();
            };

            /**
             * Creates a plain object from a MsgValsetConfirmResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgValsetConfirmResponse
             * @static
             * @param {gravity.v1.MsgValsetConfirmResponse} message MsgValsetConfirmResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgValsetConfirmResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this MsgValsetConfirmResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgValsetConfirmResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgValsetConfirmResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgValsetConfirmResponse;
        })();

        v1.MsgSendToEth = (function() {

            /**
             * Properties of a MsgSendToEth.
             * @memberof gravity.v1
             * @interface IMsgSendToEth
             * @property {string|null} [sender] MsgSendToEth sender
             * @property {string|null} [eth_dest] MsgSendToEth eth_dest
             * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgSendToEth amount
             * @property {cosmos.base.v1beta1.ICoin|null} [bridge_fee] MsgSendToEth bridge_fee
             */

            /**
             * Constructs a new MsgSendToEth.
             * @memberof gravity.v1
             * @classdesc Represents a MsgSendToEth.
             * @implements IMsgSendToEth
             * @constructor
             * @param {gravity.v1.IMsgSendToEth=} [properties] Properties to set
             */
            function MsgSendToEth(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgSendToEth sender.
             * @member {string} sender
             * @memberof gravity.v1.MsgSendToEth
             * @instance
             */
            MsgSendToEth.prototype.sender = "";

            /**
             * MsgSendToEth eth_dest.
             * @member {string} eth_dest
             * @memberof gravity.v1.MsgSendToEth
             * @instance
             */
            MsgSendToEth.prototype.eth_dest = "";

            /**
             * MsgSendToEth amount.
             * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
             * @memberof gravity.v1.MsgSendToEth
             * @instance
             */
            MsgSendToEth.prototype.amount = null;

            /**
             * MsgSendToEth bridge_fee.
             * @member {cosmos.base.v1beta1.ICoin|null|undefined} bridge_fee
             * @memberof gravity.v1.MsgSendToEth
             * @instance
             */
            MsgSendToEth.prototype.bridge_fee = null;

            /**
             * Encodes the specified MsgSendToEth message. Does not implicitly {@link gravity.v1.MsgSendToEth.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgSendToEth
             * @static
             * @param {gravity.v1.IMsgSendToEth} message MsgSendToEth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSendToEth.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                if (message.eth_dest != null && Object.hasOwnProperty.call(message, "eth_dest"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.eth_dest);
                if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                    $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.bridge_fee != null && Object.hasOwnProperty.call(message, "bridge_fee"))
                    $root.cosmos.base.v1beta1.Coin.encode(message.bridge_fee, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MsgSendToEth message, length delimited. Does not implicitly {@link gravity.v1.MsgSendToEth.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgSendToEth
             * @static
             * @param {gravity.v1.IMsgSendToEth} message MsgSendToEth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSendToEth.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgSendToEth message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgSendToEth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgSendToEth} MsgSendToEth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSendToEth.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSendToEth();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sender = reader.string();
                        break;
                    case 2:
                        message.eth_dest = reader.string();
                        break;
                    case 3:
                        message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.bridge_fee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgSendToEth message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgSendToEth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgSendToEth} MsgSendToEth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSendToEth.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgSendToEth message.
             * @function verify
             * @memberof gravity.v1.MsgSendToEth
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgSendToEth.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sender != null && message.hasOwnProperty("sender"))
                    if (!$util.isString(message.sender))
                        return "sender: string expected";
                if (message.eth_dest != null && message.hasOwnProperty("eth_dest"))
                    if (!$util.isString(message.eth_dest))
                        return "eth_dest: string expected";
                if (message.amount != null && message.hasOwnProperty("amount")) {
                    let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
                    if (error)
                        return "amount." + error;
                }
                if (message.bridge_fee != null && message.hasOwnProperty("bridge_fee")) {
                    let error = $root.cosmos.base.v1beta1.Coin.verify(message.bridge_fee);
                    if (error)
                        return "bridge_fee." + error;
                }
                return null;
            };

            /**
             * Creates a MsgSendToEth message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgSendToEth
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgSendToEth} MsgSendToEth
             */
            MsgSendToEth.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgSendToEth)
                    return object;
                let message = new $root.gravity.v1.MsgSendToEth();
                if (object.sender != null)
                    message.sender = String(object.sender);
                if (object.eth_dest != null)
                    message.eth_dest = String(object.eth_dest);
                if (object.amount != null) {
                    if (typeof object.amount !== "object")
                        throw TypeError(".gravity.v1.MsgSendToEth.amount: object expected");
                    message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
                }
                if (object.bridge_fee != null) {
                    if (typeof object.bridge_fee !== "object")
                        throw TypeError(".gravity.v1.MsgSendToEth.bridge_fee: object expected");
                    message.bridge_fee = $root.cosmos.base.v1beta1.Coin.fromObject(object.bridge_fee);
                }
                return message;
            };

            /**
             * Creates a plain object from a MsgSendToEth message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgSendToEth
             * @static
             * @param {gravity.v1.MsgSendToEth} message MsgSendToEth
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgSendToEth.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.sender = "";
                    object.eth_dest = "";
                    object.amount = null;
                    object.bridge_fee = null;
                }
                if (message.sender != null && message.hasOwnProperty("sender"))
                    object.sender = message.sender;
                if (message.eth_dest != null && message.hasOwnProperty("eth_dest"))
                    object.eth_dest = message.eth_dest;
                if (message.amount != null && message.hasOwnProperty("amount"))
                    object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
                if (message.bridge_fee != null && message.hasOwnProperty("bridge_fee"))
                    object.bridge_fee = $root.cosmos.base.v1beta1.Coin.toObject(message.bridge_fee, options);
                return object;
            };

            /**
             * Converts this MsgSendToEth to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgSendToEth
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgSendToEth.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgSendToEth;
        })();

        v1.MsgSendToEthResponse = (function() {

            /**
             * Properties of a MsgSendToEthResponse.
             * @memberof gravity.v1
             * @interface IMsgSendToEthResponse
             */

            /**
             * Constructs a new MsgSendToEthResponse.
             * @memberof gravity.v1
             * @classdesc Represents a MsgSendToEthResponse.
             * @implements IMsgSendToEthResponse
             * @constructor
             * @param {gravity.v1.IMsgSendToEthResponse=} [properties] Properties to set
             */
            function MsgSendToEthResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified MsgSendToEthResponse message. Does not implicitly {@link gravity.v1.MsgSendToEthResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgSendToEthResponse
             * @static
             * @param {gravity.v1.IMsgSendToEthResponse} message MsgSendToEthResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSendToEthResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified MsgSendToEthResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgSendToEthResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgSendToEthResponse
             * @static
             * @param {gravity.v1.IMsgSendToEthResponse} message MsgSendToEthResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSendToEthResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgSendToEthResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgSendToEthResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgSendToEthResponse} MsgSendToEthResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSendToEthResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSendToEthResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgSendToEthResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgSendToEthResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgSendToEthResponse} MsgSendToEthResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSendToEthResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgSendToEthResponse message.
             * @function verify
             * @memberof gravity.v1.MsgSendToEthResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgSendToEthResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a MsgSendToEthResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgSendToEthResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgSendToEthResponse} MsgSendToEthResponse
             */
            MsgSendToEthResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgSendToEthResponse)
                    return object;
                return new $root.gravity.v1.MsgSendToEthResponse();
            };

            /**
             * Creates a plain object from a MsgSendToEthResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgSendToEthResponse
             * @static
             * @param {gravity.v1.MsgSendToEthResponse} message MsgSendToEthResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgSendToEthResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this MsgSendToEthResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgSendToEthResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgSendToEthResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgSendToEthResponse;
        })();

        v1.MsgRequestBatch = (function() {

            /**
             * Properties of a MsgRequestBatch.
             * @memberof gravity.v1
             * @interface IMsgRequestBatch
             * @property {string|null} [sender] MsgRequestBatch sender
             * @property {string|null} [denom] MsgRequestBatch denom
             */

            /**
             * Constructs a new MsgRequestBatch.
             * @memberof gravity.v1
             * @classdesc Represents a MsgRequestBatch.
             * @implements IMsgRequestBatch
             * @constructor
             * @param {gravity.v1.IMsgRequestBatch=} [properties] Properties to set
             */
            function MsgRequestBatch(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgRequestBatch sender.
             * @member {string} sender
             * @memberof gravity.v1.MsgRequestBatch
             * @instance
             */
            MsgRequestBatch.prototype.sender = "";

            /**
             * MsgRequestBatch denom.
             * @member {string} denom
             * @memberof gravity.v1.MsgRequestBatch
             * @instance
             */
            MsgRequestBatch.prototype.denom = "";

            /**
             * Encodes the specified MsgRequestBatch message. Does not implicitly {@link gravity.v1.MsgRequestBatch.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgRequestBatch
             * @static
             * @param {gravity.v1.IMsgRequestBatch} message MsgRequestBatch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgRequestBatch.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                if (message.denom != null && Object.hasOwnProperty.call(message, "denom"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.denom);
                return writer;
            };

            /**
             * Encodes the specified MsgRequestBatch message, length delimited. Does not implicitly {@link gravity.v1.MsgRequestBatch.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgRequestBatch
             * @static
             * @param {gravity.v1.IMsgRequestBatch} message MsgRequestBatch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgRequestBatch.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgRequestBatch message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgRequestBatch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgRequestBatch} MsgRequestBatch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgRequestBatch.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgRequestBatch();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sender = reader.string();
                        break;
                    case 2:
                        message.denom = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgRequestBatch message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgRequestBatch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgRequestBatch} MsgRequestBatch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgRequestBatch.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgRequestBatch message.
             * @function verify
             * @memberof gravity.v1.MsgRequestBatch
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgRequestBatch.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sender != null && message.hasOwnProperty("sender"))
                    if (!$util.isString(message.sender))
                        return "sender: string expected";
                if (message.denom != null && message.hasOwnProperty("denom"))
                    if (!$util.isString(message.denom))
                        return "denom: string expected";
                return null;
            };

            /**
             * Creates a MsgRequestBatch message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgRequestBatch
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgRequestBatch} MsgRequestBatch
             */
            MsgRequestBatch.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgRequestBatch)
                    return object;
                let message = new $root.gravity.v1.MsgRequestBatch();
                if (object.sender != null)
                    message.sender = String(object.sender);
                if (object.denom != null)
                    message.denom = String(object.denom);
                return message;
            };

            /**
             * Creates a plain object from a MsgRequestBatch message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgRequestBatch
             * @static
             * @param {gravity.v1.MsgRequestBatch} message MsgRequestBatch
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgRequestBatch.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.sender = "";
                    object.denom = "";
                }
                if (message.sender != null && message.hasOwnProperty("sender"))
                    object.sender = message.sender;
                if (message.denom != null && message.hasOwnProperty("denom"))
                    object.denom = message.denom;
                return object;
            };

            /**
             * Converts this MsgRequestBatch to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgRequestBatch
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgRequestBatch.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgRequestBatch;
        })();

        v1.MsgRequestBatchResponse = (function() {

            /**
             * Properties of a MsgRequestBatchResponse.
             * @memberof gravity.v1
             * @interface IMsgRequestBatchResponse
             */

            /**
             * Constructs a new MsgRequestBatchResponse.
             * @memberof gravity.v1
             * @classdesc Represents a MsgRequestBatchResponse.
             * @implements IMsgRequestBatchResponse
             * @constructor
             * @param {gravity.v1.IMsgRequestBatchResponse=} [properties] Properties to set
             */
            function MsgRequestBatchResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified MsgRequestBatchResponse message. Does not implicitly {@link gravity.v1.MsgRequestBatchResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgRequestBatchResponse
             * @static
             * @param {gravity.v1.IMsgRequestBatchResponse} message MsgRequestBatchResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgRequestBatchResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified MsgRequestBatchResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgRequestBatchResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgRequestBatchResponse
             * @static
             * @param {gravity.v1.IMsgRequestBatchResponse} message MsgRequestBatchResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgRequestBatchResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgRequestBatchResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgRequestBatchResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgRequestBatchResponse} MsgRequestBatchResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgRequestBatchResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgRequestBatchResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgRequestBatchResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgRequestBatchResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgRequestBatchResponse} MsgRequestBatchResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgRequestBatchResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgRequestBatchResponse message.
             * @function verify
             * @memberof gravity.v1.MsgRequestBatchResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgRequestBatchResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a MsgRequestBatchResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgRequestBatchResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgRequestBatchResponse} MsgRequestBatchResponse
             */
            MsgRequestBatchResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgRequestBatchResponse)
                    return object;
                return new $root.gravity.v1.MsgRequestBatchResponse();
            };

            /**
             * Creates a plain object from a MsgRequestBatchResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgRequestBatchResponse
             * @static
             * @param {gravity.v1.MsgRequestBatchResponse} message MsgRequestBatchResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgRequestBatchResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this MsgRequestBatchResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgRequestBatchResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgRequestBatchResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgRequestBatchResponse;
        })();

        v1.MsgConfirmBatch = (function() {

            /**
             * Properties of a MsgConfirmBatch.
             * @memberof gravity.v1
             * @interface IMsgConfirmBatch
             * @property {Long|null} [nonce] MsgConfirmBatch nonce
             * @property {string|null} [token_contract] MsgConfirmBatch token_contract
             * @property {string|null} [eth_signer] MsgConfirmBatch eth_signer
             * @property {string|null} [orchestrator] MsgConfirmBatch orchestrator
             * @property {string|null} [signature] MsgConfirmBatch signature
             */

            /**
             * Constructs a new MsgConfirmBatch.
             * @memberof gravity.v1
             * @classdesc Represents a MsgConfirmBatch.
             * @implements IMsgConfirmBatch
             * @constructor
             * @param {gravity.v1.IMsgConfirmBatch=} [properties] Properties to set
             */
            function MsgConfirmBatch(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgConfirmBatch nonce.
             * @member {Long} nonce
             * @memberof gravity.v1.MsgConfirmBatch
             * @instance
             */
            MsgConfirmBatch.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgConfirmBatch token_contract.
             * @member {string} token_contract
             * @memberof gravity.v1.MsgConfirmBatch
             * @instance
             */
            MsgConfirmBatch.prototype.token_contract = "";

            /**
             * MsgConfirmBatch eth_signer.
             * @member {string} eth_signer
             * @memberof gravity.v1.MsgConfirmBatch
             * @instance
             */
            MsgConfirmBatch.prototype.eth_signer = "";

            /**
             * MsgConfirmBatch orchestrator.
             * @member {string} orchestrator
             * @memberof gravity.v1.MsgConfirmBatch
             * @instance
             */
            MsgConfirmBatch.prototype.orchestrator = "";

            /**
             * MsgConfirmBatch signature.
             * @member {string} signature
             * @memberof gravity.v1.MsgConfirmBatch
             * @instance
             */
            MsgConfirmBatch.prototype.signature = "";

            /**
             * Encodes the specified MsgConfirmBatch message. Does not implicitly {@link gravity.v1.MsgConfirmBatch.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgConfirmBatch
             * @static
             * @param {gravity.v1.IMsgConfirmBatch} message MsgConfirmBatch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgConfirmBatch.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.token_contract != null && Object.hasOwnProperty.call(message, "token_contract"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.token_contract);
                if (message.eth_signer != null && Object.hasOwnProperty.call(message, "eth_signer"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.eth_signer);
                if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.orchestrator);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.signature);
                return writer;
            };

            /**
             * Encodes the specified MsgConfirmBatch message, length delimited. Does not implicitly {@link gravity.v1.MsgConfirmBatch.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgConfirmBatch
             * @static
             * @param {gravity.v1.IMsgConfirmBatch} message MsgConfirmBatch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgConfirmBatch.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgConfirmBatch message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgConfirmBatch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgConfirmBatch} MsgConfirmBatch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgConfirmBatch.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgConfirmBatch();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        message.token_contract = reader.string();
                        break;
                    case 3:
                        message.eth_signer = reader.string();
                        break;
                    case 4:
                        message.orchestrator = reader.string();
                        break;
                    case 5:
                        message.signature = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgConfirmBatch message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgConfirmBatch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgConfirmBatch} MsgConfirmBatch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgConfirmBatch.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgConfirmBatch message.
             * @function verify
             * @memberof gravity.v1.MsgConfirmBatch
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgConfirmBatch.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.token_contract != null && message.hasOwnProperty("token_contract"))
                    if (!$util.isString(message.token_contract))
                        return "token_contract: string expected";
                if (message.eth_signer != null && message.hasOwnProperty("eth_signer"))
                    if (!$util.isString(message.eth_signer))
                        return "eth_signer: string expected";
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    if (!$util.isString(message.orchestrator))
                        return "orchestrator: string expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!$util.isString(message.signature))
                        return "signature: string expected";
                return null;
            };

            /**
             * Creates a MsgConfirmBatch message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgConfirmBatch
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgConfirmBatch} MsgConfirmBatch
             */
            MsgConfirmBatch.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgConfirmBatch)
                    return object;
                let message = new $root.gravity.v1.MsgConfirmBatch();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.token_contract != null)
                    message.token_contract = String(object.token_contract);
                if (object.eth_signer != null)
                    message.eth_signer = String(object.eth_signer);
                if (object.orchestrator != null)
                    message.orchestrator = String(object.orchestrator);
                if (object.signature != null)
                    message.signature = String(object.signature);
                return message;
            };

            /**
             * Creates a plain object from a MsgConfirmBatch message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgConfirmBatch
             * @static
             * @param {gravity.v1.MsgConfirmBatch} message MsgConfirmBatch
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgConfirmBatch.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    object.token_contract = "";
                    object.eth_signer = "";
                    object.orchestrator = "";
                    object.signature = "";
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.token_contract != null && message.hasOwnProperty("token_contract"))
                    object.token_contract = message.token_contract;
                if (message.eth_signer != null && message.hasOwnProperty("eth_signer"))
                    object.eth_signer = message.eth_signer;
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    object.orchestrator = message.orchestrator;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = message.signature;
                return object;
            };

            /**
             * Converts this MsgConfirmBatch to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgConfirmBatch
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgConfirmBatch.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgConfirmBatch;
        })();

        v1.MsgConfirmBatchResponse = (function() {

            /**
             * Properties of a MsgConfirmBatchResponse.
             * @memberof gravity.v1
             * @interface IMsgConfirmBatchResponse
             */

            /**
             * Constructs a new MsgConfirmBatchResponse.
             * @memberof gravity.v1
             * @classdesc Represents a MsgConfirmBatchResponse.
             * @implements IMsgConfirmBatchResponse
             * @constructor
             * @param {gravity.v1.IMsgConfirmBatchResponse=} [properties] Properties to set
             */
            function MsgConfirmBatchResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified MsgConfirmBatchResponse message. Does not implicitly {@link gravity.v1.MsgConfirmBatchResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgConfirmBatchResponse
             * @static
             * @param {gravity.v1.IMsgConfirmBatchResponse} message MsgConfirmBatchResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgConfirmBatchResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified MsgConfirmBatchResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgConfirmBatchResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgConfirmBatchResponse
             * @static
             * @param {gravity.v1.IMsgConfirmBatchResponse} message MsgConfirmBatchResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgConfirmBatchResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgConfirmBatchResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgConfirmBatchResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgConfirmBatchResponse} MsgConfirmBatchResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgConfirmBatchResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgConfirmBatchResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgConfirmBatchResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgConfirmBatchResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgConfirmBatchResponse} MsgConfirmBatchResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgConfirmBatchResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgConfirmBatchResponse message.
             * @function verify
             * @memberof gravity.v1.MsgConfirmBatchResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgConfirmBatchResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a MsgConfirmBatchResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgConfirmBatchResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgConfirmBatchResponse} MsgConfirmBatchResponse
             */
            MsgConfirmBatchResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgConfirmBatchResponse)
                    return object;
                return new $root.gravity.v1.MsgConfirmBatchResponse();
            };

            /**
             * Creates a plain object from a MsgConfirmBatchResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgConfirmBatchResponse
             * @static
             * @param {gravity.v1.MsgConfirmBatchResponse} message MsgConfirmBatchResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgConfirmBatchResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this MsgConfirmBatchResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgConfirmBatchResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgConfirmBatchResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgConfirmBatchResponse;
        })();

        v1.MsgConfirmLogicCall = (function() {

            /**
             * Properties of a MsgConfirmLogicCall.
             * @memberof gravity.v1
             * @interface IMsgConfirmLogicCall
             * @property {string|null} [invalidation_id] MsgConfirmLogicCall invalidation_id
             * @property {Long|null} [invalidation_nonce] MsgConfirmLogicCall invalidation_nonce
             * @property {string|null} [eth_signer] MsgConfirmLogicCall eth_signer
             * @property {string|null} [orchestrator] MsgConfirmLogicCall orchestrator
             * @property {string|null} [signature] MsgConfirmLogicCall signature
             */

            /**
             * Constructs a new MsgConfirmLogicCall.
             * @memberof gravity.v1
             * @classdesc Represents a MsgConfirmLogicCall.
             * @implements IMsgConfirmLogicCall
             * @constructor
             * @param {gravity.v1.IMsgConfirmLogicCall=} [properties] Properties to set
             */
            function MsgConfirmLogicCall(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgConfirmLogicCall invalidation_id.
             * @member {string} invalidation_id
             * @memberof gravity.v1.MsgConfirmLogicCall
             * @instance
             */
            MsgConfirmLogicCall.prototype.invalidation_id = "";

            /**
             * MsgConfirmLogicCall invalidation_nonce.
             * @member {Long} invalidation_nonce
             * @memberof gravity.v1.MsgConfirmLogicCall
             * @instance
             */
            MsgConfirmLogicCall.prototype.invalidation_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgConfirmLogicCall eth_signer.
             * @member {string} eth_signer
             * @memberof gravity.v1.MsgConfirmLogicCall
             * @instance
             */
            MsgConfirmLogicCall.prototype.eth_signer = "";

            /**
             * MsgConfirmLogicCall orchestrator.
             * @member {string} orchestrator
             * @memberof gravity.v1.MsgConfirmLogicCall
             * @instance
             */
            MsgConfirmLogicCall.prototype.orchestrator = "";

            /**
             * MsgConfirmLogicCall signature.
             * @member {string} signature
             * @memberof gravity.v1.MsgConfirmLogicCall
             * @instance
             */
            MsgConfirmLogicCall.prototype.signature = "";

            /**
             * Encodes the specified MsgConfirmLogicCall message. Does not implicitly {@link gravity.v1.MsgConfirmLogicCall.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgConfirmLogicCall
             * @static
             * @param {gravity.v1.IMsgConfirmLogicCall} message MsgConfirmLogicCall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgConfirmLogicCall.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.invalidation_id != null && Object.hasOwnProperty.call(message, "invalidation_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.invalidation_id);
                if (message.invalidation_nonce != null && Object.hasOwnProperty.call(message, "invalidation_nonce"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.invalidation_nonce);
                if (message.eth_signer != null && Object.hasOwnProperty.call(message, "eth_signer"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.eth_signer);
                if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.orchestrator);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.signature);
                return writer;
            };

            /**
             * Encodes the specified MsgConfirmLogicCall message, length delimited. Does not implicitly {@link gravity.v1.MsgConfirmLogicCall.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgConfirmLogicCall
             * @static
             * @param {gravity.v1.IMsgConfirmLogicCall} message MsgConfirmLogicCall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgConfirmLogicCall.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgConfirmLogicCall message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgConfirmLogicCall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgConfirmLogicCall} MsgConfirmLogicCall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgConfirmLogicCall.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgConfirmLogicCall();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.invalidation_id = reader.string();
                        break;
                    case 2:
                        message.invalidation_nonce = reader.uint64();
                        break;
                    case 3:
                        message.eth_signer = reader.string();
                        break;
                    case 4:
                        message.orchestrator = reader.string();
                        break;
                    case 5:
                        message.signature = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgConfirmLogicCall message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgConfirmLogicCall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgConfirmLogicCall} MsgConfirmLogicCall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgConfirmLogicCall.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgConfirmLogicCall message.
             * @function verify
             * @memberof gravity.v1.MsgConfirmLogicCall
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgConfirmLogicCall.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.invalidation_id != null && message.hasOwnProperty("invalidation_id"))
                    if (!$util.isString(message.invalidation_id))
                        return "invalidation_id: string expected";
                if (message.invalidation_nonce != null && message.hasOwnProperty("invalidation_nonce"))
                    if (!$util.isInteger(message.invalidation_nonce) && !(message.invalidation_nonce && $util.isInteger(message.invalidation_nonce.low) && $util.isInteger(message.invalidation_nonce.high)))
                        return "invalidation_nonce: integer|Long expected";
                if (message.eth_signer != null && message.hasOwnProperty("eth_signer"))
                    if (!$util.isString(message.eth_signer))
                        return "eth_signer: string expected";
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    if (!$util.isString(message.orchestrator))
                        return "orchestrator: string expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!$util.isString(message.signature))
                        return "signature: string expected";
                return null;
            };

            /**
             * Creates a MsgConfirmLogicCall message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgConfirmLogicCall
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgConfirmLogicCall} MsgConfirmLogicCall
             */
            MsgConfirmLogicCall.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgConfirmLogicCall)
                    return object;
                let message = new $root.gravity.v1.MsgConfirmLogicCall();
                if (object.invalidation_id != null)
                    message.invalidation_id = String(object.invalidation_id);
                if (object.invalidation_nonce != null)
                    if ($util.Long)
                        (message.invalidation_nonce = $util.Long.fromValue(object.invalidation_nonce)).unsigned = true;
                    else if (typeof object.invalidation_nonce === "string")
                        message.invalidation_nonce = parseInt(object.invalidation_nonce, 10);
                    else if (typeof object.invalidation_nonce === "number")
                        message.invalidation_nonce = object.invalidation_nonce;
                    else if (typeof object.invalidation_nonce === "object")
                        message.invalidation_nonce = new $util.LongBits(object.invalidation_nonce.low >>> 0, object.invalidation_nonce.high >>> 0).toNumber(true);
                if (object.eth_signer != null)
                    message.eth_signer = String(object.eth_signer);
                if (object.orchestrator != null)
                    message.orchestrator = String(object.orchestrator);
                if (object.signature != null)
                    message.signature = String(object.signature);
                return message;
            };

            /**
             * Creates a plain object from a MsgConfirmLogicCall message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgConfirmLogicCall
             * @static
             * @param {gravity.v1.MsgConfirmLogicCall} message MsgConfirmLogicCall
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgConfirmLogicCall.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.invalidation_id = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.invalidation_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.invalidation_nonce = options.longs === String ? "0" : 0;
                    object.eth_signer = "";
                    object.orchestrator = "";
                    object.signature = "";
                }
                if (message.invalidation_id != null && message.hasOwnProperty("invalidation_id"))
                    object.invalidation_id = message.invalidation_id;
                if (message.invalidation_nonce != null && message.hasOwnProperty("invalidation_nonce"))
                    if (typeof message.invalidation_nonce === "number")
                        object.invalidation_nonce = options.longs === String ? String(message.invalidation_nonce) : message.invalidation_nonce;
                    else
                        object.invalidation_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.invalidation_nonce) : options.longs === Number ? new $util.LongBits(message.invalidation_nonce.low >>> 0, message.invalidation_nonce.high >>> 0).toNumber(true) : message.invalidation_nonce;
                if (message.eth_signer != null && message.hasOwnProperty("eth_signer"))
                    object.eth_signer = message.eth_signer;
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    object.orchestrator = message.orchestrator;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = message.signature;
                return object;
            };

            /**
             * Converts this MsgConfirmLogicCall to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgConfirmLogicCall
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgConfirmLogicCall.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgConfirmLogicCall;
        })();

        v1.MsgConfirmLogicCallResponse = (function() {

            /**
             * Properties of a MsgConfirmLogicCallResponse.
             * @memberof gravity.v1
             * @interface IMsgConfirmLogicCallResponse
             */

            /**
             * Constructs a new MsgConfirmLogicCallResponse.
             * @memberof gravity.v1
             * @classdesc Represents a MsgConfirmLogicCallResponse.
             * @implements IMsgConfirmLogicCallResponse
             * @constructor
             * @param {gravity.v1.IMsgConfirmLogicCallResponse=} [properties] Properties to set
             */
            function MsgConfirmLogicCallResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified MsgConfirmLogicCallResponse message. Does not implicitly {@link gravity.v1.MsgConfirmLogicCallResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgConfirmLogicCallResponse
             * @static
             * @param {gravity.v1.IMsgConfirmLogicCallResponse} message MsgConfirmLogicCallResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgConfirmLogicCallResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified MsgConfirmLogicCallResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgConfirmLogicCallResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgConfirmLogicCallResponse
             * @static
             * @param {gravity.v1.IMsgConfirmLogicCallResponse} message MsgConfirmLogicCallResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgConfirmLogicCallResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgConfirmLogicCallResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgConfirmLogicCallResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgConfirmLogicCallResponse} MsgConfirmLogicCallResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgConfirmLogicCallResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgConfirmLogicCallResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgConfirmLogicCallResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgConfirmLogicCallResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgConfirmLogicCallResponse} MsgConfirmLogicCallResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgConfirmLogicCallResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgConfirmLogicCallResponse message.
             * @function verify
             * @memberof gravity.v1.MsgConfirmLogicCallResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgConfirmLogicCallResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a MsgConfirmLogicCallResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgConfirmLogicCallResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgConfirmLogicCallResponse} MsgConfirmLogicCallResponse
             */
            MsgConfirmLogicCallResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgConfirmLogicCallResponse)
                    return object;
                return new $root.gravity.v1.MsgConfirmLogicCallResponse();
            };

            /**
             * Creates a plain object from a MsgConfirmLogicCallResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgConfirmLogicCallResponse
             * @static
             * @param {gravity.v1.MsgConfirmLogicCallResponse} message MsgConfirmLogicCallResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgConfirmLogicCallResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this MsgConfirmLogicCallResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgConfirmLogicCallResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgConfirmLogicCallResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgConfirmLogicCallResponse;
        })();

        v1.MsgSendToCosmosClaim = (function() {

            /**
             * Properties of a MsgSendToCosmosClaim.
             * @memberof gravity.v1
             * @interface IMsgSendToCosmosClaim
             * @property {Long|null} [event_nonce] MsgSendToCosmosClaim event_nonce
             * @property {Long|null} [block_height] MsgSendToCosmosClaim block_height
             * @property {string|null} [token_contract] MsgSendToCosmosClaim token_contract
             * @property {string|null} [amount] MsgSendToCosmosClaim amount
             * @property {string|null} [ethereum_sender] MsgSendToCosmosClaim ethereum_sender
             * @property {string|null} [cosmos_receiver] MsgSendToCosmosClaim cosmos_receiver
             * @property {string|null} [orchestrator] MsgSendToCosmosClaim orchestrator
             */

            /**
             * Constructs a new MsgSendToCosmosClaim.
             * @memberof gravity.v1
             * @classdesc Represents a MsgSendToCosmosClaim.
             * @implements IMsgSendToCosmosClaim
             * @constructor
             * @param {gravity.v1.IMsgSendToCosmosClaim=} [properties] Properties to set
             */
            function MsgSendToCosmosClaim(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgSendToCosmosClaim event_nonce.
             * @member {Long} event_nonce
             * @memberof gravity.v1.MsgSendToCosmosClaim
             * @instance
             */
            MsgSendToCosmosClaim.prototype.event_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgSendToCosmosClaim block_height.
             * @member {Long} block_height
             * @memberof gravity.v1.MsgSendToCosmosClaim
             * @instance
             */
            MsgSendToCosmosClaim.prototype.block_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgSendToCosmosClaim token_contract.
             * @member {string} token_contract
             * @memberof gravity.v1.MsgSendToCosmosClaim
             * @instance
             */
            MsgSendToCosmosClaim.prototype.token_contract = "";

            /**
             * MsgSendToCosmosClaim amount.
             * @member {string} amount
             * @memberof gravity.v1.MsgSendToCosmosClaim
             * @instance
             */
            MsgSendToCosmosClaim.prototype.amount = "";

            /**
             * MsgSendToCosmosClaim ethereum_sender.
             * @member {string} ethereum_sender
             * @memberof gravity.v1.MsgSendToCosmosClaim
             * @instance
             */
            MsgSendToCosmosClaim.prototype.ethereum_sender = "";

            /**
             * MsgSendToCosmosClaim cosmos_receiver.
             * @member {string} cosmos_receiver
             * @memberof gravity.v1.MsgSendToCosmosClaim
             * @instance
             */
            MsgSendToCosmosClaim.prototype.cosmos_receiver = "";

            /**
             * MsgSendToCosmosClaim orchestrator.
             * @member {string} orchestrator
             * @memberof gravity.v1.MsgSendToCosmosClaim
             * @instance
             */
            MsgSendToCosmosClaim.prototype.orchestrator = "";

            /**
             * Encodes the specified MsgSendToCosmosClaim message. Does not implicitly {@link gravity.v1.MsgSendToCosmosClaim.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgSendToCosmosClaim
             * @static
             * @param {gravity.v1.IMsgSendToCosmosClaim} message MsgSendToCosmosClaim message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSendToCosmosClaim.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.event_nonce != null && Object.hasOwnProperty.call(message, "event_nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.event_nonce);
                if (message.block_height != null && Object.hasOwnProperty.call(message, "block_height"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.block_height);
                if (message.token_contract != null && Object.hasOwnProperty.call(message, "token_contract"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.token_contract);
                if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.amount);
                if (message.ethereum_sender != null && Object.hasOwnProperty.call(message, "ethereum_sender"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.ethereum_sender);
                if (message.cosmos_receiver != null && Object.hasOwnProperty.call(message, "cosmos_receiver"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.cosmos_receiver);
                if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.orchestrator);
                return writer;
            };

            /**
             * Encodes the specified MsgSendToCosmosClaim message, length delimited. Does not implicitly {@link gravity.v1.MsgSendToCosmosClaim.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgSendToCosmosClaim
             * @static
             * @param {gravity.v1.IMsgSendToCosmosClaim} message MsgSendToCosmosClaim message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSendToCosmosClaim.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgSendToCosmosClaim message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgSendToCosmosClaim
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgSendToCosmosClaim} MsgSendToCosmosClaim
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSendToCosmosClaim.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSendToCosmosClaim();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.event_nonce = reader.uint64();
                        break;
                    case 2:
                        message.block_height = reader.uint64();
                        break;
                    case 3:
                        message.token_contract = reader.string();
                        break;
                    case 4:
                        message.amount = reader.string();
                        break;
                    case 5:
                        message.ethereum_sender = reader.string();
                        break;
                    case 6:
                        message.cosmos_receiver = reader.string();
                        break;
                    case 7:
                        message.orchestrator = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgSendToCosmosClaim message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgSendToCosmosClaim
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgSendToCosmosClaim} MsgSendToCosmosClaim
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSendToCosmosClaim.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgSendToCosmosClaim message.
             * @function verify
             * @memberof gravity.v1.MsgSendToCosmosClaim
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgSendToCosmosClaim.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.event_nonce != null && message.hasOwnProperty("event_nonce"))
                    if (!$util.isInteger(message.event_nonce) && !(message.event_nonce && $util.isInteger(message.event_nonce.low) && $util.isInteger(message.event_nonce.high)))
                        return "event_nonce: integer|Long expected";
                if (message.block_height != null && message.hasOwnProperty("block_height"))
                    if (!$util.isInteger(message.block_height) && !(message.block_height && $util.isInteger(message.block_height.low) && $util.isInteger(message.block_height.high)))
                        return "block_height: integer|Long expected";
                if (message.token_contract != null && message.hasOwnProperty("token_contract"))
                    if (!$util.isString(message.token_contract))
                        return "token_contract: string expected";
                if (message.amount != null && message.hasOwnProperty("amount"))
                    if (!$util.isString(message.amount))
                        return "amount: string expected";
                if (message.ethereum_sender != null && message.hasOwnProperty("ethereum_sender"))
                    if (!$util.isString(message.ethereum_sender))
                        return "ethereum_sender: string expected";
                if (message.cosmos_receiver != null && message.hasOwnProperty("cosmos_receiver"))
                    if (!$util.isString(message.cosmos_receiver))
                        return "cosmos_receiver: string expected";
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    if (!$util.isString(message.orchestrator))
                        return "orchestrator: string expected";
                return null;
            };

            /**
             * Creates a MsgSendToCosmosClaim message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgSendToCosmosClaim
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgSendToCosmosClaim} MsgSendToCosmosClaim
             */
            MsgSendToCosmosClaim.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgSendToCosmosClaim)
                    return object;
                let message = new $root.gravity.v1.MsgSendToCosmosClaim();
                if (object.event_nonce != null)
                    if ($util.Long)
                        (message.event_nonce = $util.Long.fromValue(object.event_nonce)).unsigned = true;
                    else if (typeof object.event_nonce === "string")
                        message.event_nonce = parseInt(object.event_nonce, 10);
                    else if (typeof object.event_nonce === "number")
                        message.event_nonce = object.event_nonce;
                    else if (typeof object.event_nonce === "object")
                        message.event_nonce = new $util.LongBits(object.event_nonce.low >>> 0, object.event_nonce.high >>> 0).toNumber(true);
                if (object.block_height != null)
                    if ($util.Long)
                        (message.block_height = $util.Long.fromValue(object.block_height)).unsigned = true;
                    else if (typeof object.block_height === "string")
                        message.block_height = parseInt(object.block_height, 10);
                    else if (typeof object.block_height === "number")
                        message.block_height = object.block_height;
                    else if (typeof object.block_height === "object")
                        message.block_height = new $util.LongBits(object.block_height.low >>> 0, object.block_height.high >>> 0).toNumber(true);
                if (object.token_contract != null)
                    message.token_contract = String(object.token_contract);
                if (object.amount != null)
                    message.amount = String(object.amount);
                if (object.ethereum_sender != null)
                    message.ethereum_sender = String(object.ethereum_sender);
                if (object.cosmos_receiver != null)
                    message.cosmos_receiver = String(object.cosmos_receiver);
                if (object.orchestrator != null)
                    message.orchestrator = String(object.orchestrator);
                return message;
            };

            /**
             * Creates a plain object from a MsgSendToCosmosClaim message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgSendToCosmosClaim
             * @static
             * @param {gravity.v1.MsgSendToCosmosClaim} message MsgSendToCosmosClaim
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgSendToCosmosClaim.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.event_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.event_nonce = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.block_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.block_height = options.longs === String ? "0" : 0;
                    object.token_contract = "";
                    object.amount = "";
                    object.ethereum_sender = "";
                    object.cosmos_receiver = "";
                    object.orchestrator = "";
                }
                if (message.event_nonce != null && message.hasOwnProperty("event_nonce"))
                    if (typeof message.event_nonce === "number")
                        object.event_nonce = options.longs === String ? String(message.event_nonce) : message.event_nonce;
                    else
                        object.event_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.event_nonce) : options.longs === Number ? new $util.LongBits(message.event_nonce.low >>> 0, message.event_nonce.high >>> 0).toNumber(true) : message.event_nonce;
                if (message.block_height != null && message.hasOwnProperty("block_height"))
                    if (typeof message.block_height === "number")
                        object.block_height = options.longs === String ? String(message.block_height) : message.block_height;
                    else
                        object.block_height = options.longs === String ? $util.Long.prototype.toString.call(message.block_height) : options.longs === Number ? new $util.LongBits(message.block_height.low >>> 0, message.block_height.high >>> 0).toNumber(true) : message.block_height;
                if (message.token_contract != null && message.hasOwnProperty("token_contract"))
                    object.token_contract = message.token_contract;
                if (message.amount != null && message.hasOwnProperty("amount"))
                    object.amount = message.amount;
                if (message.ethereum_sender != null && message.hasOwnProperty("ethereum_sender"))
                    object.ethereum_sender = message.ethereum_sender;
                if (message.cosmos_receiver != null && message.hasOwnProperty("cosmos_receiver"))
                    object.cosmos_receiver = message.cosmos_receiver;
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    object.orchestrator = message.orchestrator;
                return object;
            };

            /**
             * Converts this MsgSendToCosmosClaim to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgSendToCosmosClaim
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgSendToCosmosClaim.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgSendToCosmosClaim;
        })();

        v1.MsgSendToCosmosClaimResponse = (function() {

            /**
             * Properties of a MsgSendToCosmosClaimResponse.
             * @memberof gravity.v1
             * @interface IMsgSendToCosmosClaimResponse
             */

            /**
             * Constructs a new MsgSendToCosmosClaimResponse.
             * @memberof gravity.v1
             * @classdesc Represents a MsgSendToCosmosClaimResponse.
             * @implements IMsgSendToCosmosClaimResponse
             * @constructor
             * @param {gravity.v1.IMsgSendToCosmosClaimResponse=} [properties] Properties to set
             */
            function MsgSendToCosmosClaimResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified MsgSendToCosmosClaimResponse message. Does not implicitly {@link gravity.v1.MsgSendToCosmosClaimResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgSendToCosmosClaimResponse
             * @static
             * @param {gravity.v1.IMsgSendToCosmosClaimResponse} message MsgSendToCosmosClaimResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSendToCosmosClaimResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified MsgSendToCosmosClaimResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgSendToCosmosClaimResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgSendToCosmosClaimResponse
             * @static
             * @param {gravity.v1.IMsgSendToCosmosClaimResponse} message MsgSendToCosmosClaimResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSendToCosmosClaimResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgSendToCosmosClaimResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgSendToCosmosClaimResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgSendToCosmosClaimResponse} MsgSendToCosmosClaimResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSendToCosmosClaimResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSendToCosmosClaimResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgSendToCosmosClaimResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgSendToCosmosClaimResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgSendToCosmosClaimResponse} MsgSendToCosmosClaimResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSendToCosmosClaimResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgSendToCosmosClaimResponse message.
             * @function verify
             * @memberof gravity.v1.MsgSendToCosmosClaimResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgSendToCosmosClaimResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a MsgSendToCosmosClaimResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgSendToCosmosClaimResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgSendToCosmosClaimResponse} MsgSendToCosmosClaimResponse
             */
            MsgSendToCosmosClaimResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgSendToCosmosClaimResponse)
                    return object;
                return new $root.gravity.v1.MsgSendToCosmosClaimResponse();
            };

            /**
             * Creates a plain object from a MsgSendToCosmosClaimResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgSendToCosmosClaimResponse
             * @static
             * @param {gravity.v1.MsgSendToCosmosClaimResponse} message MsgSendToCosmosClaimResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgSendToCosmosClaimResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this MsgSendToCosmosClaimResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgSendToCosmosClaimResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgSendToCosmosClaimResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgSendToCosmosClaimResponse;
        })();

        v1.MsgBatchSendToEthClaim = (function() {

            /**
             * Properties of a MsgBatchSendToEthClaim.
             * @memberof gravity.v1
             * @interface IMsgBatchSendToEthClaim
             * @property {Long|null} [event_nonce] MsgBatchSendToEthClaim event_nonce
             * @property {Long|null} [block_height] MsgBatchSendToEthClaim block_height
             * @property {Long|null} [batch_nonce] MsgBatchSendToEthClaim batch_nonce
             * @property {string|null} [token_contract] MsgBatchSendToEthClaim token_contract
             * @property {string|null} [orchestrator] MsgBatchSendToEthClaim orchestrator
             */

            /**
             * Constructs a new MsgBatchSendToEthClaim.
             * @memberof gravity.v1
             * @classdesc Represents a MsgBatchSendToEthClaim.
             * @implements IMsgBatchSendToEthClaim
             * @constructor
             * @param {gravity.v1.IMsgBatchSendToEthClaim=} [properties] Properties to set
             */
            function MsgBatchSendToEthClaim(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgBatchSendToEthClaim event_nonce.
             * @member {Long} event_nonce
             * @memberof gravity.v1.MsgBatchSendToEthClaim
             * @instance
             */
            MsgBatchSendToEthClaim.prototype.event_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgBatchSendToEthClaim block_height.
             * @member {Long} block_height
             * @memberof gravity.v1.MsgBatchSendToEthClaim
             * @instance
             */
            MsgBatchSendToEthClaim.prototype.block_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgBatchSendToEthClaim batch_nonce.
             * @member {Long} batch_nonce
             * @memberof gravity.v1.MsgBatchSendToEthClaim
             * @instance
             */
            MsgBatchSendToEthClaim.prototype.batch_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgBatchSendToEthClaim token_contract.
             * @member {string} token_contract
             * @memberof gravity.v1.MsgBatchSendToEthClaim
             * @instance
             */
            MsgBatchSendToEthClaim.prototype.token_contract = "";

            /**
             * MsgBatchSendToEthClaim orchestrator.
             * @member {string} orchestrator
             * @memberof gravity.v1.MsgBatchSendToEthClaim
             * @instance
             */
            MsgBatchSendToEthClaim.prototype.orchestrator = "";

            /**
             * Encodes the specified MsgBatchSendToEthClaim message. Does not implicitly {@link gravity.v1.MsgBatchSendToEthClaim.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgBatchSendToEthClaim
             * @static
             * @param {gravity.v1.IMsgBatchSendToEthClaim} message MsgBatchSendToEthClaim message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgBatchSendToEthClaim.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.event_nonce != null && Object.hasOwnProperty.call(message, "event_nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.event_nonce);
                if (message.block_height != null && Object.hasOwnProperty.call(message, "block_height"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.block_height);
                if (message.batch_nonce != null && Object.hasOwnProperty.call(message, "batch_nonce"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.batch_nonce);
                if (message.token_contract != null && Object.hasOwnProperty.call(message, "token_contract"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.token_contract);
                if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.orchestrator);
                return writer;
            };

            /**
             * Encodes the specified MsgBatchSendToEthClaim message, length delimited. Does not implicitly {@link gravity.v1.MsgBatchSendToEthClaim.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgBatchSendToEthClaim
             * @static
             * @param {gravity.v1.IMsgBatchSendToEthClaim} message MsgBatchSendToEthClaim message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgBatchSendToEthClaim.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgBatchSendToEthClaim message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgBatchSendToEthClaim
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgBatchSendToEthClaim} MsgBatchSendToEthClaim
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgBatchSendToEthClaim.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgBatchSendToEthClaim();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.event_nonce = reader.uint64();
                        break;
                    case 2:
                        message.block_height = reader.uint64();
                        break;
                    case 3:
                        message.batch_nonce = reader.uint64();
                        break;
                    case 4:
                        message.token_contract = reader.string();
                        break;
                    case 5:
                        message.orchestrator = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgBatchSendToEthClaim message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgBatchSendToEthClaim
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgBatchSendToEthClaim} MsgBatchSendToEthClaim
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgBatchSendToEthClaim.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgBatchSendToEthClaim message.
             * @function verify
             * @memberof gravity.v1.MsgBatchSendToEthClaim
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgBatchSendToEthClaim.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.event_nonce != null && message.hasOwnProperty("event_nonce"))
                    if (!$util.isInteger(message.event_nonce) && !(message.event_nonce && $util.isInteger(message.event_nonce.low) && $util.isInteger(message.event_nonce.high)))
                        return "event_nonce: integer|Long expected";
                if (message.block_height != null && message.hasOwnProperty("block_height"))
                    if (!$util.isInteger(message.block_height) && !(message.block_height && $util.isInteger(message.block_height.low) && $util.isInteger(message.block_height.high)))
                        return "block_height: integer|Long expected";
                if (message.batch_nonce != null && message.hasOwnProperty("batch_nonce"))
                    if (!$util.isInteger(message.batch_nonce) && !(message.batch_nonce && $util.isInteger(message.batch_nonce.low) && $util.isInteger(message.batch_nonce.high)))
                        return "batch_nonce: integer|Long expected";
                if (message.token_contract != null && message.hasOwnProperty("token_contract"))
                    if (!$util.isString(message.token_contract))
                        return "token_contract: string expected";
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    if (!$util.isString(message.orchestrator))
                        return "orchestrator: string expected";
                return null;
            };

            /**
             * Creates a MsgBatchSendToEthClaim message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgBatchSendToEthClaim
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgBatchSendToEthClaim} MsgBatchSendToEthClaim
             */
            MsgBatchSendToEthClaim.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgBatchSendToEthClaim)
                    return object;
                let message = new $root.gravity.v1.MsgBatchSendToEthClaim();
                if (object.event_nonce != null)
                    if ($util.Long)
                        (message.event_nonce = $util.Long.fromValue(object.event_nonce)).unsigned = true;
                    else if (typeof object.event_nonce === "string")
                        message.event_nonce = parseInt(object.event_nonce, 10);
                    else if (typeof object.event_nonce === "number")
                        message.event_nonce = object.event_nonce;
                    else if (typeof object.event_nonce === "object")
                        message.event_nonce = new $util.LongBits(object.event_nonce.low >>> 0, object.event_nonce.high >>> 0).toNumber(true);
                if (object.block_height != null)
                    if ($util.Long)
                        (message.block_height = $util.Long.fromValue(object.block_height)).unsigned = true;
                    else if (typeof object.block_height === "string")
                        message.block_height = parseInt(object.block_height, 10);
                    else if (typeof object.block_height === "number")
                        message.block_height = object.block_height;
                    else if (typeof object.block_height === "object")
                        message.block_height = new $util.LongBits(object.block_height.low >>> 0, object.block_height.high >>> 0).toNumber(true);
                if (object.batch_nonce != null)
                    if ($util.Long)
                        (message.batch_nonce = $util.Long.fromValue(object.batch_nonce)).unsigned = true;
                    else if (typeof object.batch_nonce === "string")
                        message.batch_nonce = parseInt(object.batch_nonce, 10);
                    else if (typeof object.batch_nonce === "number")
                        message.batch_nonce = object.batch_nonce;
                    else if (typeof object.batch_nonce === "object")
                        message.batch_nonce = new $util.LongBits(object.batch_nonce.low >>> 0, object.batch_nonce.high >>> 0).toNumber(true);
                if (object.token_contract != null)
                    message.token_contract = String(object.token_contract);
                if (object.orchestrator != null)
                    message.orchestrator = String(object.orchestrator);
                return message;
            };

            /**
             * Creates a plain object from a MsgBatchSendToEthClaim message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgBatchSendToEthClaim
             * @static
             * @param {gravity.v1.MsgBatchSendToEthClaim} message MsgBatchSendToEthClaim
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgBatchSendToEthClaim.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.event_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.event_nonce = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.block_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.block_height = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.batch_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.batch_nonce = options.longs === String ? "0" : 0;
                    object.token_contract = "";
                    object.orchestrator = "";
                }
                if (message.event_nonce != null && message.hasOwnProperty("event_nonce"))
                    if (typeof message.event_nonce === "number")
                        object.event_nonce = options.longs === String ? String(message.event_nonce) : message.event_nonce;
                    else
                        object.event_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.event_nonce) : options.longs === Number ? new $util.LongBits(message.event_nonce.low >>> 0, message.event_nonce.high >>> 0).toNumber(true) : message.event_nonce;
                if (message.block_height != null && message.hasOwnProperty("block_height"))
                    if (typeof message.block_height === "number")
                        object.block_height = options.longs === String ? String(message.block_height) : message.block_height;
                    else
                        object.block_height = options.longs === String ? $util.Long.prototype.toString.call(message.block_height) : options.longs === Number ? new $util.LongBits(message.block_height.low >>> 0, message.block_height.high >>> 0).toNumber(true) : message.block_height;
                if (message.batch_nonce != null && message.hasOwnProperty("batch_nonce"))
                    if (typeof message.batch_nonce === "number")
                        object.batch_nonce = options.longs === String ? String(message.batch_nonce) : message.batch_nonce;
                    else
                        object.batch_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.batch_nonce) : options.longs === Number ? new $util.LongBits(message.batch_nonce.low >>> 0, message.batch_nonce.high >>> 0).toNumber(true) : message.batch_nonce;
                if (message.token_contract != null && message.hasOwnProperty("token_contract"))
                    object.token_contract = message.token_contract;
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    object.orchestrator = message.orchestrator;
                return object;
            };

            /**
             * Converts this MsgBatchSendToEthClaim to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgBatchSendToEthClaim
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgBatchSendToEthClaim.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgBatchSendToEthClaim;
        })();

        v1.MsgBatchSendToEthClaimResponse = (function() {

            /**
             * Properties of a MsgBatchSendToEthClaimResponse.
             * @memberof gravity.v1
             * @interface IMsgBatchSendToEthClaimResponse
             */

            /**
             * Constructs a new MsgBatchSendToEthClaimResponse.
             * @memberof gravity.v1
             * @classdesc Represents a MsgBatchSendToEthClaimResponse.
             * @implements IMsgBatchSendToEthClaimResponse
             * @constructor
             * @param {gravity.v1.IMsgBatchSendToEthClaimResponse=} [properties] Properties to set
             */
            function MsgBatchSendToEthClaimResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified MsgBatchSendToEthClaimResponse message. Does not implicitly {@link gravity.v1.MsgBatchSendToEthClaimResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
             * @static
             * @param {gravity.v1.IMsgBatchSendToEthClaimResponse} message MsgBatchSendToEthClaimResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgBatchSendToEthClaimResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified MsgBatchSendToEthClaimResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgBatchSendToEthClaimResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
             * @static
             * @param {gravity.v1.IMsgBatchSendToEthClaimResponse} message MsgBatchSendToEthClaimResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgBatchSendToEthClaimResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgBatchSendToEthClaimResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgBatchSendToEthClaimResponse} MsgBatchSendToEthClaimResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgBatchSendToEthClaimResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgBatchSendToEthClaimResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgBatchSendToEthClaimResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgBatchSendToEthClaimResponse} MsgBatchSendToEthClaimResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgBatchSendToEthClaimResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgBatchSendToEthClaimResponse message.
             * @function verify
             * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgBatchSendToEthClaimResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a MsgBatchSendToEthClaimResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgBatchSendToEthClaimResponse} MsgBatchSendToEthClaimResponse
             */
            MsgBatchSendToEthClaimResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgBatchSendToEthClaimResponse)
                    return object;
                return new $root.gravity.v1.MsgBatchSendToEthClaimResponse();
            };

            /**
             * Creates a plain object from a MsgBatchSendToEthClaimResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
             * @static
             * @param {gravity.v1.MsgBatchSendToEthClaimResponse} message MsgBatchSendToEthClaimResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgBatchSendToEthClaimResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this MsgBatchSendToEthClaimResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgBatchSendToEthClaimResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgBatchSendToEthClaimResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgBatchSendToEthClaimResponse;
        })();

        v1.MsgERC20DeployedClaim = (function() {

            /**
             * Properties of a MsgERC20DeployedClaim.
             * @memberof gravity.v1
             * @interface IMsgERC20DeployedClaim
             * @property {Long|null} [event_nonce] MsgERC20DeployedClaim event_nonce
             * @property {Long|null} [block_height] MsgERC20DeployedClaim block_height
             * @property {string|null} [cosmos_denom] MsgERC20DeployedClaim cosmos_denom
             * @property {string|null} [token_contract] MsgERC20DeployedClaim token_contract
             * @property {string|null} [name] MsgERC20DeployedClaim name
             * @property {string|null} [symbol] MsgERC20DeployedClaim symbol
             * @property {Long|null} [decimals] MsgERC20DeployedClaim decimals
             * @property {string|null} [orchestrator] MsgERC20DeployedClaim orchestrator
             */

            /**
             * Constructs a new MsgERC20DeployedClaim.
             * @memberof gravity.v1
             * @classdesc Represents a MsgERC20DeployedClaim.
             * @implements IMsgERC20DeployedClaim
             * @constructor
             * @param {gravity.v1.IMsgERC20DeployedClaim=} [properties] Properties to set
             */
            function MsgERC20DeployedClaim(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgERC20DeployedClaim event_nonce.
             * @member {Long} event_nonce
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @instance
             */
            MsgERC20DeployedClaim.prototype.event_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgERC20DeployedClaim block_height.
             * @member {Long} block_height
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @instance
             */
            MsgERC20DeployedClaim.prototype.block_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgERC20DeployedClaim cosmos_denom.
             * @member {string} cosmos_denom
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @instance
             */
            MsgERC20DeployedClaim.prototype.cosmos_denom = "";

            /**
             * MsgERC20DeployedClaim token_contract.
             * @member {string} token_contract
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @instance
             */
            MsgERC20DeployedClaim.prototype.token_contract = "";

            /**
             * MsgERC20DeployedClaim name.
             * @member {string} name
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @instance
             */
            MsgERC20DeployedClaim.prototype.name = "";

            /**
             * MsgERC20DeployedClaim symbol.
             * @member {string} symbol
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @instance
             */
            MsgERC20DeployedClaim.prototype.symbol = "";

            /**
             * MsgERC20DeployedClaim decimals.
             * @member {Long} decimals
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @instance
             */
            MsgERC20DeployedClaim.prototype.decimals = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgERC20DeployedClaim orchestrator.
             * @member {string} orchestrator
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @instance
             */
            MsgERC20DeployedClaim.prototype.orchestrator = "";

            /**
             * Encodes the specified MsgERC20DeployedClaim message. Does not implicitly {@link gravity.v1.MsgERC20DeployedClaim.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @static
             * @param {gravity.v1.IMsgERC20DeployedClaim} message MsgERC20DeployedClaim message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgERC20DeployedClaim.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.event_nonce != null && Object.hasOwnProperty.call(message, "event_nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.event_nonce);
                if (message.block_height != null && Object.hasOwnProperty.call(message, "block_height"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.block_height);
                if (message.cosmos_denom != null && Object.hasOwnProperty.call(message, "cosmos_denom"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.cosmos_denom);
                if (message.token_contract != null && Object.hasOwnProperty.call(message, "token_contract"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.token_contract);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
                if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.symbol);
                if (message.decimals != null && Object.hasOwnProperty.call(message, "decimals"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.decimals);
                if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.orchestrator);
                return writer;
            };

            /**
             * Encodes the specified MsgERC20DeployedClaim message, length delimited. Does not implicitly {@link gravity.v1.MsgERC20DeployedClaim.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @static
             * @param {gravity.v1.IMsgERC20DeployedClaim} message MsgERC20DeployedClaim message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgERC20DeployedClaim.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgERC20DeployedClaim message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgERC20DeployedClaim} MsgERC20DeployedClaim
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgERC20DeployedClaim.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgERC20DeployedClaim();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.event_nonce = reader.uint64();
                        break;
                    case 2:
                        message.block_height = reader.uint64();
                        break;
                    case 3:
                        message.cosmos_denom = reader.string();
                        break;
                    case 4:
                        message.token_contract = reader.string();
                        break;
                    case 5:
                        message.name = reader.string();
                        break;
                    case 6:
                        message.symbol = reader.string();
                        break;
                    case 7:
                        message.decimals = reader.uint64();
                        break;
                    case 8:
                        message.orchestrator = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgERC20DeployedClaim message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgERC20DeployedClaim} MsgERC20DeployedClaim
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgERC20DeployedClaim.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgERC20DeployedClaim message.
             * @function verify
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgERC20DeployedClaim.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.event_nonce != null && message.hasOwnProperty("event_nonce"))
                    if (!$util.isInteger(message.event_nonce) && !(message.event_nonce && $util.isInteger(message.event_nonce.low) && $util.isInteger(message.event_nonce.high)))
                        return "event_nonce: integer|Long expected";
                if (message.block_height != null && message.hasOwnProperty("block_height"))
                    if (!$util.isInteger(message.block_height) && !(message.block_height && $util.isInteger(message.block_height.low) && $util.isInteger(message.block_height.high)))
                        return "block_height: integer|Long expected";
                if (message.cosmos_denom != null && message.hasOwnProperty("cosmos_denom"))
                    if (!$util.isString(message.cosmos_denom))
                        return "cosmos_denom: string expected";
                if (message.token_contract != null && message.hasOwnProperty("token_contract"))
                    if (!$util.isString(message.token_contract))
                        return "token_contract: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.symbol != null && message.hasOwnProperty("symbol"))
                    if (!$util.isString(message.symbol))
                        return "symbol: string expected";
                if (message.decimals != null && message.hasOwnProperty("decimals"))
                    if (!$util.isInteger(message.decimals) && !(message.decimals && $util.isInteger(message.decimals.low) && $util.isInteger(message.decimals.high)))
                        return "decimals: integer|Long expected";
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    if (!$util.isString(message.orchestrator))
                        return "orchestrator: string expected";
                return null;
            };

            /**
             * Creates a MsgERC20DeployedClaim message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgERC20DeployedClaim} MsgERC20DeployedClaim
             */
            MsgERC20DeployedClaim.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgERC20DeployedClaim)
                    return object;
                let message = new $root.gravity.v1.MsgERC20DeployedClaim();
                if (object.event_nonce != null)
                    if ($util.Long)
                        (message.event_nonce = $util.Long.fromValue(object.event_nonce)).unsigned = true;
                    else if (typeof object.event_nonce === "string")
                        message.event_nonce = parseInt(object.event_nonce, 10);
                    else if (typeof object.event_nonce === "number")
                        message.event_nonce = object.event_nonce;
                    else if (typeof object.event_nonce === "object")
                        message.event_nonce = new $util.LongBits(object.event_nonce.low >>> 0, object.event_nonce.high >>> 0).toNumber(true);
                if (object.block_height != null)
                    if ($util.Long)
                        (message.block_height = $util.Long.fromValue(object.block_height)).unsigned = true;
                    else if (typeof object.block_height === "string")
                        message.block_height = parseInt(object.block_height, 10);
                    else if (typeof object.block_height === "number")
                        message.block_height = object.block_height;
                    else if (typeof object.block_height === "object")
                        message.block_height = new $util.LongBits(object.block_height.low >>> 0, object.block_height.high >>> 0).toNumber(true);
                if (object.cosmos_denom != null)
                    message.cosmos_denom = String(object.cosmos_denom);
                if (object.token_contract != null)
                    message.token_contract = String(object.token_contract);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.symbol != null)
                    message.symbol = String(object.symbol);
                if (object.decimals != null)
                    if ($util.Long)
                        (message.decimals = $util.Long.fromValue(object.decimals)).unsigned = true;
                    else if (typeof object.decimals === "string")
                        message.decimals = parseInt(object.decimals, 10);
                    else if (typeof object.decimals === "number")
                        message.decimals = object.decimals;
                    else if (typeof object.decimals === "object")
                        message.decimals = new $util.LongBits(object.decimals.low >>> 0, object.decimals.high >>> 0).toNumber(true);
                if (object.orchestrator != null)
                    message.orchestrator = String(object.orchestrator);
                return message;
            };

            /**
             * Creates a plain object from a MsgERC20DeployedClaim message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @static
             * @param {gravity.v1.MsgERC20DeployedClaim} message MsgERC20DeployedClaim
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgERC20DeployedClaim.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.event_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.event_nonce = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.block_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.block_height = options.longs === String ? "0" : 0;
                    object.cosmos_denom = "";
                    object.token_contract = "";
                    object.name = "";
                    object.symbol = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.decimals = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.decimals = options.longs === String ? "0" : 0;
                    object.orchestrator = "";
                }
                if (message.event_nonce != null && message.hasOwnProperty("event_nonce"))
                    if (typeof message.event_nonce === "number")
                        object.event_nonce = options.longs === String ? String(message.event_nonce) : message.event_nonce;
                    else
                        object.event_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.event_nonce) : options.longs === Number ? new $util.LongBits(message.event_nonce.low >>> 0, message.event_nonce.high >>> 0).toNumber(true) : message.event_nonce;
                if (message.block_height != null && message.hasOwnProperty("block_height"))
                    if (typeof message.block_height === "number")
                        object.block_height = options.longs === String ? String(message.block_height) : message.block_height;
                    else
                        object.block_height = options.longs === String ? $util.Long.prototype.toString.call(message.block_height) : options.longs === Number ? new $util.LongBits(message.block_height.low >>> 0, message.block_height.high >>> 0).toNumber(true) : message.block_height;
                if (message.cosmos_denom != null && message.hasOwnProperty("cosmos_denom"))
                    object.cosmos_denom = message.cosmos_denom;
                if (message.token_contract != null && message.hasOwnProperty("token_contract"))
                    object.token_contract = message.token_contract;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.symbol != null && message.hasOwnProperty("symbol"))
                    object.symbol = message.symbol;
                if (message.decimals != null && message.hasOwnProperty("decimals"))
                    if (typeof message.decimals === "number")
                        object.decimals = options.longs === String ? String(message.decimals) : message.decimals;
                    else
                        object.decimals = options.longs === String ? $util.Long.prototype.toString.call(message.decimals) : options.longs === Number ? new $util.LongBits(message.decimals.low >>> 0, message.decimals.high >>> 0).toNumber(true) : message.decimals;
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    object.orchestrator = message.orchestrator;
                return object;
            };

            /**
             * Converts this MsgERC20DeployedClaim to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgERC20DeployedClaim
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgERC20DeployedClaim.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgERC20DeployedClaim;
        })();

        v1.MsgERC20DeployedClaimResponse = (function() {

            /**
             * Properties of a MsgERC20DeployedClaimResponse.
             * @memberof gravity.v1
             * @interface IMsgERC20DeployedClaimResponse
             */

            /**
             * Constructs a new MsgERC20DeployedClaimResponse.
             * @memberof gravity.v1
             * @classdesc Represents a MsgERC20DeployedClaimResponse.
             * @implements IMsgERC20DeployedClaimResponse
             * @constructor
             * @param {gravity.v1.IMsgERC20DeployedClaimResponse=} [properties] Properties to set
             */
            function MsgERC20DeployedClaimResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified MsgERC20DeployedClaimResponse message. Does not implicitly {@link gravity.v1.MsgERC20DeployedClaimResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgERC20DeployedClaimResponse
             * @static
             * @param {gravity.v1.IMsgERC20DeployedClaimResponse} message MsgERC20DeployedClaimResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgERC20DeployedClaimResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified MsgERC20DeployedClaimResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgERC20DeployedClaimResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgERC20DeployedClaimResponse
             * @static
             * @param {gravity.v1.IMsgERC20DeployedClaimResponse} message MsgERC20DeployedClaimResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgERC20DeployedClaimResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgERC20DeployedClaimResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgERC20DeployedClaimResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgERC20DeployedClaimResponse} MsgERC20DeployedClaimResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgERC20DeployedClaimResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgERC20DeployedClaimResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgERC20DeployedClaimResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgERC20DeployedClaimResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgERC20DeployedClaimResponse} MsgERC20DeployedClaimResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgERC20DeployedClaimResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgERC20DeployedClaimResponse message.
             * @function verify
             * @memberof gravity.v1.MsgERC20DeployedClaimResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgERC20DeployedClaimResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a MsgERC20DeployedClaimResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgERC20DeployedClaimResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgERC20DeployedClaimResponse} MsgERC20DeployedClaimResponse
             */
            MsgERC20DeployedClaimResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgERC20DeployedClaimResponse)
                    return object;
                return new $root.gravity.v1.MsgERC20DeployedClaimResponse();
            };

            /**
             * Creates a plain object from a MsgERC20DeployedClaimResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgERC20DeployedClaimResponse
             * @static
             * @param {gravity.v1.MsgERC20DeployedClaimResponse} message MsgERC20DeployedClaimResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgERC20DeployedClaimResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this MsgERC20DeployedClaimResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgERC20DeployedClaimResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgERC20DeployedClaimResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgERC20DeployedClaimResponse;
        })();

        v1.MsgLogicCallExecutedClaim = (function() {

            /**
             * Properties of a MsgLogicCallExecutedClaim.
             * @memberof gravity.v1
             * @interface IMsgLogicCallExecutedClaim
             * @property {Long|null} [event_nonce] MsgLogicCallExecutedClaim event_nonce
             * @property {Long|null} [block_height] MsgLogicCallExecutedClaim block_height
             * @property {Uint8Array|null} [invalidation_id] MsgLogicCallExecutedClaim invalidation_id
             * @property {Long|null} [invalidation_nonce] MsgLogicCallExecutedClaim invalidation_nonce
             * @property {string|null} [orchestrator] MsgLogicCallExecutedClaim orchestrator
             */

            /**
             * Constructs a new MsgLogicCallExecutedClaim.
             * @memberof gravity.v1
             * @classdesc Represents a MsgLogicCallExecutedClaim.
             * @implements IMsgLogicCallExecutedClaim
             * @constructor
             * @param {gravity.v1.IMsgLogicCallExecutedClaim=} [properties] Properties to set
             */
            function MsgLogicCallExecutedClaim(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgLogicCallExecutedClaim event_nonce.
             * @member {Long} event_nonce
             * @memberof gravity.v1.MsgLogicCallExecutedClaim
             * @instance
             */
            MsgLogicCallExecutedClaim.prototype.event_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgLogicCallExecutedClaim block_height.
             * @member {Long} block_height
             * @memberof gravity.v1.MsgLogicCallExecutedClaim
             * @instance
             */
            MsgLogicCallExecutedClaim.prototype.block_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgLogicCallExecutedClaim invalidation_id.
             * @member {Uint8Array} invalidation_id
             * @memberof gravity.v1.MsgLogicCallExecutedClaim
             * @instance
             */
            MsgLogicCallExecutedClaim.prototype.invalidation_id = $util.newBuffer([]);

            /**
             * MsgLogicCallExecutedClaim invalidation_nonce.
             * @member {Long} invalidation_nonce
             * @memberof gravity.v1.MsgLogicCallExecutedClaim
             * @instance
             */
            MsgLogicCallExecutedClaim.prototype.invalidation_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgLogicCallExecutedClaim orchestrator.
             * @member {string} orchestrator
             * @memberof gravity.v1.MsgLogicCallExecutedClaim
             * @instance
             */
            MsgLogicCallExecutedClaim.prototype.orchestrator = "";

            /**
             * Encodes the specified MsgLogicCallExecutedClaim message. Does not implicitly {@link gravity.v1.MsgLogicCallExecutedClaim.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgLogicCallExecutedClaim
             * @static
             * @param {gravity.v1.IMsgLogicCallExecutedClaim} message MsgLogicCallExecutedClaim message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgLogicCallExecutedClaim.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.event_nonce != null && Object.hasOwnProperty.call(message, "event_nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.event_nonce);
                if (message.block_height != null && Object.hasOwnProperty.call(message, "block_height"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.block_height);
                if (message.invalidation_id != null && Object.hasOwnProperty.call(message, "invalidation_id"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.invalidation_id);
                if (message.invalidation_nonce != null && Object.hasOwnProperty.call(message, "invalidation_nonce"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.invalidation_nonce);
                if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.orchestrator);
                return writer;
            };

            /**
             * Encodes the specified MsgLogicCallExecutedClaim message, length delimited. Does not implicitly {@link gravity.v1.MsgLogicCallExecutedClaim.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgLogicCallExecutedClaim
             * @static
             * @param {gravity.v1.IMsgLogicCallExecutedClaim} message MsgLogicCallExecutedClaim message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgLogicCallExecutedClaim.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgLogicCallExecutedClaim message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgLogicCallExecutedClaim
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgLogicCallExecutedClaim} MsgLogicCallExecutedClaim
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgLogicCallExecutedClaim.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgLogicCallExecutedClaim();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.event_nonce = reader.uint64();
                        break;
                    case 2:
                        message.block_height = reader.uint64();
                        break;
                    case 3:
                        message.invalidation_id = reader.bytes();
                        break;
                    case 4:
                        message.invalidation_nonce = reader.uint64();
                        break;
                    case 5:
                        message.orchestrator = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgLogicCallExecutedClaim message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgLogicCallExecutedClaim
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgLogicCallExecutedClaim} MsgLogicCallExecutedClaim
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgLogicCallExecutedClaim.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgLogicCallExecutedClaim message.
             * @function verify
             * @memberof gravity.v1.MsgLogicCallExecutedClaim
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgLogicCallExecutedClaim.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.event_nonce != null && message.hasOwnProperty("event_nonce"))
                    if (!$util.isInteger(message.event_nonce) && !(message.event_nonce && $util.isInteger(message.event_nonce.low) && $util.isInteger(message.event_nonce.high)))
                        return "event_nonce: integer|Long expected";
                if (message.block_height != null && message.hasOwnProperty("block_height"))
                    if (!$util.isInteger(message.block_height) && !(message.block_height && $util.isInteger(message.block_height.low) && $util.isInteger(message.block_height.high)))
                        return "block_height: integer|Long expected";
                if (message.invalidation_id != null && message.hasOwnProperty("invalidation_id"))
                    if (!(message.invalidation_id && typeof message.invalidation_id.length === "number" || $util.isString(message.invalidation_id)))
                        return "invalidation_id: buffer expected";
                if (message.invalidation_nonce != null && message.hasOwnProperty("invalidation_nonce"))
                    if (!$util.isInteger(message.invalidation_nonce) && !(message.invalidation_nonce && $util.isInteger(message.invalidation_nonce.low) && $util.isInteger(message.invalidation_nonce.high)))
                        return "invalidation_nonce: integer|Long expected";
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    if (!$util.isString(message.orchestrator))
                        return "orchestrator: string expected";
                return null;
            };

            /**
             * Creates a MsgLogicCallExecutedClaim message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgLogicCallExecutedClaim
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgLogicCallExecutedClaim} MsgLogicCallExecutedClaim
             */
            MsgLogicCallExecutedClaim.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgLogicCallExecutedClaim)
                    return object;
                let message = new $root.gravity.v1.MsgLogicCallExecutedClaim();
                if (object.event_nonce != null)
                    if ($util.Long)
                        (message.event_nonce = $util.Long.fromValue(object.event_nonce)).unsigned = true;
                    else if (typeof object.event_nonce === "string")
                        message.event_nonce = parseInt(object.event_nonce, 10);
                    else if (typeof object.event_nonce === "number")
                        message.event_nonce = object.event_nonce;
                    else if (typeof object.event_nonce === "object")
                        message.event_nonce = new $util.LongBits(object.event_nonce.low >>> 0, object.event_nonce.high >>> 0).toNumber(true);
                if (object.block_height != null)
                    if ($util.Long)
                        (message.block_height = $util.Long.fromValue(object.block_height)).unsigned = true;
                    else if (typeof object.block_height === "string")
                        message.block_height = parseInt(object.block_height, 10);
                    else if (typeof object.block_height === "number")
                        message.block_height = object.block_height;
                    else if (typeof object.block_height === "object")
                        message.block_height = new $util.LongBits(object.block_height.low >>> 0, object.block_height.high >>> 0).toNumber(true);
                if (object.invalidation_id != null)
                    if (typeof object.invalidation_id === "string")
                        $util.base64.decode(object.invalidation_id, message.invalidation_id = $util.newBuffer($util.base64.length(object.invalidation_id)), 0);
                    else if (object.invalidation_id.length)
                        message.invalidation_id = object.invalidation_id;
                if (object.invalidation_nonce != null)
                    if ($util.Long)
                        (message.invalidation_nonce = $util.Long.fromValue(object.invalidation_nonce)).unsigned = true;
                    else if (typeof object.invalidation_nonce === "string")
                        message.invalidation_nonce = parseInt(object.invalidation_nonce, 10);
                    else if (typeof object.invalidation_nonce === "number")
                        message.invalidation_nonce = object.invalidation_nonce;
                    else if (typeof object.invalidation_nonce === "object")
                        message.invalidation_nonce = new $util.LongBits(object.invalidation_nonce.low >>> 0, object.invalidation_nonce.high >>> 0).toNumber(true);
                if (object.orchestrator != null)
                    message.orchestrator = String(object.orchestrator);
                return message;
            };

            /**
             * Creates a plain object from a MsgLogicCallExecutedClaim message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgLogicCallExecutedClaim
             * @static
             * @param {gravity.v1.MsgLogicCallExecutedClaim} message MsgLogicCallExecutedClaim
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgLogicCallExecutedClaim.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.event_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.event_nonce = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.block_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.block_height = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.invalidation_id = "";
                    else {
                        object.invalidation_id = [];
                        if (options.bytes !== Array)
                            object.invalidation_id = $util.newBuffer(object.invalidation_id);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.invalidation_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.invalidation_nonce = options.longs === String ? "0" : 0;
                    object.orchestrator = "";
                }
                if (message.event_nonce != null && message.hasOwnProperty("event_nonce"))
                    if (typeof message.event_nonce === "number")
                        object.event_nonce = options.longs === String ? String(message.event_nonce) : message.event_nonce;
                    else
                        object.event_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.event_nonce) : options.longs === Number ? new $util.LongBits(message.event_nonce.low >>> 0, message.event_nonce.high >>> 0).toNumber(true) : message.event_nonce;
                if (message.block_height != null && message.hasOwnProperty("block_height"))
                    if (typeof message.block_height === "number")
                        object.block_height = options.longs === String ? String(message.block_height) : message.block_height;
                    else
                        object.block_height = options.longs === String ? $util.Long.prototype.toString.call(message.block_height) : options.longs === Number ? new $util.LongBits(message.block_height.low >>> 0, message.block_height.high >>> 0).toNumber(true) : message.block_height;
                if (message.invalidation_id != null && message.hasOwnProperty("invalidation_id"))
                    object.invalidation_id = options.bytes === String ? $util.base64.encode(message.invalidation_id, 0, message.invalidation_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.invalidation_id) : message.invalidation_id;
                if (message.invalidation_nonce != null && message.hasOwnProperty("invalidation_nonce"))
                    if (typeof message.invalidation_nonce === "number")
                        object.invalidation_nonce = options.longs === String ? String(message.invalidation_nonce) : message.invalidation_nonce;
                    else
                        object.invalidation_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.invalidation_nonce) : options.longs === Number ? new $util.LongBits(message.invalidation_nonce.low >>> 0, message.invalidation_nonce.high >>> 0).toNumber(true) : message.invalidation_nonce;
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    object.orchestrator = message.orchestrator;
                return object;
            };

            /**
             * Converts this MsgLogicCallExecutedClaim to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgLogicCallExecutedClaim
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgLogicCallExecutedClaim.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgLogicCallExecutedClaim;
        })();

        v1.MsgLogicCallExecutedClaimResponse = (function() {

            /**
             * Properties of a MsgLogicCallExecutedClaimResponse.
             * @memberof gravity.v1
             * @interface IMsgLogicCallExecutedClaimResponse
             */

            /**
             * Constructs a new MsgLogicCallExecutedClaimResponse.
             * @memberof gravity.v1
             * @classdesc Represents a MsgLogicCallExecutedClaimResponse.
             * @implements IMsgLogicCallExecutedClaimResponse
             * @constructor
             * @param {gravity.v1.IMsgLogicCallExecutedClaimResponse=} [properties] Properties to set
             */
            function MsgLogicCallExecutedClaimResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified MsgLogicCallExecutedClaimResponse message. Does not implicitly {@link gravity.v1.MsgLogicCallExecutedClaimResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
             * @static
             * @param {gravity.v1.IMsgLogicCallExecutedClaimResponse} message MsgLogicCallExecutedClaimResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgLogicCallExecutedClaimResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified MsgLogicCallExecutedClaimResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgLogicCallExecutedClaimResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
             * @static
             * @param {gravity.v1.IMsgLogicCallExecutedClaimResponse} message MsgLogicCallExecutedClaimResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgLogicCallExecutedClaimResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgLogicCallExecutedClaimResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgLogicCallExecutedClaimResponse} MsgLogicCallExecutedClaimResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgLogicCallExecutedClaimResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgLogicCallExecutedClaimResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgLogicCallExecutedClaimResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgLogicCallExecutedClaimResponse} MsgLogicCallExecutedClaimResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgLogicCallExecutedClaimResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgLogicCallExecutedClaimResponse message.
             * @function verify
             * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgLogicCallExecutedClaimResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a MsgLogicCallExecutedClaimResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgLogicCallExecutedClaimResponse} MsgLogicCallExecutedClaimResponse
             */
            MsgLogicCallExecutedClaimResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgLogicCallExecutedClaimResponse)
                    return object;
                return new $root.gravity.v1.MsgLogicCallExecutedClaimResponse();
            };

            /**
             * Creates a plain object from a MsgLogicCallExecutedClaimResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
             * @static
             * @param {gravity.v1.MsgLogicCallExecutedClaimResponse} message MsgLogicCallExecutedClaimResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgLogicCallExecutedClaimResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this MsgLogicCallExecutedClaimResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgLogicCallExecutedClaimResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgLogicCallExecutedClaimResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgLogicCallExecutedClaimResponse;
        })();

        v1.MsgValsetUpdatedClaim = (function() {

            /**
             * Properties of a MsgValsetUpdatedClaim.
             * @memberof gravity.v1
             * @interface IMsgValsetUpdatedClaim
             * @property {Long|null} [event_nonce] MsgValsetUpdatedClaim event_nonce
             * @property {Long|null} [valset_nonce] MsgValsetUpdatedClaim valset_nonce
             * @property {Long|null} [block_height] MsgValsetUpdatedClaim block_height
             * @property {Array.<gravity.v1.IBridgeValidator>|null} [members] MsgValsetUpdatedClaim members
             * @property {string|null} [reward_amount] MsgValsetUpdatedClaim reward_amount
             * @property {string|null} [reward_token] MsgValsetUpdatedClaim reward_token
             * @property {string|null} [orchestrator] MsgValsetUpdatedClaim orchestrator
             */

            /**
             * Constructs a new MsgValsetUpdatedClaim.
             * @memberof gravity.v1
             * @classdesc Represents a MsgValsetUpdatedClaim.
             * @implements IMsgValsetUpdatedClaim
             * @constructor
             * @param {gravity.v1.IMsgValsetUpdatedClaim=} [properties] Properties to set
             */
            function MsgValsetUpdatedClaim(properties) {
                this.members = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgValsetUpdatedClaim event_nonce.
             * @member {Long} event_nonce
             * @memberof gravity.v1.MsgValsetUpdatedClaim
             * @instance
             */
            MsgValsetUpdatedClaim.prototype.event_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgValsetUpdatedClaim valset_nonce.
             * @member {Long} valset_nonce
             * @memberof gravity.v1.MsgValsetUpdatedClaim
             * @instance
             */
            MsgValsetUpdatedClaim.prototype.valset_nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgValsetUpdatedClaim block_height.
             * @member {Long} block_height
             * @memberof gravity.v1.MsgValsetUpdatedClaim
             * @instance
             */
            MsgValsetUpdatedClaim.prototype.block_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgValsetUpdatedClaim members.
             * @member {Array.<gravity.v1.IBridgeValidator>} members
             * @memberof gravity.v1.MsgValsetUpdatedClaim
             * @instance
             */
            MsgValsetUpdatedClaim.prototype.members = $util.emptyArray;

            /**
             * MsgValsetUpdatedClaim reward_amount.
             * @member {string} reward_amount
             * @memberof gravity.v1.MsgValsetUpdatedClaim
             * @instance
             */
            MsgValsetUpdatedClaim.prototype.reward_amount = "";

            /**
             * MsgValsetUpdatedClaim reward_token.
             * @member {string} reward_token
             * @memberof gravity.v1.MsgValsetUpdatedClaim
             * @instance
             */
            MsgValsetUpdatedClaim.prototype.reward_token = "";

            /**
             * MsgValsetUpdatedClaim orchestrator.
             * @member {string} orchestrator
             * @memberof gravity.v1.MsgValsetUpdatedClaim
             * @instance
             */
            MsgValsetUpdatedClaim.prototype.orchestrator = "";

            /**
             * Encodes the specified MsgValsetUpdatedClaim message. Does not implicitly {@link gravity.v1.MsgValsetUpdatedClaim.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgValsetUpdatedClaim
             * @static
             * @param {gravity.v1.IMsgValsetUpdatedClaim} message MsgValsetUpdatedClaim message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgValsetUpdatedClaim.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.event_nonce != null && Object.hasOwnProperty.call(message, "event_nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.event_nonce);
                if (message.valset_nonce != null && Object.hasOwnProperty.call(message, "valset_nonce"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.valset_nonce);
                if (message.block_height != null && Object.hasOwnProperty.call(message, "block_height"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.block_height);
                if (message.members != null && message.members.length)
                    for (let i = 0; i < message.members.length; ++i)
                        $root.gravity.v1.BridgeValidator.encode(message.members[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.reward_amount != null && Object.hasOwnProperty.call(message, "reward_amount"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.reward_amount);
                if (message.reward_token != null && Object.hasOwnProperty.call(message, "reward_token"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.reward_token);
                if (message.orchestrator != null && Object.hasOwnProperty.call(message, "orchestrator"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.orchestrator);
                return writer;
            };

            /**
             * Encodes the specified MsgValsetUpdatedClaim message, length delimited. Does not implicitly {@link gravity.v1.MsgValsetUpdatedClaim.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgValsetUpdatedClaim
             * @static
             * @param {gravity.v1.IMsgValsetUpdatedClaim} message MsgValsetUpdatedClaim message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgValsetUpdatedClaim.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgValsetUpdatedClaim message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgValsetUpdatedClaim
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgValsetUpdatedClaim} MsgValsetUpdatedClaim
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgValsetUpdatedClaim.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgValsetUpdatedClaim();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.event_nonce = reader.uint64();
                        break;
                    case 2:
                        message.valset_nonce = reader.uint64();
                        break;
                    case 3:
                        message.block_height = reader.uint64();
                        break;
                    case 4:
                        if (!(message.members && message.members.length))
                            message.members = [];
                        message.members.push($root.gravity.v1.BridgeValidator.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.reward_amount = reader.string();
                        break;
                    case 6:
                        message.reward_token = reader.string();
                        break;
                    case 7:
                        message.orchestrator = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgValsetUpdatedClaim message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgValsetUpdatedClaim
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgValsetUpdatedClaim} MsgValsetUpdatedClaim
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgValsetUpdatedClaim.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgValsetUpdatedClaim message.
             * @function verify
             * @memberof gravity.v1.MsgValsetUpdatedClaim
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgValsetUpdatedClaim.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.event_nonce != null && message.hasOwnProperty("event_nonce"))
                    if (!$util.isInteger(message.event_nonce) && !(message.event_nonce && $util.isInteger(message.event_nonce.low) && $util.isInteger(message.event_nonce.high)))
                        return "event_nonce: integer|Long expected";
                if (message.valset_nonce != null && message.hasOwnProperty("valset_nonce"))
                    if (!$util.isInteger(message.valset_nonce) && !(message.valset_nonce && $util.isInteger(message.valset_nonce.low) && $util.isInteger(message.valset_nonce.high)))
                        return "valset_nonce: integer|Long expected";
                if (message.block_height != null && message.hasOwnProperty("block_height"))
                    if (!$util.isInteger(message.block_height) && !(message.block_height && $util.isInteger(message.block_height.low) && $util.isInteger(message.block_height.high)))
                        return "block_height: integer|Long expected";
                if (message.members != null && message.hasOwnProperty("members")) {
                    if (!Array.isArray(message.members))
                        return "members: array expected";
                    for (let i = 0; i < message.members.length; ++i) {
                        let error = $root.gravity.v1.BridgeValidator.verify(message.members[i]);
                        if (error)
                            return "members." + error;
                    }
                }
                if (message.reward_amount != null && message.hasOwnProperty("reward_amount"))
                    if (!$util.isString(message.reward_amount))
                        return "reward_amount: string expected";
                if (message.reward_token != null && message.hasOwnProperty("reward_token"))
                    if (!$util.isString(message.reward_token))
                        return "reward_token: string expected";
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    if (!$util.isString(message.orchestrator))
                        return "orchestrator: string expected";
                return null;
            };

            /**
             * Creates a MsgValsetUpdatedClaim message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgValsetUpdatedClaim
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgValsetUpdatedClaim} MsgValsetUpdatedClaim
             */
            MsgValsetUpdatedClaim.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgValsetUpdatedClaim)
                    return object;
                let message = new $root.gravity.v1.MsgValsetUpdatedClaim();
                if (object.event_nonce != null)
                    if ($util.Long)
                        (message.event_nonce = $util.Long.fromValue(object.event_nonce)).unsigned = true;
                    else if (typeof object.event_nonce === "string")
                        message.event_nonce = parseInt(object.event_nonce, 10);
                    else if (typeof object.event_nonce === "number")
                        message.event_nonce = object.event_nonce;
                    else if (typeof object.event_nonce === "object")
                        message.event_nonce = new $util.LongBits(object.event_nonce.low >>> 0, object.event_nonce.high >>> 0).toNumber(true);
                if (object.valset_nonce != null)
                    if ($util.Long)
                        (message.valset_nonce = $util.Long.fromValue(object.valset_nonce)).unsigned = true;
                    else if (typeof object.valset_nonce === "string")
                        message.valset_nonce = parseInt(object.valset_nonce, 10);
                    else if (typeof object.valset_nonce === "number")
                        message.valset_nonce = object.valset_nonce;
                    else if (typeof object.valset_nonce === "object")
                        message.valset_nonce = new $util.LongBits(object.valset_nonce.low >>> 0, object.valset_nonce.high >>> 0).toNumber(true);
                if (object.block_height != null)
                    if ($util.Long)
                        (message.block_height = $util.Long.fromValue(object.block_height)).unsigned = true;
                    else if (typeof object.block_height === "string")
                        message.block_height = parseInt(object.block_height, 10);
                    else if (typeof object.block_height === "number")
                        message.block_height = object.block_height;
                    else if (typeof object.block_height === "object")
                        message.block_height = new $util.LongBits(object.block_height.low >>> 0, object.block_height.high >>> 0).toNumber(true);
                if (object.members) {
                    if (!Array.isArray(object.members))
                        throw TypeError(".gravity.v1.MsgValsetUpdatedClaim.members: array expected");
                    message.members = [];
                    for (let i = 0; i < object.members.length; ++i) {
                        if (typeof object.members[i] !== "object")
                            throw TypeError(".gravity.v1.MsgValsetUpdatedClaim.members: object expected");
                        message.members[i] = $root.gravity.v1.BridgeValidator.fromObject(object.members[i]);
                    }
                }
                if (object.reward_amount != null)
                    message.reward_amount = String(object.reward_amount);
                if (object.reward_token != null)
                    message.reward_token = String(object.reward_token);
                if (object.orchestrator != null)
                    message.orchestrator = String(object.orchestrator);
                return message;
            };

            /**
             * Creates a plain object from a MsgValsetUpdatedClaim message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgValsetUpdatedClaim
             * @static
             * @param {gravity.v1.MsgValsetUpdatedClaim} message MsgValsetUpdatedClaim
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgValsetUpdatedClaim.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.members = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.event_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.event_nonce = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.valset_nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.valset_nonce = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.block_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.block_height = options.longs === String ? "0" : 0;
                    object.reward_amount = "";
                    object.reward_token = "";
                    object.orchestrator = "";
                }
                if (message.event_nonce != null && message.hasOwnProperty("event_nonce"))
                    if (typeof message.event_nonce === "number")
                        object.event_nonce = options.longs === String ? String(message.event_nonce) : message.event_nonce;
                    else
                        object.event_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.event_nonce) : options.longs === Number ? new $util.LongBits(message.event_nonce.low >>> 0, message.event_nonce.high >>> 0).toNumber(true) : message.event_nonce;
                if (message.valset_nonce != null && message.hasOwnProperty("valset_nonce"))
                    if (typeof message.valset_nonce === "number")
                        object.valset_nonce = options.longs === String ? String(message.valset_nonce) : message.valset_nonce;
                    else
                        object.valset_nonce = options.longs === String ? $util.Long.prototype.toString.call(message.valset_nonce) : options.longs === Number ? new $util.LongBits(message.valset_nonce.low >>> 0, message.valset_nonce.high >>> 0).toNumber(true) : message.valset_nonce;
                if (message.block_height != null && message.hasOwnProperty("block_height"))
                    if (typeof message.block_height === "number")
                        object.block_height = options.longs === String ? String(message.block_height) : message.block_height;
                    else
                        object.block_height = options.longs === String ? $util.Long.prototype.toString.call(message.block_height) : options.longs === Number ? new $util.LongBits(message.block_height.low >>> 0, message.block_height.high >>> 0).toNumber(true) : message.block_height;
                if (message.members && message.members.length) {
                    object.members = [];
                    for (let j = 0; j < message.members.length; ++j)
                        object.members[j] = $root.gravity.v1.BridgeValidator.toObject(message.members[j], options);
                }
                if (message.reward_amount != null && message.hasOwnProperty("reward_amount"))
                    object.reward_amount = message.reward_amount;
                if (message.reward_token != null && message.hasOwnProperty("reward_token"))
                    object.reward_token = message.reward_token;
                if (message.orchestrator != null && message.hasOwnProperty("orchestrator"))
                    object.orchestrator = message.orchestrator;
                return object;
            };

            /**
             * Converts this MsgValsetUpdatedClaim to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgValsetUpdatedClaim
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgValsetUpdatedClaim.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgValsetUpdatedClaim;
        })();

        v1.MsgValsetUpdatedClaimResponse = (function() {

            /**
             * Properties of a MsgValsetUpdatedClaimResponse.
             * @memberof gravity.v1
             * @interface IMsgValsetUpdatedClaimResponse
             */

            /**
             * Constructs a new MsgValsetUpdatedClaimResponse.
             * @memberof gravity.v1
             * @classdesc Represents a MsgValsetUpdatedClaimResponse.
             * @implements IMsgValsetUpdatedClaimResponse
             * @constructor
             * @param {gravity.v1.IMsgValsetUpdatedClaimResponse=} [properties] Properties to set
             */
            function MsgValsetUpdatedClaimResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified MsgValsetUpdatedClaimResponse message. Does not implicitly {@link gravity.v1.MsgValsetUpdatedClaimResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
             * @static
             * @param {gravity.v1.IMsgValsetUpdatedClaimResponse} message MsgValsetUpdatedClaimResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgValsetUpdatedClaimResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified MsgValsetUpdatedClaimResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgValsetUpdatedClaimResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
             * @static
             * @param {gravity.v1.IMsgValsetUpdatedClaimResponse} message MsgValsetUpdatedClaimResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgValsetUpdatedClaimResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgValsetUpdatedClaimResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgValsetUpdatedClaimResponse} MsgValsetUpdatedClaimResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgValsetUpdatedClaimResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgValsetUpdatedClaimResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgValsetUpdatedClaimResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgValsetUpdatedClaimResponse} MsgValsetUpdatedClaimResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgValsetUpdatedClaimResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgValsetUpdatedClaimResponse message.
             * @function verify
             * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgValsetUpdatedClaimResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a MsgValsetUpdatedClaimResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgValsetUpdatedClaimResponse} MsgValsetUpdatedClaimResponse
             */
            MsgValsetUpdatedClaimResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgValsetUpdatedClaimResponse)
                    return object;
                return new $root.gravity.v1.MsgValsetUpdatedClaimResponse();
            };

            /**
             * Creates a plain object from a MsgValsetUpdatedClaimResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
             * @static
             * @param {gravity.v1.MsgValsetUpdatedClaimResponse} message MsgValsetUpdatedClaimResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgValsetUpdatedClaimResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this MsgValsetUpdatedClaimResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgValsetUpdatedClaimResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgValsetUpdatedClaimResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgValsetUpdatedClaimResponse;
        })();

        v1.MsgCancelSendToEth = (function() {

            /**
             * Properties of a MsgCancelSendToEth.
             * @memberof gravity.v1
             * @interface IMsgCancelSendToEth
             * @property {Long|null} [transaction_id] MsgCancelSendToEth transaction_id
             * @property {string|null} [sender] MsgCancelSendToEth sender
             */

            /**
             * Constructs a new MsgCancelSendToEth.
             * @memberof gravity.v1
             * @classdesc Represents a MsgCancelSendToEth.
             * @implements IMsgCancelSendToEth
             * @constructor
             * @param {gravity.v1.IMsgCancelSendToEth=} [properties] Properties to set
             */
            function MsgCancelSendToEth(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgCancelSendToEth transaction_id.
             * @member {Long} transaction_id
             * @memberof gravity.v1.MsgCancelSendToEth
             * @instance
             */
            MsgCancelSendToEth.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MsgCancelSendToEth sender.
             * @member {string} sender
             * @memberof gravity.v1.MsgCancelSendToEth
             * @instance
             */
            MsgCancelSendToEth.prototype.sender = "";

            /**
             * Encodes the specified MsgCancelSendToEth message. Does not implicitly {@link gravity.v1.MsgCancelSendToEth.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgCancelSendToEth
             * @static
             * @param {gravity.v1.IMsgCancelSendToEth} message MsgCancelSendToEth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgCancelSendToEth.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.transaction_id);
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.sender);
                return writer;
            };

            /**
             * Encodes the specified MsgCancelSendToEth message, length delimited. Does not implicitly {@link gravity.v1.MsgCancelSendToEth.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgCancelSendToEth
             * @static
             * @param {gravity.v1.IMsgCancelSendToEth} message MsgCancelSendToEth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgCancelSendToEth.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgCancelSendToEth message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgCancelSendToEth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgCancelSendToEth} MsgCancelSendToEth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgCancelSendToEth.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgCancelSendToEth();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.transaction_id = reader.uint64();
                        break;
                    case 2:
                        message.sender = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgCancelSendToEth message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgCancelSendToEth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgCancelSendToEth} MsgCancelSendToEth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgCancelSendToEth.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgCancelSendToEth message.
             * @function verify
             * @memberof gravity.v1.MsgCancelSendToEth
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgCancelSendToEth.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                    if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                        return "transaction_id: integer|Long expected";
                if (message.sender != null && message.hasOwnProperty("sender"))
                    if (!$util.isString(message.sender))
                        return "sender: string expected";
                return null;
            };

            /**
             * Creates a MsgCancelSendToEth message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgCancelSendToEth
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgCancelSendToEth} MsgCancelSendToEth
             */
            MsgCancelSendToEth.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgCancelSendToEth)
                    return object;
                let message = new $root.gravity.v1.MsgCancelSendToEth();
                if (object.transaction_id != null)
                    if ($util.Long)
                        (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = true;
                    else if (typeof object.transaction_id === "string")
                        message.transaction_id = parseInt(object.transaction_id, 10);
                    else if (typeof object.transaction_id === "number")
                        message.transaction_id = object.transaction_id;
                    else if (typeof object.transaction_id === "object")
                        message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber(true);
                if (object.sender != null)
                    message.sender = String(object.sender);
                return message;
            };

            /**
             * Creates a plain object from a MsgCancelSendToEth message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgCancelSendToEth
             * @static
             * @param {gravity.v1.MsgCancelSendToEth} message MsgCancelSendToEth
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgCancelSendToEth.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.transaction_id = options.longs === String ? "0" : 0;
                    object.sender = "";
                }
                if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                    if (typeof message.transaction_id === "number")
                        object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                    else
                        object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber(true) : message.transaction_id;
                if (message.sender != null && message.hasOwnProperty("sender"))
                    object.sender = message.sender;
                return object;
            };

            /**
             * Converts this MsgCancelSendToEth to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgCancelSendToEth
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgCancelSendToEth.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgCancelSendToEth;
        })();

        v1.MsgCancelSendToEthResponse = (function() {

            /**
             * Properties of a MsgCancelSendToEthResponse.
             * @memberof gravity.v1
             * @interface IMsgCancelSendToEthResponse
             */

            /**
             * Constructs a new MsgCancelSendToEthResponse.
             * @memberof gravity.v1
             * @classdesc Represents a MsgCancelSendToEthResponse.
             * @implements IMsgCancelSendToEthResponse
             * @constructor
             * @param {gravity.v1.IMsgCancelSendToEthResponse=} [properties] Properties to set
             */
            function MsgCancelSendToEthResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified MsgCancelSendToEthResponse message. Does not implicitly {@link gravity.v1.MsgCancelSendToEthResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgCancelSendToEthResponse
             * @static
             * @param {gravity.v1.IMsgCancelSendToEthResponse} message MsgCancelSendToEthResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgCancelSendToEthResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified MsgCancelSendToEthResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgCancelSendToEthResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgCancelSendToEthResponse
             * @static
             * @param {gravity.v1.IMsgCancelSendToEthResponse} message MsgCancelSendToEthResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgCancelSendToEthResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgCancelSendToEthResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgCancelSendToEthResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgCancelSendToEthResponse} MsgCancelSendToEthResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgCancelSendToEthResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgCancelSendToEthResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgCancelSendToEthResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgCancelSendToEthResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgCancelSendToEthResponse} MsgCancelSendToEthResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgCancelSendToEthResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgCancelSendToEthResponse message.
             * @function verify
             * @memberof gravity.v1.MsgCancelSendToEthResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgCancelSendToEthResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a MsgCancelSendToEthResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgCancelSendToEthResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgCancelSendToEthResponse} MsgCancelSendToEthResponse
             */
            MsgCancelSendToEthResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgCancelSendToEthResponse)
                    return object;
                return new $root.gravity.v1.MsgCancelSendToEthResponse();
            };

            /**
             * Creates a plain object from a MsgCancelSendToEthResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgCancelSendToEthResponse
             * @static
             * @param {gravity.v1.MsgCancelSendToEthResponse} message MsgCancelSendToEthResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgCancelSendToEthResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this MsgCancelSendToEthResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgCancelSendToEthResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgCancelSendToEthResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgCancelSendToEthResponse;
        })();

        v1.MsgSubmitBadSignatureEvidence = (function() {

            /**
             * Properties of a MsgSubmitBadSignatureEvidence.
             * @memberof gravity.v1
             * @interface IMsgSubmitBadSignatureEvidence
             * @property {google.protobuf.IAny|null} [subject] MsgSubmitBadSignatureEvidence subject
             * @property {string|null} [signature] MsgSubmitBadSignatureEvidence signature
             * @property {string|null} [sender] MsgSubmitBadSignatureEvidence sender
             */

            /**
             * Constructs a new MsgSubmitBadSignatureEvidence.
             * @memberof gravity.v1
             * @classdesc Represents a MsgSubmitBadSignatureEvidence.
             * @implements IMsgSubmitBadSignatureEvidence
             * @constructor
             * @param {gravity.v1.IMsgSubmitBadSignatureEvidence=} [properties] Properties to set
             */
            function MsgSubmitBadSignatureEvidence(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MsgSubmitBadSignatureEvidence subject.
             * @member {google.protobuf.IAny|null|undefined} subject
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
             * @instance
             */
            MsgSubmitBadSignatureEvidence.prototype.subject = null;

            /**
             * MsgSubmitBadSignatureEvidence signature.
             * @member {string} signature
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
             * @instance
             */
            MsgSubmitBadSignatureEvidence.prototype.signature = "";

            /**
             * MsgSubmitBadSignatureEvidence sender.
             * @member {string} sender
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
             * @instance
             */
            MsgSubmitBadSignatureEvidence.prototype.sender = "";

            /**
             * Encodes the specified MsgSubmitBadSignatureEvidence message. Does not implicitly {@link gravity.v1.MsgSubmitBadSignatureEvidence.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
             * @static
             * @param {gravity.v1.IMsgSubmitBadSignatureEvidence} message MsgSubmitBadSignatureEvidence message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSubmitBadSignatureEvidence.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    $root.google.protobuf.Any.encode(message.subject, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.signature);
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.sender);
                return writer;
            };

            /**
             * Encodes the specified MsgSubmitBadSignatureEvidence message, length delimited. Does not implicitly {@link gravity.v1.MsgSubmitBadSignatureEvidence.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
             * @static
             * @param {gravity.v1.IMsgSubmitBadSignatureEvidence} message MsgSubmitBadSignatureEvidence message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSubmitBadSignatureEvidence.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgSubmitBadSignatureEvidence message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgSubmitBadSignatureEvidence} MsgSubmitBadSignatureEvidence
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSubmitBadSignatureEvidence.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSubmitBadSignatureEvidence();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subject = $root.google.protobuf.Any.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.signature = reader.string();
                        break;
                    case 3:
                        message.sender = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgSubmitBadSignatureEvidence message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgSubmitBadSignatureEvidence} MsgSubmitBadSignatureEvidence
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSubmitBadSignatureEvidence.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgSubmitBadSignatureEvidence message.
             * @function verify
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgSubmitBadSignatureEvidence.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subject != null && message.hasOwnProperty("subject")) {
                    let error = $root.google.protobuf.Any.verify(message.subject);
                    if (error)
                        return "subject." + error;
                }
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!$util.isString(message.signature))
                        return "signature: string expected";
                if (message.sender != null && message.hasOwnProperty("sender"))
                    if (!$util.isString(message.sender))
                        return "sender: string expected";
                return null;
            };

            /**
             * Creates a MsgSubmitBadSignatureEvidence message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgSubmitBadSignatureEvidence} MsgSubmitBadSignatureEvidence
             */
            MsgSubmitBadSignatureEvidence.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgSubmitBadSignatureEvidence)
                    return object;
                let message = new $root.gravity.v1.MsgSubmitBadSignatureEvidence();
                if (object.subject != null) {
                    if (typeof object.subject !== "object")
                        throw TypeError(".gravity.v1.MsgSubmitBadSignatureEvidence.subject: object expected");
                    message.subject = $root.google.protobuf.Any.fromObject(object.subject);
                }
                if (object.signature != null)
                    message.signature = String(object.signature);
                if (object.sender != null)
                    message.sender = String(object.sender);
                return message;
            };

            /**
             * Creates a plain object from a MsgSubmitBadSignatureEvidence message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
             * @static
             * @param {gravity.v1.MsgSubmitBadSignatureEvidence} message MsgSubmitBadSignatureEvidence
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgSubmitBadSignatureEvidence.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.subject = null;
                    object.signature = "";
                    object.sender = "";
                }
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = $root.google.protobuf.Any.toObject(message.subject, options);
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = message.signature;
                if (message.sender != null && message.hasOwnProperty("sender"))
                    object.sender = message.sender;
                return object;
            };

            /**
             * Converts this MsgSubmitBadSignatureEvidence to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidence
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgSubmitBadSignatureEvidence.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgSubmitBadSignatureEvidence;
        })();

        v1.MsgSubmitBadSignatureEvidenceResponse = (function() {

            /**
             * Properties of a MsgSubmitBadSignatureEvidenceResponse.
             * @memberof gravity.v1
             * @interface IMsgSubmitBadSignatureEvidenceResponse
             */

            /**
             * Constructs a new MsgSubmitBadSignatureEvidenceResponse.
             * @memberof gravity.v1
             * @classdesc Represents a MsgSubmitBadSignatureEvidenceResponse.
             * @implements IMsgSubmitBadSignatureEvidenceResponse
             * @constructor
             * @param {gravity.v1.IMsgSubmitBadSignatureEvidenceResponse=} [properties] Properties to set
             */
            function MsgSubmitBadSignatureEvidenceResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified MsgSubmitBadSignatureEvidenceResponse message. Does not implicitly {@link gravity.v1.MsgSubmitBadSignatureEvidenceResponse.verify|verify} messages.
             * @function encode
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
             * @static
             * @param {gravity.v1.IMsgSubmitBadSignatureEvidenceResponse} message MsgSubmitBadSignatureEvidenceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSubmitBadSignatureEvidenceResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified MsgSubmitBadSignatureEvidenceResponse message, length delimited. Does not implicitly {@link gravity.v1.MsgSubmitBadSignatureEvidenceResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
             * @static
             * @param {gravity.v1.IMsgSubmitBadSignatureEvidenceResponse} message MsgSubmitBadSignatureEvidenceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgSubmitBadSignatureEvidenceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MsgSubmitBadSignatureEvidenceResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gravity.v1.MsgSubmitBadSignatureEvidenceResponse} MsgSubmitBadSignatureEvidenceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSubmitBadSignatureEvidenceResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.gravity.v1.MsgSubmitBadSignatureEvidenceResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MsgSubmitBadSignatureEvidenceResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gravity.v1.MsgSubmitBadSignatureEvidenceResponse} MsgSubmitBadSignatureEvidenceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgSubmitBadSignatureEvidenceResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MsgSubmitBadSignatureEvidenceResponse message.
             * @function verify
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MsgSubmitBadSignatureEvidenceResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a MsgSubmitBadSignatureEvidenceResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gravity.v1.MsgSubmitBadSignatureEvidenceResponse} MsgSubmitBadSignatureEvidenceResponse
             */
            MsgSubmitBadSignatureEvidenceResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gravity.v1.MsgSubmitBadSignatureEvidenceResponse)
                    return object;
                return new $root.gravity.v1.MsgSubmitBadSignatureEvidenceResponse();
            };

            /**
             * Creates a plain object from a MsgSubmitBadSignatureEvidenceResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
             * @static
             * @param {gravity.v1.MsgSubmitBadSignatureEvidenceResponse} message MsgSubmitBadSignatureEvidenceResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MsgSubmitBadSignatureEvidenceResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this MsgSubmitBadSignatureEvidenceResponse to JSON.
             * @function toJSON
             * @memberof gravity.v1.MsgSubmitBadSignatureEvidenceResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MsgSubmitBadSignatureEvidenceResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MsgSubmitBadSignatureEvidenceResponse;
        })();

        /**
         * SignType enum.
         * @name gravity.v1.SignType
         * @enum {number}
         * @property {number} SIGN_TYPE_UNSPECIFIED=0 SIGN_TYPE_UNSPECIFIED value
         * @property {number} SIGN_TYPE_ORCHESTRATOR_SIGNED_MULTI_SIG_UPDATE=1 SIGN_TYPE_ORCHESTRATOR_SIGNED_MULTI_SIG_UPDATE value
         * @property {number} SIGN_TYPE_ORCHESTRATOR_SIGNED_WITHDRAW_BATCH=2 SIGN_TYPE_ORCHESTRATOR_SIGNED_WITHDRAW_BATCH value
         */
        v1.SignType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SIGN_TYPE_UNSPECIFIED"] = 0;
            values[valuesById[1] = "SIGN_TYPE_ORCHESTRATOR_SIGNED_MULTI_SIG_UPDATE"] = 1;
            values[valuesById[2] = "SIGN_TYPE_ORCHESTRATOR_SIGNED_WITHDRAW_BATCH"] = 2;
            return values;
        })();

        return v1;
    })();

    return gravity;
})();

export { $root as default };
