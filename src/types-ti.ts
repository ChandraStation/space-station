/**
 * This module was automatically generated by `ts-interface-builder`
 */
import * as t from 'ts-interface-checker';

// es-lint:disable:object-literal-key-quotes quotes

export const ThemeType = t.enumtype({
  Dark: 'dark',
  Light: 'light'
});

export const SupportedChain = t.enumtype({
  Eth: 'eth',
  Goerli: 'goerli',
  GravityBridge: 'gravityBridge',
  Osmosis: 'osmosis'
});

export const SupportedEthChain = t.enumtype({
  Eth: 'eth',
  Goerli: 'goerli'
});

export const SupportedCosmosChain = t.enumtype({
  GravityBridge: 'gravityBridge',
  Osmosis: 'osmosis'
});

export const IERC20Token = t.iface([], {
  chainId: 'string',
  address: 'string',
  name: t.opt('string'),
  decimals: 'number',
  symbol: 'string',
  logoURI: t.opt('string')
});

export const ICosmosToken = t.iface([], {
  chainId: 'string',
  denom: 'string',
  name: t.opt('string'),
  decimals: 'number',
  logoURI: t.opt('string'),
  isIbc: t.opt('boolean'),
  isErc20: t.opt('boolean')
});

export const TokenInfo = t.union('IERC20Token', 'ICosmosToken');

export const IToken = t.iface([], {
  isErc20: 'boolean',
  isCosmos: 'boolean',
  erc20: t.opt('IERC20Token'),
  cosmos: t.opt('ICosmosToken')
});

export const IAccount = t.iface([], {
  address: 'string',
  balance: 'string'
});

export const ICosmosSdkAccount = t.iface(['IAccount'], {
  pubKey: 'Uint8Array'
});

export const IEthAccount = t.iface(['IAccount'], {
});

export const SupportedAccount = t.union('ICosmosSdkAccount', 'IEthAccount');

export const EthWalletType = t.enumtype({
  MetaMask: 'MetaMask'
});

export const AccountChangeEventHandler = t.func('void', t.param('accounts', t.array('string')));

export const NetworkChangeEventHandler = t.func('void', t.param('data', 'any'));

export const IEthWalletManager = t.iface([], {
  init: t.func('void', t.param('ethChain', 'SupportedEthChain')),
  connect: t.func('void', t.param('chain', 'SupportedEthChain'), t.param('walletType', 'EthWalletType')),
  getERC20Info: t.func(t.union('IERC20Token', 'null'), t.param('chain', 'SupportedEthChain'), t.param('contractAddress', 'string')),
  updateAccount: t.func('void', t.param('chain', 'SupportedEthChain')),
  getERC20Balance: t.func('string', t.param('chain', 'SupportedEthChain'), t.param('contractAddress', 'string'), t.param('ownerAddress', 'string')),
  getWeb3: t.func(t.union('Web3Manager', 'null'), t.param('chain', 'SupportedEthChain'))
});

export const IEthWallet = t.iface([], {
  connect: t.func('void', t.param('chain', 'SupportedEthChain')),
  checkConnection: t.func('boolean', t.param('chain', 'SupportedEthChain')),
  getAccount: t.func('IEthAccount'),
  updateNetwork: t.func('boolean', t.param('chain', 'SupportedEthChain')),
  registerAccountChangeHandler: t.func('void', t.param('handler', 'AccountChangeEventHandler')),
  registerNetworkChangeHandler: t.func('void', t.param('handler', 'NetworkChangeEventHandler')),
  getWeb3: t.func(t.union('Web3Manager', 'null')),
  isSupportMultiConnection: t.func('boolean')
});

export const MetaMaskProvider = t.iface(['AbstractProvider', 'EventEmitter'], {
  isMetaMask: t.opt('boolean'),
  request: t.func('any', t.param('args', 'RequestArguments'))
});

export const EthChainInfo = t.iface([], {
  chainId: 'string'
});

export const CosmosWalletType = t.enumtype({
  Keplr: 'Keplr'
});

export const DirectSignDoc = t.iface([], {
  chainId: 'string',
  bodyBytes: 'Uint8Array',
  authInfoBytes: 'Uint8Array',
  accountNumber: 'Long'
});

export const ICosmosWalletManager = t.iface([], {
  init: t.func('void'),
  connect: t.func('void', t.param('chain', 'SupportedCosmosChain'), t.param('walletType', 'CosmosWalletType')),
  sign: t.func('DirectSignResponse', t.param('chain', 'SupportedCosmosChain'), t.param('messages', t.array('google.protobuf.IAny'))),
  broadcast: t.func('string', t.param('chain', 'SupportedCosmosChain'), t.param('txBytes', 'Uint8Array'), t.param('broadCastMode', 'cosmos.tx.v1beta1.BroadcastMode'))
});

export const ICosmosWallet = t.iface([], {
  connect: t.func('void', t.param('chainId', 'string')),
  getAccount: t.func('ICosmosSdkAccount', t.param('chainId', 'string')),
  sign: t.func('DirectSignResponse', t.param('chainId', 'string'), t.param('signer', 'string'), t.param('signDoc', 'cosmos.tx.v1beta1.SignDoc')),
  sendTx: t.func('Uint8Array', t.param('chainId', 'string'), t.param('txBytes', 'Uint8Array'), t.param('mode', 'BroadcastMode')),
  addChain: t.func('void', t.param('chainId', 'string')),
  onAccountChange: t.opt(t.func('any', t.param('handler', 'AccountChangeEventHandler'))),
  onNetworkChange: t.opt(t.func('any', t.param('handler', 'NetworkChangeEventHandler')))
});

export const Erc20ContractMethods = t.iface([], {
  balanceOf: t.func('ContractSendMethod', t.param('ethAddress', 'string')),
  name: t.func('ContractSendMethod'),
  decimals: t.func('ContractSendMethod'),
  symbol: t.func('ContractSendMethod'),
  approve: t.func('ContractSendMethod', t.param('spender', 'string'), t.param('amount', 'string'))
});

export const GravityBridgetContractMethods = t.iface([], {
  sendToCosmos: t.func('ContractSendMethod', t.param('erc20Address', 'string'), t.param('gravityBridgeAddress', 'string'), t.param('amount', 'string')),
  deployERC20: t.func('ContractSendMethod', t.param('cosmosDenom', 'string'), t.param('tokenName', 'string'), t.param('symbol', 'string'), t.param('decimal', 'number'))
});

export const Price = t.iface([], {
  currency: 'string',
  current_price: 'number'
});

export const PriceInfo = t.iface([], {
  denom: 'string',
  last_updated: 'string',
  prices: t.array('Price')
});

export const Fee = t.iface([], {
  id: 'number',
  label: 'string',
  denom: 'string',
  amount: 'string',
  amountInCurrency: 'string'
});

export const TransferEntity = t.name('IGravityBridgeTransferEntity');

export const IGravityBridgeTransferEntity = t.iface([], {
  fromChain: t.union(t.enumlit('SupportedChain', 'GravityBridge'), t.enumlit('SupportedChain', 'Eth'), t.enumlit('SupportedChain', 'Goerli')),
  toChain: t.union(t.enumlit('SupportedChain', 'GravityBridge'), t.enumlit('SupportedChain', 'Eth'), t.enumlit('SupportedChain', 'Goerli')),
  token: 'IERC20Token',
  fromAddress: 'string',
  toAddress: 'string',
  amount: 'string',
  fee: t.opt('Fee')
});

export const ITransferer = t.iface([], {
  transfer: t.func('string', t.param('entity', 'TransferEntity')),
  needBridgeFee: t.func('boolean', t.param('entity', 'TransferEntity')),
  getFees: t.func(t.array('Fee'), t.param('fromChain', 'SupportedChain'), t.param('toChain', 'SupportedChain'), t.param('token', 'IToken'), t.param('tokenPrice', 'string')),
  isSupported: t.func('boolean', t.param('entity', 'TransferEntity'))
});

const exportedTypeSuite: t.ITypeSuite = {
  ThemeType,
  SupportedChain,
  SupportedEthChain,
  SupportedCosmosChain,
  IERC20Token,
  ICosmosToken,
  TokenInfo,
  IToken,
  IAccount,
  ICosmosSdkAccount,
  IEthAccount,
  SupportedAccount,
  EthWalletType,
  AccountChangeEventHandler,
  NetworkChangeEventHandler,
  IEthWalletManager,
  IEthWallet,
  MetaMaskProvider,
  EthChainInfo,
  CosmosWalletType,
  DirectSignDoc,
  ICosmosWalletManager,
  ICosmosWallet,
  Erc20ContractMethods,
  GravityBridgetContractMethods,
  Price,
  PriceInfo,
  Fee,
  TransferEntity,
  IGravityBridgeTransferEntity,
  ITransferer
};
export default exportedTypeSuite;
